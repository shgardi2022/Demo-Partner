//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class CancellationReasonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderType (optional) 
     * @param orderStatus (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    cancelationReasons(orderType: OrderType | undefined, orderStatus: OrderStatus | undefined, accept_Language: any | undefined): Observable<CancellationReasonLightDto[]> {
        let url_ = this.baseUrl + "/api/1/CancellationReason/CancelationReasons?";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "orderType=" + encodeURIComponent("" + orderType) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            url_ += "orderStatus=" + encodeURIComponent("" + orderStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelationReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonLightDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonLightDto[]>;
        }));
    }

    protected processCancelationReasons(response: HttpResponseBase): Observable<CancellationReasonLightDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonLightDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CancellationReasonDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param freeSearch (optional) 
     * @param userType (optional) 
     * @param isActive (optional) 
     * @param isFinalClosure (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(freeSearch: string | undefined, userType: UserType | undefined, isActive: boolean | undefined, isFinalClosure: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<CancellationReasonDto[]> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/All?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isFinalClosure === null)
            throw new Error("The parameter 'isFinalClosure' cannot be null.");
        else if (isFinalClosure !== undefined)
            url_ += "IsFinalClosure=" + encodeURIComponent("" + isFinalClosure) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonDto[]>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<CancellationReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param freeSearch (optional) 
     * @param userType (optional) 
     * @param isActive (optional) 
     * @param isFinalClosure (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(freeSearch: string | undefined, userType: UserType | undefined, isActive: boolean | undefined, isFinalClosure: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<CancellationReasonDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/Page?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isFinalClosure === null)
            throw new Error("The parameter 'isFinalClosure' cannot be null.");
        else if (isFinalClosure !== undefined)
            url_ += "IsFinalClosure=" + encodeURIComponent("" + isFinalClosure) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<CancellationReasonDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: CreateCancellationReasonDto | undefined): Observable<CancellationReasonDto> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CancellationReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param year (optional) 
     * @param month (optional) 
     * @param cancelledBy (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getCancellationReasonPerDayLastWeek(year: number | undefined, month: number | undefined, cancelledBy: number | undefined, accept_Language: any | undefined): Observable<CancellationReasonByDayDto[]> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/GetCancellationReasonPerDayLastWeek?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (cancelledBy === null)
            throw new Error("The parameter 'cancelledBy' cannot be null.");
        else if (cancelledBy !== undefined)
            url_ += "CancelledBy=" + encodeURIComponent("" + cancelledBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationReasonPerDayLastWeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationReasonPerDayLastWeek(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonByDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonByDayDto[]>;
        }));
    }

    protected processGetCancellationReasonPerDayLastWeek(response: HttpResponseBase): Observable<CancellationReasonByDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonByDayDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param year (optional) 
     * @param month (optional) 
     * @param cancelledBy (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getCancellationReasonPerMonth(year: number | undefined, month: number | undefined, cancelledBy: number | undefined, accept_Language: any | undefined): Observable<CancellationReasonByDayDto[]> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/GetCancellationReasonPerMonth?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (cancelledBy === null)
            throw new Error("The parameter 'cancelledBy' cannot be null.");
        else if (cancelledBy !== undefined)
            url_ += "CancelledBy=" + encodeURIComponent("" + cancelledBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationReasonPerMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationReasonPerMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonByDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonByDayDto[]>;
        }));
    }

    protected processGetCancellationReasonPerMonth(response: HttpResponseBase): Observable<CancellationReasonByDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonByDayDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: CancellationReasonDto | undefined): Observable<CancellationReasonDto> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CancellationReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    enable(accept_Language: any | undefined, body: CancellationReasonEnableDto | undefined): Observable<CancellationReasonDto> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonDto>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<CancellationReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    toggleIsFinalClosure(accept_Language: any | undefined, body: CancellationReasonIsFinalClosureToggleDto | undefined): Observable<CancellationReasonDto> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/ToggleIsFinalClosure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleIsFinalClosure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleIsFinalClosure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReasonDto>;
        }));
    }

    protected processToggleIsFinalClosure(response: HttpResponseBase): Observable<CancellationReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CancellationReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delete(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/CancellationReasonDashboard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChangeingDriverReasonDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    get(id: number, accept_Language: any | undefined): Observable<ChangingDriverReasonDto> {
        let url_ = this.baseUrl + "/api/1/ChangeingDriverReasonDashBoard/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ChangingDriverReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getAll(sorting: string | undefined, accept_Language: any | undefined): Observable<ChangingDriverReasonDto[]> {
        let url_ = this.baseUrl + "/api/1/ChangeingDriverReasonDashBoard/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ChangingDriverReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: CreateChangingDriverReasonDto | undefined): Observable<ChangingDriverReasonDto> {
        let url_ = this.baseUrl + "/api/1/ChangeingDriverReasonDashBoard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ChangingDriverReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ChangingDriverReasonDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/ChangeingDriverReasonDashBoard/Page?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<ChangingDriverReasonDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateChangingDriverReasonDto | undefined): Observable<ChangingDriverReasonDto> {
        let url_ = this.baseUrl + "/api/1/ChangeingDriverReasonDashBoard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ChangingDriverReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param reorderingList (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    reOrderinglist(reorderingList: Int64ReOrderingDto[] | undefined, accept_Language: any | undefined): Observable<ChangingDriverReasonDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/ChangeingDriverReasonDashBoard/ReOrderinglist?";
        if (reorderingList === null)
            throw new Error("The parameter 'reorderingList' cannot be null.");
        else if (reorderingList !== undefined)
            reorderingList && reorderingList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "ReorderingList[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReOrderinglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReOrderinglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonDtoPaginatedList>;
        }));
    }

    protected processReOrderinglist(response: HttpResponseBase): Observable<ChangingDriverReasonDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChangingDriverReasonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    changingDriverReasons(accept_Language: any | undefined): Observable<ChangingDriverReasonLightDto[]> {
        let url_ = this.baseUrl + "/api/1/ChangingDriverReason/ChangingDriverReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangingDriverReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangingDriverReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangingDriverReasonLightDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangingDriverReasonLightDto[]>;
        }));
    }

    protected processChangingDriverReasons(response: HttpResponseBase): Observable<ChangingDriverReasonLightDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChangingDriverReasonLightDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getChats(orderId: string | undefined, accept_Language: any | undefined): Observable<ChatModel[]> {
        let url_ = this.baseUrl + "/api/1.1/Chat/GetChats?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatModel[]>;
        }));
    }

    protected processGetChats(response: HttpResponseBase): Observable<ChatModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getLastMessage(orderId: string | undefined, accept_Language: any | undefined): Observable<ChatModel> {
        let url_ = this.baseUrl + "/api/1.1/Chat/GetLastMessage?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatModel>;
        }));
    }

    protected processGetLastMessage(response: HttpResponseBase): Observable<ChatModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getUnreadMessagesCount(orderId: string | undefined, accept_Language: any | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1.1/Chat/GetUnreadMessagesCount?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnreadMessagesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnreadMessagesCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetUnreadMessagesCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    ordersUnreadMessagesCount(accept_Language: any | undefined, body: string[]): Observable<OrdersChatUnReadMessageCountDto[]> {
        let url_ = this.baseUrl + "/api/1.1/Chat/OrdersUnreadMessagesCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersUnreadMessagesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersUnreadMessagesCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersChatUnReadMessageCountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersChatUnReadMessageCountDto[]>;
        }));
    }

    protected processOrdersUnreadMessagesCount(response: HttpResponseBase): Observable<OrdersChatUnReadMessageCountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersChatUnReadMessageCountDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatDashbBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getOrderChats(orderId: string | undefined, accept_Language: any | undefined): Observable<ChatModel[]> {
        let url_ = this.baseUrl + "/api/1/ChatDashbBoard/GetOrderChats?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderChats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderChats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChatModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChatModel[]>;
        }));
    }

    protected processGetOrderChats(response: HttpResponseBase): Observable<ChatModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ClosingReasonDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isActive (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(isActive: boolean | undefined, accept_Language: any | undefined): Observable<ClosingReasonDto[]> {
        let url_ = this.baseUrl + "/api/1/ClosingReasonDashboard/All?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClosingReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClosingReasonDto[]>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ClosingReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClosingReasonDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ClosingReasonDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/ClosingReasonDashboard/Page?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClosingReasonDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClosingReasonDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<ClosingReasonDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClosingReasonDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: ClosingReasonCreateDto | undefined): Observable<ClosingReasonDto> {
        let url_ = this.baseUrl + "/api/1/ClosingReasonDashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClosingReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClosingReasonDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClosingReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClosingReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: ClosingReasonDto | undefined): Observable<ClosingReasonDto> {
        let url_ = this.baseUrl + "/api/1/ClosingReasonDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClosingReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClosingReasonDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClosingReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClosingReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DriversServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    statusGet(accept_Language: any | undefined): Observable<DriverStatusDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverStatusDto>;
        }));
    }

    protected processStatusGet(response: HttpResponseBase): Observable<DriverStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    statusPost(accept_Language: any | undefined, body: DriverStatusDto | undefined): Observable<DriverStatusDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverStatusDto>;
        }));
    }

    protected processStatusPost(response: HttpResponseBase): Observable<DriverStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    nearestdrivers(latitude: number | undefined, longitude: number | undefined, orderId: string | undefined, accept_Language: any | undefined): Observable<DriverDto[]> {
        let url_ = this.baseUrl + "/api/1/Drivers/nearestdrivers?";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNearestdrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNearestdrivers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverDto[]>;
        }));
    }

    protected processNearestdrivers(response: HttpResponseBase): Observable<DriverDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    asyncDriverLocation(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Drivers/AsyncDriverLocation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsyncDriverLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsyncDriverLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAsyncDriverLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    lastDriverLocationByOrder(orderId: string | undefined, accept_Language: any | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/LastDriverLocationByOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLastDriverLocationByOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLastDriverLocationByOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationDto>;
        }));
    }

    protected processLastDriverLocationByOrder(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LocationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CourierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param freeSearch (optional) 
     * @param driverStatus (optional) 
     * @param courierId (optional) 
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    currentstatus(freeSearch: string | undefined, driverStatus: DriverStatus | undefined, courierId: string | undefined, latitude: number | undefined, longitude: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<DriverCurrentStatusDto[]> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/Currentstatus?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (driverStatus === null)
            throw new Error("The parameter 'driverStatus' cannot be null.");
        else if (driverStatus !== undefined)
            url_ += "DriverStatus=" + encodeURIComponent("" + driverStatus) + "&";
        if (courierId === null)
            throw new Error("The parameter 'courierId' cannot be null.");
        else if (courierId !== undefined)
            url_ += "CourierId=" + encodeURIComponent("" + courierId) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverCurrentStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverCurrentStatusDto[]>;
        }));
    }

    protected processCurrentstatus(response: HttpResponseBase): Observable<DriverCurrentStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverCurrentStatusDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param freeSearch (optional) 
     * @param driverStatus (optional) 
     * @param courierId (optional) 
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allCurrentstatus(freeSearch: string | undefined, driverStatus: DriverStatus | undefined, courierId: string | undefined, latitude: number | undefined, longitude: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<AllDriverCurrentStatusDto> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/AllCurrentstatus?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (driverStatus === null)
            throw new Error("The parameter 'driverStatus' cannot be null.");
        else if (driverStatus !== undefined)
            url_ += "DriverStatus=" + encodeURIComponent("" + driverStatus) + "&";
        if (courierId === null)
            throw new Error("The parameter 'courierId' cannot be null.");
        else if (courierId !== undefined)
            url_ += "CourierId=" + encodeURIComponent("" + courierId) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllCurrentstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllCurrentstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllDriverCurrentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllDriverCurrentStatusDto>;
        }));
    }

    protected processAllCurrentstatus(response: HttpResponseBase): Observable<AllDriverCurrentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AllDriverCurrentStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    driverHistoryLocation(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderDriverLocation[]> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/DriverHistoryLocation?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverHistoryLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverHistoryLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDriverLocation[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDriverLocation[]>;
        }));
    }

    protected processDriverHistoryLocation(response: HttpResponseBase): Observable<OrderDriverLocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDriverLocation[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    removeDriverNotUpdatedHisLocations(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/RemoveDriverNotUpdatedHisLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDriverNotUpdatedHisLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDriverNotUpdatedHisLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDriverNotUpdatedHisLocations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param storeIds (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    ordersUsingPartnerAccept(storeIds: string[] | undefined, accept_Language: any | undefined): Observable<PartnerReceivedOrderDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/order/OrdersUsingPartnerAccept?";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersUsingPartnerAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersUsingPartnerAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerReceivedOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerReceivedOrderDto[]>;
        }));
    }

    protected processOrdersUsingPartnerAccept(response: HttpResponseBase): Observable<PartnerReceivedOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerReceivedOrderDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param freeSearch (optional) 
     * @param orderNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param orderStatus (optional) 
     * @param storeIds (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    currentOrderMapPreviewByStoresIDs(freeSearch: string | undefined, orderNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, orderStatus: OrderStatus[] | undefined, storeIds: string[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersCurrentStatusDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/CurrentOrderMapPreviewByStoresIDs?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentOrderMapPreviewByStoresIDs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentOrderMapPreviewByStoresIDs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersCurrentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersCurrentStatusDto>;
        }));
    }

    protected processCurrentOrderMapPreviewByStoresIDs(response: HttpResponseBase): Observable<OrdersCurrentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersCurrentStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    showStatisticsByStoresIds(accept_Language: any | undefined, body: string[] | undefined): Observable<StatisticsOrderDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/ShowStatisticsByStoresIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowStatisticsByStoresIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowStatisticsByStoresIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatisticsOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatisticsOrderDto>;
        }));
    }

    protected processShowStatisticsByStoresIds(response: HttpResponseBase): Observable<StatisticsOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatisticsOrderDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    pageByStoreId(accept_Language: any | undefined, body: OrderGetAllInputDto | undefined): Observable<OrdersViewDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/PageByStoreId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPageByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPageByStoreId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDtoPaginatedList>;
        }));
    }

    protected processPageByStoreId(response: HttpResponseBase): Observable<OrdersViewDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    partnerPageExcel(accept_Language: any | undefined, body: OrderGetAllInputDto | undefined): Observable<PartnerPageExcelDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/PartnerPageExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerPageExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerPageExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPageExcelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPageExcelDto>;
        }));
    }

    protected processPartnerPageExcel(response: HttpResponseBase): Observable<PartnerPageExcelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPageExcelDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    dashboardOrdersUsingPartnerAccept(accept_Language: any | undefined, body: string[] | undefined): Observable<PartnerReceivedOrderDto[]> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/DashboardOrdersUsingPartnerAccept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardOrdersUsingPartnerAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardOrdersUsingPartnerAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerReceivedOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerReceivedOrderDto[]>;
        }));
    }

    protected processDashboardOrdersUsingPartnerAccept(response: HttpResponseBase): Observable<PartnerReceivedOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerReceivedOrderDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationHistory(id: string, accept_Language: any | undefined): Observable<OrderHistoryDto[]> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/integrationHistory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderHistoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderHistoryDto[]>;
        }));
    }

    protected processIntegrationHistory(response: HttpResponseBase): Observable<OrderHistoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderHistoryDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationDriverLocations(orderId: string | undefined, accept_Language: any | undefined): Observable<DriverCurrentStatusDto[]> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/integrationDriverLocations?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationDriverLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationDriverLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverCurrentStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverCurrentStatusDto[]>;
        }));
    }

    protected processIntegrationDriverLocations(response: HttpResponseBase): Observable<DriverCurrentStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverCurrentStatusDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    integrationSetOrderIsDelivered(accept_Language: any | undefined, body: OrderDeliveredConfirmation | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/integrationSetOrderIsDelivered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationSetOrderIsDelivered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationSetOrderIsDelivered(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processIntegrationSetOrderIsDelivered(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationDriverHistoryLocation(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderDriverLocation[]> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/integrationDriverHistoryLocation?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationDriverHistoryLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationDriverHistoryLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDriverLocation[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDriverLocation[]>;
        }));
    }

    protected processIntegrationDriverHistoryLocation(response: HttpResponseBase): Observable<OrderDriverLocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDriverLocation[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationBuyer(id: string, accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/integrationBuyer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationBuyer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationBuyer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processIntegrationBuyer(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationStore(id: string, accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/order/integrationStore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processIntegrationStore(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    editOrderPut(accept_Language: any | undefined, body: OrderEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Orders/order/EditOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOrderPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOrderPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditOrderPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    userDelivered(accept_Language: any | undefined, body: OrderDeliveredConfirmation | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/Orders/order/UserDelivered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserDelivered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserDelivered(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processUserDelivered(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    userPaid(accept_Language: any | undefined, body: OrderPaidConfirmation | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/Orders/order/UserPaid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPaid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processUserPaid(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    userPaymentMethod(accept_Language: any | undefined, body: OrderPaymentMethod | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/Orders/order/UserPaymentMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPaymentMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPaymentMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processUserPaymentMethod(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    paymentStatus(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderPaymentStatus> {
        let url_ = this.baseUrl + "/api/1/Orders/order/PaymentStatus?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderPaymentStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderPaymentStatus>;
        }));
    }

    protected processPaymentStatus(response: HttpResponseBase): Observable<OrderPaymentStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderPaymentStatus;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    lastCompleted(accept_Language: any | undefined): Observable<LastCompeletedOrder> {
        let url_ = this.baseUrl + "/api/1/Orders/order/lastCompleted";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLastCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLastCompleted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LastCompeletedOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LastCompeletedOrder>;
        }));
    }

    protected processLastCompleted(response: HttpResponseBase): Observable<LastCompeletedOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LastCompeletedOrder;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getOrderStatus(orderId: string | undefined, accept_Language: any | undefined): Observable<GetOrderStatus> {
        let url_ = this.baseUrl + "/api/1/Orders/order/GetOrderStatus?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetOrderStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetOrderStatus>;
        }));
    }

    protected processGetOrderStatus(response: HttpResponseBase): Observable<GetOrderStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetOrderStatus;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setOrderPreparation(accept_Language: any | undefined, body: OrderPreparationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Orders/order/SetOrderPreparation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrderPreparation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrderPreparation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetOrderPreparation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    countCompeletedOrder(accept_Language: any | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1/Orders/order/CountCompeletedOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountCompeletedOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountCompeletedOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCountCompeletedOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    history(id: string, accept_Language: any | undefined): Observable<OrderHistoryDto[]> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderHistoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderHistoryDto[]>;
        }));
    }

    protected processHistory(response: HttpResponseBase): Observable<OrderHistoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderHistoryDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    buyer(id: string, accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/buyer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processBuyer(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    store(id: string, accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/store/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processStore(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driver(id: string, accept_Language: any | undefined): Observable<DriverDatailsDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/driver/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverDatailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverDatailsDto>;
        }));
    }

    protected processDriver(response: HttpResponseBase): Observable<DriverDatailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverDatailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    driverLocations(orderId: string | undefined, accept_Language: any | undefined): Observable<DriverCurrentStatusDto[]> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/DriverLocations?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverCurrentStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverCurrentStatusDto[]>;
        }));
    }

    protected processDriverLocations(response: HttpResponseBase): Observable<DriverCurrentStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverCurrentStatusDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    driverCanceledReason(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderDriverCanceledReasonDto[]> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/DriverCanceledReason?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverCanceledReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverCanceledReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDriverCanceledReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDriverCanceledReasonDto[]>;
        }));
    }

    protected processDriverCanceledReason(response: HttpResponseBase): Observable<OrderDriverCanceledReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDriverCanceledReasonDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    canceledReasons(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderCanceledReasonFullDto[]> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/CanceledReasons?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanceledReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanceledReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderCanceledReasonFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderCanceledReasonFullDto[]>;
        }));
    }

    protected processCanceledReasons(response: HttpResponseBase): Observable<OrderCanceledReasonFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderCanceledReasonFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/Page?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<OrdersViewDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    list(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDto[]> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/List?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDto[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<OrdersViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delayedList(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDto[]> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/DelayedList?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelayedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelayedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDto[]>;
        }));
    }

    protected processDelayedList(response: HttpResponseBase): Observable<OrdersViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    count(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/Count?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delayedOrderCount(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/DelayedOrderCount?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelayedOrderCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelayedOrderCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDelayedOrderCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param courierId (optional) 
     * @param orderStatus (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param user (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getCourierOrdersPage(courierId: string | undefined, orderStatus: OrderStatus[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, user: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/GetCourierOrdersPage?";
        if (courierId === null)
            throw new Error("The parameter 'courierId' cannot be null.");
        else if (courierId !== undefined)
            url_ += "CourierId=" + encodeURIComponent("" + courierId) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "User=" + encodeURIComponent("" + user) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourierOrdersPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourierOrdersPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDtoPaginatedList>;
        }));
    }

    protected processGetCourierOrdersPage(response: HttpResponseBase): Observable<OrdersViewDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param orderStatus (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param user (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerOrdersPage(partnerId: string | undefined, orderStatus: OrderStatus[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, user: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/GetPartnerOrdersPage?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "User=" + encodeURIComponent("" + user) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerOrdersPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerOrdersPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDtoPaginatedList>;
        }));
    }

    protected processGetPartnerOrdersPage(response: HttpResponseBase): Observable<OrdersViewDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param orderStatus (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param user (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getStoreOrdersPage(storeId: string | undefined, orderStatus: OrderStatus[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, user: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/GetStoreOrdersPage?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "User=" + encodeURIComponent("" + user) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreOrdersPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreOrdersPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDtoPaginatedList>;
        }));
    }

    protected processGetStoreOrdersPage(response: HttpResponseBase): Observable<OrdersViewDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param orderStatus (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param courier (optional) 
     * @param freeSearch (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getUserOrdersPage(userId: string | undefined, orderStatus: OrderStatus[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, courier: string | undefined, freeSearch: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersViewDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/GetUserOrdersPage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (courier === null)
            throw new Error("The parameter 'courier' cannot be null.");
        else if (courier !== undefined)
            url_ += "Courier=" + encodeURIComponent("" + courier) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserOrdersPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserOrdersPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersViewDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersViewDtoPaginatedList>;
        }));
    }

    protected processGetUserOrdersPage(response: HttpResponseBase): Observable<OrdersViewDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersViewDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    showStatistics(accept_Language: any | undefined): Observable<StatisticsOrderDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/ShowStatistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShowStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShowStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatisticsOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatisticsOrderDto>;
        }));
    }

    protected processShowStatistics(response: HttpResponseBase): Observable<StatisticsOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatisticsOrderDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param freeSearch (optional) 
     * @param orderNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param orderStatus (optional) 
     * @param storeIds (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    currentOrderMapPreview(freeSearch: string | undefined, orderNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, orderStatus: OrderStatus[] | undefined, storeIds: string[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrdersCurrentStatusDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/CurrentOrderMapPreview?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentOrderMapPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentOrderMapPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersCurrentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersCurrentStatusDto>;
        }));
    }

    protected processCurrentOrderMapPreview(response: HttpResponseBase): Observable<OrdersCurrentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersCurrentStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userType (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    topUsers(userType: UserType | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<TopUserDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/TopUsers?";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTopUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTopUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopUserDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopUserDtoPaginatedList>;
        }));
    }

    protected processTopUsers(response: HttpResponseBase): Observable<TopUserDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TopUserDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userType (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    topUsersCancelled(userType: UserType | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<TopUserDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/TopUsersCancelled?";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTopUsersCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTopUsersCancelled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopUserDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopUserDtoPaginatedList>;
        }));
    }

    protected processTopUsersCancelled(response: HttpResponseBase): Observable<TopUserDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TopUserDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    editOrderPost(accept_Language: any | undefined, body: OrderEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/EditOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOrderPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOrderPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditOrderPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateOrderPaymentStatus(accept_Language: any | undefined, body: OrderPaymentStatusRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/UpdateOrderPaymentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderPaymentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderPaymentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOrderPaymentStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setOrderIsDelivered(accept_Language: any | undefined, body: OrderDeliveredConfirmation | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/SetOrderIsDelivered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrderIsDelivered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrderIsDelivered(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processSetOrderIsDelivered(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    changePaymentMethod(accept_Language: any | undefined, body: OrderPaymentMethod | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/ChangePaymentMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePaymentMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePaymentMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processChangePaymentMethod(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param buyerId (optional) 
     * @param driverId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    setCashedOrderId(orderId: string | undefined, buyerId: string | undefined, driverId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/SetCashedOrderId?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (buyerId === null)
            throw new Error("The parameter 'buyerId' cannot be null.");
        else if (buyerId !== undefined)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCashedOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCashedOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetCashedOrderId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    cashedAllOrderIds(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/CashedAllOrderIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCashedAllOrderIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCashedAllOrderIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCashedAllOrderIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param buyerId (optional) 
     * @param driverId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkHaveOrderCashed(orderId: string | undefined, buyerId: string | undefined, driverId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/CheckHaveOrderCashed?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (buyerId === null)
            throw new Error("The parameter 'buyerId' cannot be null.");
        else if (buyerId !== undefined)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckHaveOrderCashed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckHaveOrderCashed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckHaveOrderCashed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    storePickupConfirmation(accept_Language: any | undefined, body: StorePickupConfirmationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/StorePickupConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStorePickupConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStorePickupConfirmation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStorePickupConfirmation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reSendOrderToPayment(accept_Language: any | undefined, body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/ReSendOrderToPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReSendOrderToPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReSendOrderToPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReSendOrderToPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param lat (optional) 
     * @param lng (optional) 
     * @param reduis (optional) 
     * @param title_Ar (optional) 
     * @param title_En (optional) 
     * @param mes_Ar (optional) 
     * @param mes_En (optional) 
     * @param userType (optional) 
     * @param isInbox (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    sendNotificationByLocation(lat: number | undefined, lng: number | undefined, reduis: number | undefined, title_Ar: string | undefined, title_En: string | undefined, mes_Ar: string | undefined, mes_En: string | undefined, userType: UserType | undefined, isInbox: boolean | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/SendNotificationByLocation?";
        if (lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (lng === null)
            throw new Error("The parameter 'lng' cannot be null.");
        else if (lng !== undefined)
            url_ += "Lng=" + encodeURIComponent("" + lng) + "&";
        if (reduis === null)
            throw new Error("The parameter 'reduis' cannot be null.");
        else if (reduis !== undefined)
            url_ += "Reduis=" + encodeURIComponent("" + reduis) + "&";
        if (title_Ar === null)
            throw new Error("The parameter 'title_Ar' cannot be null.");
        else if (title_Ar !== undefined)
            url_ += "Title.Ar=" + encodeURIComponent("" + title_Ar) + "&";
        if (title_En === null)
            throw new Error("The parameter 'title_En' cannot be null.");
        else if (title_En !== undefined)
            url_ += "Title.En=" + encodeURIComponent("" + title_En) + "&";
        if (mes_Ar === null)
            throw new Error("The parameter 'mes_Ar' cannot be null.");
        else if (mes_Ar !== undefined)
            url_ += "Mes.Ar=" + encodeURIComponent("" + mes_Ar) + "&";
        if (mes_En === null)
            throw new Error("The parameter 'mes_En' cannot be null.");
        else if (mes_En !== undefined)
            url_ += "Mes.En=" + encodeURIComponent("" + mes_En) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (isInbox === null)
            throw new Error("The parameter 'isInbox' cannot be null.");
        else if (isInbox !== undefined)
            url_ += "IsInbox=" + encodeURIComponent("" + isInbox) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotificationByLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotificationByLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendNotificationByLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param longitude (optional) 
     * @param latitude (optional) 
     * @param radius (optional) 
     * @param userType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    calculateSendNotificationaffectedUser(longitude: number | undefined, latitude: number | undefined, radius: number | undefined, userType: UserType | undefined, accept_Language: any | undefined): Observable<CalculateSendNotificationaffectedUserCountDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/CalculateSendNotificationaffectedUser?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (radius === null)
            throw new Error("The parameter 'radius' cannot be null.");
        else if (radius !== undefined)
            url_ += "Radius=" + encodeURIComponent("" + radius) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateSendNotificationaffectedUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateSendNotificationaffectedUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CalculateSendNotificationaffectedUserCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CalculateSendNotificationaffectedUserCountDto>;
        }));
    }

    protected processCalculateSendNotificationaffectedUser(response: HttpResponseBase): Observable<CalculateSendNotificationaffectedUserCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CalculateSendNotificationaffectedUserCountDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setOrderPreparationDashBoard(accept_Language: any | undefined, body: OrderPreparationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/SetOrderPreparationDashBoard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrderPreparationDashBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrderPreparationDashBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetOrderPreparationDashBoard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IntegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerAcceptOrjectInSeconds(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/PartnerAcceptOrjectInSeconds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerAcceptOrjectInSeconds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerAcceptOrjectInSeconds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartnerAcceptOrjectInSeconds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CatalogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    order(accept_Language: any | undefined, body: CreatePartnerOrderDto | undefined): Observable<CreateOrderResponseDto> {
        let url_ = this.baseUrl + "/api/1/Integration/catalog/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponseDto>;
        }));
    }

    protected processOrder(response: HttpResponseBase): Observable<CreateOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateOrderResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerintegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    order(accept_Language: any | undefined, body: CreateOrderFromIntegrationDto | undefined): Observable<CreateOrderResponseDto> {
        let url_ = this.baseUrl + "/api/1/Integration/partnerintegration/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponseDto>;
        }));
    }

    protected processOrder(response: HttpResponseBase): Observable<CreateOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateOrderResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IntegrationDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationPage(orderId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrderingNoteDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/integrationPage?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderingNoteDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderingNoteDtoPaginatedList>;
        }));
    }

    protected processIntegrationPage(response: HttpResponseBase): Observable<OrderingNoteDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderingNoteDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    integrationOrder(id: string, accept_Language: any | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/integrationOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processIntegrationOrder(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    dashBoardPartnerAcceptOrRjectInSeconds(accept_Language: any | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/DashBoardPartnerAcceptOrRjectInSeconds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashBoardPartnerAcceptOrRjectInSeconds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashBoardPartnerAcceptOrRjectInSeconds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDashBoardPartnerAcceptOrRjectInSeconds(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    pickupConfirmationFromStore(accept_Language: any | undefined, body: StorePickupConfirmationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/PickupConfirmationFromStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPickupConfirmationFromStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPickupConfirmationFromStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPickupConfirmationFromStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setOrderPreparation(accept_Language: any | undefined, body: OrderPreparationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/SetOrderPreparation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrderPreparation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrderPreparation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetOrderPreparation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrderDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/page?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<OrderDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrderingNoteDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    integrationCreate(accept_Language: any | undefined, body: OrderingNoteCreateDto | undefined): Observable<OrderingNoteDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/OrderingNoteDashBoard/integrationCreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderingNoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderingNoteDto>;
        }));
    }

    protected processIntegrationCreate(response: HttpResponseBase): Observable<OrderingNoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderingNoteDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(orderId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrderingNoteDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrderingNoteDashBoard/page?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderingNoteDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderingNoteDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<OrderingNoteDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderingNoteDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: OrderingNoteCreateDto | undefined): Observable<OrderingNoteDto> {
        let url_ = this.baseUrl + "/api/1/OrderingNoteDashBoard/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderingNoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderingNoteDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrderingNoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderingNoteDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IntegrationOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driver(id: string, accept_Language: any | undefined): Observable<DriverDatailsDto> {
        let url_ = this.baseUrl + "/api/1/IntegrationDashBoard/integrationOrder/driver/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverDatailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverDatailsDto>;
        }));
    }

    protected processDriver(response: HttpResponseBase): Observable<DriverDatailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverDatailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrdersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    order(accept_Language: any | undefined, body: CreateOrderDto | undefined): Observable<CreateOrderResponseDto> {
        let url_ = this.baseUrl + "/api/1/Orders/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponseDto>;
        }));
    }

    protected processOrder(response: HttpResponseBase): Observable<CreateOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateOrderResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    partnerOrder(accept_Language: any | undefined, body: CreatePartnerOrderDto | undefined): Observable<CreateOrderResponseDto> {
        let url_ = this.baseUrl + "/api/1/Orders/partnerOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponseDto>;
        }));
    }

    protected processPartnerOrder(response: HttpResponseBase): Observable<CreateOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateOrderResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    reCreateOrder(orderId: string | undefined, accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Orders/ReCreateOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReCreateOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processReCreateOrder(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    orderStore(accept_Language: any | undefined, body: CreateOrderFromStoreDto | undefined): Observable<CreateOrderResponseDto> {
        let url_ = this.baseUrl + "/api/1/Orders/orderStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponseDto>;
        }));
    }

    protected processOrderStore(response: HttpResponseBase): Observable<CreateOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateOrderResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    integrationOrderStore(accept_Language: any | undefined, body: CreateIntegrationOrderFromStoreRequestDto | undefined): Observable<CreateIntegrationOrderResponseDto> {
        let url_ = this.baseUrl + "/api/1/Orders/integrationOrderStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationOrderStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationOrderStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateIntegrationOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateIntegrationOrderResponseDto>;
        }));
    }

    protected processIntegrationOrderStore(response: HttpResponseBase): Observable<CreateIntegrationOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateIntegrationOrderResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    all(accept_Language: any | undefined): Observable<MyOrderDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyOrderDto[]>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<MyOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MyOrderDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getOrdersIds(accept_Language: any | undefined): Observable<OrderDdlDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/GetOrdersIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDdlDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDdlDto[]>;
        }));
    }

    protected processGetOrdersIds(response: HttpResponseBase): Observable<OrderDdlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDdlDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderNumber (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getOrderByNumber(orderNumber: string | undefined, accept_Language: any | undefined): Observable<OrderStateResultDto> {
        let url_ = this.baseUrl + "/api/1/Orders/GetOrderByNumber?";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "orderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderByNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderByNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStateResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStateResultDto>;
        }));
    }

    protected processGetOrderByNumber(response: HttpResponseBase): Observable<OrderStateResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderStateResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    listOrders(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrderDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Orders/ListOrders?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDtoPaginatedList>;
        }));
    }

    protected processListOrders(response: HttpResponseBase): Observable<OrderDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    listOrdersPerYear(accept_Language: any | undefined): Observable<OrdersPerYearDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/ListOrdersPerYear";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOrdersPerYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOrdersPerYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersPerYearDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersPerYearDto[]>;
        }));
    }

    protected processListOrdersPerYear(response: HttpResponseBase): Observable<OrdersPerYearDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersPerYearDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    listOrdersPerDay(createdDate: moment.Moment, accept_Language: any | undefined): Observable<OrdersPerDayDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/ListOrdersPerDay?";
        if (createdDate === undefined || createdDate === null)
            throw new Error("The parameter 'createdDate' must be defined and cannot be null.");
        else
            url_ += "CreatedDate=" + encodeURIComponent(createdDate ? "" + createdDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOrdersPerDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOrdersPerDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersPerDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersPerDayDto[]>;
        }));
    }

    protected processListOrdersPerDay(response: HttpResponseBase): Observable<OrdersPerDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersPerDayDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    listOrdersPerWeek(dateFrom: moment.Moment, dateTo: moment.Moment, accept_Language: any | undefined): Observable<OrdersPerWeekDayDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/ListOrdersPerWeek?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOrdersPerWeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOrdersPerWeek(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersPerWeekDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersPerWeekDayDto[]>;
        }));
    }

    protected processListOrdersPerWeek(response: HttpResponseBase): Observable<OrdersPerWeekDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrdersPerWeekDayDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    driverLocations(orderId: string | undefined, accept_Language: any | undefined): Observable<LocationSocketObject[]> {
        let url_ = this.baseUrl + "/api/1/Orders/DriverLocations?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationSocketObject[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationSocketObject[]>;
        }));
    }

    protected processDriverLocations(response: HttpResponseBase): Observable<LocationSocketObject[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LocationSocketObject[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    ordersHitMap(latitude: number, longitude: number, accept_Language: any | undefined): Observable<OrderHitMap[]> {
        let url_ = this.baseUrl + "/api/1/Orders/OrdersHitMap?";
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersHitMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersHitMap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderHitMap[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderHitMap[]>;
        }));
    }

    protected processOrdersHitMap(response: HttpResponseBase): Observable<OrderHitMap[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderHitMap[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param highestPrice (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    orderQueue(location_Latitude: number, location_Longitude: number, highestPrice: boolean | undefined, accept_Language: any | undefined): Observable<ReceivedOrderQueueEventModel[]> {
        let url_ = this.baseUrl + "/api/1/Orders/OrderQueue?";
        if (location_Latitude === undefined || location_Latitude === null)
            throw new Error("The parameter 'location_Latitude' must be defined and cannot be null.");
        else
            url_ += "Location.Latitude=" + encodeURIComponent("" + location_Latitude) + "&";
        if (location_Longitude === undefined || location_Longitude === null)
            throw new Error("The parameter 'location_Longitude' must be defined and cannot be null.");
        else
            url_ += "Location.Longitude=" + encodeURIComponent("" + location_Longitude) + "&";
        if (highestPrice === null)
            throw new Error("The parameter 'highestPrice' cannot be null.");
        else if (highestPrice !== undefined)
            url_ += "HighestPrice=" + encodeURIComponent("" + highestPrice) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderQueue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderQueue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceivedOrderQueueEventModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceivedOrderQueueEventModel[]>;
        }));
    }

    protected processOrderQueue(response: HttpResponseBase): Observable<ReceivedOrderQueueEventModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReceivedOrderQueueEventModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    checkAvailabilityFemaleDriver(latitude: number, longitude: number, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Orders/CheckAvailabilityFemaleDriver?";
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAvailabilityFemaleDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAvailabilityFemaleDriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckAvailabilityFemaleDriver(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    state(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderUserResultDto> {
        let url_ = this.baseUrl + "/api/1/Orders/User/State?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderUserResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderUserResultDto>;
        }));
    }

    protected processState(response: HttpResponseBase): Observable<OrderUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderUserResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    currentOrders(accept_Language: any | undefined): Observable<UserAndDriverOrderDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/User/CurrentOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAndDriverOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAndDriverOrderDto[]>;
        }));
    }

    protected processCurrentOrders(response: HttpResponseBase): Observable<UserAndDriverOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAndDriverOrderDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    ordersCount(accept_Language: any | undefined): Observable<UserOrdersCountDto> {
        let url_ = this.baseUrl + "/api/1/Orders/User/OrdersCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserOrdersCountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserOrdersCountDto>;
        }));
    }

    protected processOrdersCount(response: HttpResponseBase): Observable<UserOrdersCountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserOrdersCountDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    requestOrder(accept_Language: any | undefined, body: OrderIdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Orders/User/RequestOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    state(orderId: string | undefined, accept_Language: any | undefined): Observable<OrderDriverResultDto> {
        let url_ = this.baseUrl + "/api/1/Orders/Driver/State?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDriverResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDriverResultDto>;
        }));
    }

    protected processState(response: HttpResponseBase): Observable<OrderDriverResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDriverResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    currentOrders(accept_Language: any | undefined): Observable<UserAndDriverOrderDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/Driver/CurrentOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAndDriverOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAndDriverOrderDto[]>;
        }));
    }

    protected processCurrentOrders(response: HttpResponseBase): Observable<UserAndDriverOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAndDriverOrderDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    state(orderId: string | undefined, storeId: string | undefined, accept_Language: any | undefined): Observable<OrderStoreResultDto> {
        let url_ = this.baseUrl + "/api/1/Orders/Store/State?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStoreResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStoreResultDto>;
        }));
    }

    protected processState(response: HttpResponseBase): Observable<OrderStoreResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderStoreResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    currentOrders(storeId: string | undefined, accept_Language: any | undefined): Observable<UserAndDriverOrderDto[]> {
        let url_ = this.baseUrl + "/api/1/Orders/Store/CurrentOrders?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAndDriverOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAndDriverOrderDto[]>;
        }));
    }

    protected processCurrentOrders(response: HttpResponseBase): Observable<UserAndDriverOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserAndDriverOrderDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    requestOrder(accept_Language: any | undefined, body: OrderEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Orders/Store/RequestOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrdersDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    order(id: string, accept_Language: any | undefined): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processOrder(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderStatus (optional) 
     * @param orderType (optional) 
     * @param paymentType (optional) 
     * @param createdAt (optional) 
     * @param orderNumber (optional) 
     * @param freeSearch (optional) 
     * @param userName (optional) 
     * @param userPhoneNumber (optional) 
     * @param courierName (optional) 
     * @param courierPhoneNumber (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param storeIds (optional) 
     * @param delayedOrders (optional) 
     * @param delayedOrderMin (optional) 
     * @param closingReasonId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(orderStatus: OrderStatus[] | undefined, orderType: OrderType[] | undefined, paymentType: PaymentType[] | undefined, createdAt: moment.Moment | undefined, orderNumber: string | undefined, freeSearch: string | undefined, userName: string | undefined, userPhoneNumber: string | undefined, courierName: string | undefined, courierPhoneNumber: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, storeIds: string[] | undefined, delayedOrders: OrderStatus | undefined, delayedOrderMin: number | undefined, closingReasonId: number[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<OrderDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/OrdersDashBoard/page?";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            orderStatus && orderStatus.forEach(item => { url_ += "OrderStatus=" + encodeURIComponent("" + item) + "&"; });
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            orderType && orderType.forEach(item => { url_ += "OrderType=" + encodeURIComponent("" + item) + "&"; });
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            paymentType && paymentType.forEach(item => { url_ += "PaymentType=" + encodeURIComponent("" + item) + "&"; });
        if (createdAt === null)
            throw new Error("The parameter 'createdAt' cannot be null.");
        else if (createdAt !== undefined)
            url_ += "CreatedAt=" + encodeURIComponent(createdAt ? "" + createdAt.toISOString() : "") + "&";
        if (orderNumber === null)
            throw new Error("The parameter 'orderNumber' cannot be null.");
        else if (orderNumber !== undefined)
            url_ += "OrderNumber=" + encodeURIComponent("" + orderNumber) + "&";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (userPhoneNumber === null)
            throw new Error("The parameter 'userPhoneNumber' cannot be null.");
        else if (userPhoneNumber !== undefined)
            url_ += "UserPhoneNumber=" + encodeURIComponent("" + userPhoneNumber) + "&";
        if (courierName === null)
            throw new Error("The parameter 'courierName' cannot be null.");
        else if (courierName !== undefined)
            url_ += "CourierName=" + encodeURIComponent("" + courierName) + "&";
        if (courierPhoneNumber === null)
            throw new Error("The parameter 'courierPhoneNumber' cannot be null.");
        else if (courierPhoneNumber !== undefined)
            url_ += "CourierPhoneNumber=" + encodeURIComponent("" + courierPhoneNumber) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (delayedOrders === null)
            throw new Error("The parameter 'delayedOrders' cannot be null.");
        else if (delayedOrders !== undefined)
            url_ += "DelayedOrders=" + encodeURIComponent("" + delayedOrders) + "&";
        if (delayedOrderMin === null)
            throw new Error("The parameter 'delayedOrderMin' cannot be null.");
        else if (delayedOrderMin !== undefined)
            url_ += "delayedOrderMin=" + encodeURIComponent("" + delayedOrderMin) + "&";
        if (closingReasonId === null)
            throw new Error("The parameter 'closingReasonId' cannot be null.");
        else if (closingReasonId !== undefined)
            closingReasonId && closingReasonId.forEach(item => { url_ += "ClosingReasonId=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<OrderDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CashbackPolicyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    voucherById(id: string, accept_Language: any | undefined): Observable<CashbackVoucherDto> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicy/CashbackPolicy/VoucherById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashbackVoucherDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashbackVoucherDto>;
        }));
    }

    protected processVoucherById(response: HttpResponseBase): Observable<CashbackVoucherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CashbackVoucherDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param buyerId (optional) 
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    voucher(buyerId: string | undefined, partnerId: string, storeId: string | undefined, accept_Language: any | undefined): Observable<CashbackVoucherDto[]> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicy/CashbackPolicy/Voucher?";
        if (buyerId === null)
            throw new Error("The parameter 'buyerId' cannot be null.");
        else if (buyerId !== undefined)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (partnerId === undefined || partnerId === null)
            throw new Error("The parameter 'partnerId' must be defined and cannot be null.");
        else
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashbackVoucherDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashbackVoucherDto[]>;
        }));
    }

    protected processVoucher(response: HttpResponseBase): Observable<CashbackVoucherDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CashbackVoucherDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param voucherStatus (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    voucherStatus(voucherStatus: VoucherStatus | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<CashbackVoucherDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicy/CashbackPolicy/VoucherStatus?";
        if (voucherStatus === null)
            throw new Error("The parameter 'voucherStatus' cannot be null.");
        else if (voucherStatus !== undefined)
            url_ += "VoucherStatus=" + encodeURIComponent("" + voucherStatus) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoucherStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashbackVoucherDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashbackVoucherDtoPaginatedList>;
        }));
    }

    protected processVoucherStatus(response: HttpResponseBase): Observable<CashbackVoucherDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CashbackVoucherDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    externalVoucher(accept_Language: any | undefined, body: CashbackExternalVoucherCreateDto | undefined): Observable<CashbackVoucherDto> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicy/CashbackPolicy/ExternalVoucher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalVoucher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalVoucher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashbackVoucherDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashbackVoucherDto>;
        }));
    }

    protected processExternalVoucher(response: HttpResponseBase): Observable<CashbackVoucherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CashbackVoucherDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerCashbackPolicyDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    gey(id: string, accept_Language: any | undefined): Observable<PartnerCashbackPolicyDto> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Gey/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerCashbackPolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerCashbackPolicyDto>;
        }));
    }

    protected processGey(response: HttpResponseBase): Observable<PartnerCashbackPolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerCashbackPolicyDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param storeId (optional) 
     * @param policyName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param isActive (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(partnerId: string | undefined, storeId: string | undefined, policyName: string | undefined, startDate: string | undefined, endDate: string | undefined, isActive: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerCashbackPolicyDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/All?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (policyName === null)
            throw new Error("The parameter 'policyName' cannot be null.");
        else if (policyName !== undefined)
            url_ += "PolicyName=" + encodeURIComponent("" + policyName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerCashbackPolicyDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerCashbackPolicyDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<PartnerCashbackPolicyDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerCashbackPolicyDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: PartnerCashbackPolicyCreateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: PartnerCashbackPolicyUpdateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: PartnerCashbackPolicyActivateDto | undefined): Observable<PartnerCashbackPolicyDto> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerCashbackPolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerCashbackPolicyDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<PartnerCashbackPolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerCashbackPolicyDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cashbackPolicyId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delete(cashbackPolicyId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Delete?";
        if (cashbackPolicyId === null)
            throw new Error("The parameter 'cashbackPolicyId' cannot be null.");
        else if (cashbackPolicyId !== undefined)
            url_ += "cashbackPolicyId=" + encodeURIComponent("" + cashbackPolicyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param policyId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    policyCodes(policyId: string | undefined, accept_Language: any | undefined): Observable<PartnerCashbackPolicyCodeDto[]> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/policyCodes?";
        if (policyId === null)
            throw new Error("The parameter 'policyId' cannot be null.");
        else if (policyId !== undefined)
            url_ += "policyId=" + encodeURIComponent("" + policyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPolicyCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPolicyCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerCashbackPolicyCodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerCashbackPolicyCodeDto[]>;
        }));
    }

    protected processPolicyCodes(response: HttpResponseBase): Observable<PartnerCashbackPolicyCodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerCashbackPolicyCodeDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: DashBoardCashbackPolicyCreateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Dashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: DashBoardCashbackPolicyUpdateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Dashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: PartnerCashbackPolicyActivateDto | undefined): Observable<PartnerCashbackPolicyDto> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Dashboard/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerCashbackPolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerCashbackPolicyDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<PartnerCashbackPolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerCashbackPolicyDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cashbackPolicyId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delete(cashbackPolicyId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerCashbackPolicyDashBoard/Dashboard/Delete?";
        if (cashbackPolicyId === null)
            throw new Error("The parameter 'cashbackPolicyId' cannot be null.");
        else if (cashbackPolicyId !== undefined)
            url_ += "cashbackPolicyId=" + encodeURIComponent("" + cashbackPolicyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerPromoCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param partnerId (optional) 
     * @param storeId (optional) 
     * @param orderPrice (optional) 
     * @param paymentTypeId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    consume(code: string | undefined, partnerId: string | undefined, storeId: string | undefined, orderPrice: number | undefined, paymentTypeId: PaymentType | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, orderId: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeConsumeResultDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoCodes/consume?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (orderPrice === null)
            throw new Error("The parameter 'orderPrice' cannot be null.");
        else if (orderPrice !== undefined)
            url_ += "OrderPrice=" + encodeURIComponent("" + orderPrice) + "&";
        if (paymentTypeId === null)
            throw new Error("The parameter 'paymentTypeId' cannot be null.");
        else if (paymentTypeId !== undefined)
            url_ += "PaymentTypeId=" + encodeURIComponent("" + paymentTypeId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsume(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsume(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeConsumeResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeConsumeResultDto>;
        }));
    }

    protected processConsume(response: HttpResponseBase): Observable<PartnerPromoCodeConsumeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeConsumeResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentTypes (optional) 
     * @param orderId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    consumeMultiplePayments(code: string, partnerId: string, storeId: string, orderPrice: number, paymentTypes: PaymentType[] | undefined, orderId: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeConsumeResultDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoCodes/ConsumeMultiplePayments?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (partnerId === undefined || partnerId === null)
            throw new Error("The parameter 'partnerId' must be defined and cannot be null.");
        else
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined and cannot be null.");
        else
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (orderPrice === undefined || orderPrice === null)
            throw new Error("The parameter 'orderPrice' must be defined and cannot be null.");
        else
            url_ += "OrderPrice=" + encodeURIComponent("" + orderPrice) + "&";
        if (paymentTypes === null)
            throw new Error("The parameter 'paymentTypes' cannot be null.");
        else if (paymentTypes !== undefined)
            paymentTypes && paymentTypes.forEach(item => { url_ += "PaymentTypes=" + encodeURIComponent("" + item) + "&"; });
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsumeMultiplePayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsumeMultiplePayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeConsumeResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeConsumeResultDto>;
        }));
    }

    protected processConsumeMultiplePayments(response: HttpResponseBase): Observable<PartnerPromoCodeConsumeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeConsumeResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param serviceTypeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    available(partnerId: string, storeId: string, orderPrice: number, serviceTypeId: number | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeAvailableResultDto[]> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoCodes/available?";
        if (partnerId === undefined || partnerId === null)
            throw new Error("The parameter 'partnerId' must be defined and cannot be null.");
        else
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined and cannot be null.");
        else
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (orderPrice === undefined || orderPrice === null)
            throw new Error("The parameter 'orderPrice' must be defined and cannot be null.");
        else
            url_ += "OrderPrice=" + encodeURIComponent("" + orderPrice) + "&";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeAvailableResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeAvailableResultDto[]>;
        }));
    }

    protected processAvailable(response: HttpResponseBase): Observable<PartnerPromoCodeAvailableResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeAvailableResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param serviceTypeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promoCodeSummary(partnerId: string, storeId: string, orderPrice: number, serviceTypeId: number | undefined, accept_Language: any | undefined): Observable<PromoCodeSummaryDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoCodes/PromoCodeSummary?";
        if (partnerId === undefined || partnerId === null)
            throw new Error("The parameter 'partnerId' must be defined and cannot be null.");
        else
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined and cannot be null.");
        else
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (orderPrice === undefined || orderPrice === null)
            throw new Error("The parameter 'orderPrice' must be defined and cannot be null.");
        else
            url_ += "OrderPrice=" + encodeURIComponent("" + orderPrice) + "&";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromoCodeSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromoCodeSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeSummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeSummaryDto>;
        }));
    }

    protected processPromoCodeSummary(response: HttpResponseBase): Observable<PromoCodeSummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeSummaryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerPromoDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number, accept_Language: any | undefined): Observable<PartnerPromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDto>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<PartnerPromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param isPercentageDiscount (optional) 
     * @param discountValue (optional) 
     * @param isActive (optional) 
     * @param partnerId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(code: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, isPercentageDiscount: boolean | undefined, discountValue: number | undefined, isActive: boolean | undefined, partnerId: string | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/All?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (isPercentageDiscount === null)
            throw new Error("The parameter 'isPercentageDiscount' cannot be null.");
        else if (isPercentageDiscount !== undefined)
            url_ += "IsPercentageDiscount=" + encodeURIComponent("" + isPercentageDiscount) + "&";
        if (discountValue === null)
            throw new Error("The parameter 'discountValue' cannot be null.");
        else if (discountValue !== undefined)
            url_ += "DiscountValue=" + encodeURIComponent("" + discountValue) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<PartnerPromoCodeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodePost(accept_Language: any | undefined, body: PartnerPromoCodeCreateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processPromocodePost(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodePut(accept_Language: any | undefined, body: PartnerPromoCodeUpdateDto | undefined): Observable<PartnerPromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDto>;
        }));
    }

    protected processPromocodePut(response: HttpResponseBase): Observable<PartnerPromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodeDelete(accept_Language: any | undefined, body: PartnerPromoCodeDeleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPromocodeDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: PartnerPromoCodeActivateDto | undefined): Observable<PartnerPromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<PartnerPromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param promoCode (optional) 
     * @param partnerId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promoCodeConsuming(fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, promoCode: string | undefined, partnerId: string | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeConsumingResultDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/PromoCodeConsuming?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "PromoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromoCodeConsuming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromoCodeConsuming(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeConsumingResultDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeConsumingResultDtoPaginatedList>;
        }));
    }

    protected processPromoCodeConsuming(response: HttpResponseBase): Observable<PartnerPromoCodeConsumingResultDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeConsumingResultDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param promoCode (optional) 
     * @param partnerId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    consume(fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, promoCode: string | undefined, partnerId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeConsumingResultDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoDashBoard/consume?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "PromoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsume(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsume(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeConsumingResultDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeConsumingResultDtoPaginatedList>;
        }));
    }

    protected processConsume(response: HttpResponseBase): Observable<PartnerPromoCodeConsumingResultDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeConsumingResultDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerPromoPartnerDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number, accept_Language: any | undefined): Observable<PartnerPromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDto>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<PartnerPromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param isPercentageDiscount (optional) 
     * @param discountValue (optional) 
     * @param isActive (optional) 
     * @param partnerId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(code: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, isPercentageDiscount: boolean | undefined, discountValue: number | undefined, isActive: boolean | undefined, partnerId: string | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/All?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (isPercentageDiscount === null)
            throw new Error("The parameter 'isPercentageDiscount' cannot be null.");
        else if (isPercentageDiscount !== undefined)
            url_ += "IsPercentageDiscount=" + encodeURIComponent("" + isPercentageDiscount) + "&";
        if (discountValue === null)
            throw new Error("The parameter 'discountValue' cannot be null.");
        else if (discountValue !== undefined)
            url_ += "DiscountValue=" + encodeURIComponent("" + discountValue) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<PartnerPromoCodeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodePost(accept_Language: any | undefined, body: PartnerPromoCodeCreateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processPromocodePost(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodePut(accept_Language: any | undefined, body: PartnerPromoCodeUpdateDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processPromocodePut(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodeDelete(accept_Language: any | undefined, body: PartnerPromoCodeDeleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPromocodeDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: PartnerPromoCodeActivateDto | undefined): Observable<PartnerPromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<PartnerPromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param promoCode (optional) 
     * @param partnerId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promoCodeConsuming(fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, promoCode: string | undefined, partnerId: string | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeConsumingResultDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/PromoCodeConsuming?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "PromoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromoCodeConsuming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromoCodeConsuming(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeConsumingResultDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeConsumingResultDtoPaginatedList>;
        }));
    }

    protected processPromoCodeConsuming(response: HttpResponseBase): Observable<PartnerPromoCodeConsumingResultDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeConsumingResultDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param partnerId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promoCodeConsumingById(id: number | undefined, partnerId: string | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, accept_Language: any | undefined): Observable<PartnerPromoCodeConsumingResultDto> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/PromoCodeConsumingById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromoCodeConsumingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromoCodeConsumingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPromoCodeConsumingResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPromoCodeConsumingResultDto>;
        }));
    }

    protected processPromoCodeConsumingById(response: HttpResponseBase): Observable<PartnerPromoCodeConsumingResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPromoCodeConsumingResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param partnerId (optional) 
     * @param partnerPromoCodeType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPromoCodeByDay(id: number | undefined, partnerId: string | undefined, partnerPromoCodeType: PartnerPromoCodeType | undefined, accept_Language: any | undefined): Observable<PromoCodeByDayDto[]> {
        let url_ = this.baseUrl + "/api/1/PartnerPromoPartnerDashBoard/getPromoCodeByDay?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (partnerPromoCodeType === null)
            throw new Error("The parameter 'partnerPromoCodeType' cannot be null.");
        else if (partnerPromoCodeType !== undefined)
            url_ += "PartnerPromoCodeType=" + encodeURIComponent("" + partnerPromoCodeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromoCodeByDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromoCodeByDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeByDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeByDayDto[]>;
        }));
    }

    protected processGetPromoCodeByDay(response: HttpResponseBase): Observable<PromoCodeByDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeByDayDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PromoCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promocode(code: string | undefined, accept_Language: any | undefined): Observable<PromoCodeResponseVM> {
        let url_ = this.baseUrl + "/api/1/PromoCodes/promocode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeResponseVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeResponseVM>;
        }));
    }

    protected processPromocode(response: HttpResponseBase): Observable<PromoCodeResponseVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeResponseVM;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param serviceTypeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    availablePromoCodesGet(serviceTypeId: number | undefined, accept_Language: any | undefined): Observable<AvailablePromoCodesResponseDto[]> {
        let url_ = this.baseUrl + "/api/1/PromoCodes/AvailablePromoCodes?";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "serviceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailablePromoCodesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailablePromoCodesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailablePromoCodesResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailablePromoCodesResponseDto[]>;
        }));
    }

    protected processAvailablePromoCodesGet(response: HttpResponseBase): Observable<AvailablePromoCodesResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailablePromoCodesResponseDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @param serviceTypeId (optional) 
     * @param supportedLocationId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    consume(code: string | undefined, serviceTypeId: OrderType | undefined, supportedLocationId: number | undefined, accept_Language: any | undefined): Observable<PromoCodeConsumeResultDto> {
        let url_ = this.baseUrl + "/api/1/PromoCodes/consume?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        if (supportedLocationId === null)
            throw new Error("The parameter 'supportedLocationId' cannot be null.");
        else if (supportedLocationId !== undefined)
            url_ += "SupportedLocationId=" + encodeURIComponent("" + supportedLocationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsume(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsume(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeConsumeResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeConsumeResultDto>;
        }));
    }

    protected processConsume(response: HttpResponseBase): Observable<PromoCodeConsumeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeConsumeResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    generalconsume(code: string | undefined, accept_Language: any | undefined): Observable<PromoCodeGeneralConsumeResultDto> {
        let url_ = this.baseUrl + "/api/1/PromoCodes/generalconsume?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralconsume(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralconsume(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeGeneralConsumeResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeGeneralConsumeResultDto>;
        }));
    }

    protected processGeneralconsume(response: HttpResponseBase): Observable<PromoCodeGeneralConsumeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeGeneralConsumeResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param serviceTypeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    availablePromoCodesGet(serviceTypeId: number | undefined, accept_Language: any | undefined): Observable<AvailablePromoCodesResponseDto[]> {
        let url_ = this.baseUrl + "/api/1.1/PromoCodes/AvailablePromoCodes?";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "serviceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailablePromoCodesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailablePromoCodesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailablePromoCodesResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailablePromoCodesResponseDto[]>;
        }));
    }

    protected processAvailablePromoCodesGet(response: HttpResponseBase): Observable<AvailablePromoCodesResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailablePromoCodesResponseDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PromoDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number, accept_Language: any | undefined): Observable<PromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeDto>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<PromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    code(code: string, accept_Language: any | undefined): Observable<PromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/code/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeDto>;
        }));
    }

    protected processCode(response: HttpResponseBase): Observable<PromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param freeSearch (optional) 
     * @param aliasName (optional) 
     * @param code (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param isPercentageDiscount (optional) 
     * @param discountValue (optional) 
     * @param maxUsageLimit (optional) 
     * @param maxUserUsageLimit (optional) 
     * @param isActive (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(freeSearch: string | undefined, aliasName: string | undefined, code: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, isPercentageDiscount: boolean | undefined, discountValue: number | undefined, maxUsageLimit: number | undefined, maxUserUsageLimit: number | undefined, isActive: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PromoCodeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/All?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (aliasName === null)
            throw new Error("The parameter 'aliasName' cannot be null.");
        else if (aliasName !== undefined)
            url_ += "AliasName=" + encodeURIComponent("" + aliasName) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (isPercentageDiscount === null)
            throw new Error("The parameter 'isPercentageDiscount' cannot be null.");
        else if (isPercentageDiscount !== undefined)
            url_ += "IsPercentageDiscount=" + encodeURIComponent("" + isPercentageDiscount) + "&";
        if (discountValue === null)
            throw new Error("The parameter 'discountValue' cannot be null.");
        else if (discountValue !== undefined)
            url_ += "DiscountValue=" + encodeURIComponent("" + discountValue) + "&";
        if (maxUsageLimit === null)
            throw new Error("The parameter 'maxUsageLimit' cannot be null.");
        else if (maxUsageLimit !== undefined)
            url_ += "MaxUsageLimit=" + encodeURIComponent("" + maxUsageLimit) + "&";
        if (maxUserUsageLimit === null)
            throw new Error("The parameter 'maxUserUsageLimit' cannot be null.");
        else if (maxUserUsageLimit !== undefined)
            url_ += "MaxUserUsageLimit=" + encodeURIComponent("" + maxUserUsageLimit) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<PromoCodeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodePost(accept_Language: any | undefined, body: PromoCodeCreateDto | undefined): Observable<PromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeDto>;
        }));
    }

    protected processPromocodePost(response: HttpResponseBase): Observable<PromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodePut(accept_Language: any | undefined, body: PromoCodeUpdateDto | undefined): Observable<PromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeDto>;
        }));
    }

    protected processPromocodePut(response: HttpResponseBase): Observable<PromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promocodeDelete(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocode?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPromocodeDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    enbale(accept_Language: any | undefined, body: PromoCodeEnableDto | undefined): Observable<PromoCodeDto> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/enbale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnbale(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnbale(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeDto>;
        }));
    }

    protected processEnbale(response: HttpResponseBase): Observable<PromoCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param promoCodeId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promocodeusersGet(promoCodeId: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<UserDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocodeusers?";
        if (promoCodeId === null)
            throw new Error("The parameter 'promoCodeId' cannot be null.");
        else if (promoCodeId !== undefined)
            url_ += "PromoCodeId=" + encodeURIComponent("" + promoCodeId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeusersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeusersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPaginatedList>;
        }));
    }

    protected processPromocodeusersGet(response: HttpResponseBase): Observable<UserDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodeusersDelete(accept_Language: any | undefined, body: PromoCodeUserDeleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocodeusers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeusersDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeusersDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPromocodeusersDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param promoCodeId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promocodeservicesGet(promoCodeId: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ServiceTypeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocodeservices?";
        if (promoCodeId === null)
            throw new Error("The parameter 'promoCodeId' cannot be null.");
        else if (promoCodeId !== undefined)
            url_ += "PromoCodeId=" + encodeURIComponent("" + promoCodeId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeservicesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeservicesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceTypeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceTypeDtoPaginatedList>;
        }));
    }

    protected processPromocodeservicesGet(response: HttpResponseBase): Observable<ServiceTypeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceTypeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    promocodeservicesDelete(accept_Language: any | undefined, body: PromoCodeServiceDeleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/promocodeservices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromocodeservicesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromocodeservicesDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPromocodeservicesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param promoCode (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    promoCodeConsuming(fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, promoCode: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PromoCodeConsumingResultDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PromoDashBoard/PromoCodeConsuming?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "PromoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPromoCodeConsuming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPromoCodeConsuming(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PromoCodeConsumingResultDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PromoCodeConsumingResultDtoPaginatedList>;
        }));
    }

    protected processPromoCodeConsuming(response: HttpResponseBase): Observable<PromoCodeConsumingResultDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PromoCodeConsumingResultDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ServiceFareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param countryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    defaultFare(countryId: number | undefined, accept_Language: any | undefined): Observable<DefaultFareDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFare/DefaultFare?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDefaultFare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDefaultFare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DefaultFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DefaultFareDto>;
        }));
    }

    protected processDefaultFare(response: HttpResponseBase): Observable<DefaultFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DefaultFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fname (optional) 
     * @param lastname (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    test(fname: string | undefined, lastname: string | undefined, accept_Language: any | undefined): Observable<GreetingResponse> {
        let url_ = this.baseUrl + "/api/1/ServiceFare/test?";
        if (fname === null)
            throw new Error("The parameter 'fname' cannot be null.");
        else if (fname !== undefined)
            url_ += "fname=" + encodeURIComponent("" + fname) + "&";
        if (lastname === null)
            throw new Error("The parameter 'lastname' cannot be null.");
        else if (lastname !== undefined)
            url_ += "lastname=" + encodeURIComponent("" + lastname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GreetingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GreetingResponse>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<GreetingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GreetingResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fname (optional) 
     * @param lastname (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    test2(fname: string | undefined, lastname: string | undefined, accept_Language: any | undefined): Observable<DriverDto[]> {
        let url_ = this.baseUrl + "/api/1/ServiceFare/test2?";
        if (fname === null)
            throw new Error("The parameter 'fname' cannot be null.");
        else if (fname !== undefined)
            url_ += "fname=" + encodeURIComponent("" + fname) + "&";
        if (lastname === null)
            throw new Error("The parameter 'lastname' cannot be null.");
        else if (lastname !== undefined)
            url_ += "lastname=" + encodeURIComponent("" + lastname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverDto[]>;
        }));
    }

    protected processTest2(response: HttpResponseBase): Observable<DriverDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param areaOfWorkId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    areaOfWorkServices(areaOfWorkId: number | undefined, accept_Language: any | undefined): Observable<ServiceFareDto[]> {
        let url_ = this.baseUrl + "/api/1/ServiceFare/AreaOfWorkServices?";
        if (areaOfWorkId === null)
            throw new Error("The parameter 'areaOfWorkId' cannot be null.");
        else if (areaOfWorkId !== undefined)
            url_ += "AreaOfWorkId=" + encodeURIComponent("" + areaOfWorkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAreaOfWorkServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAreaOfWorkServices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDto[]>;
        }));
    }

    protected processAreaOfWorkServices(response: HttpResponseBase): Observable<ServiceFareDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param serviceTypeId (optional) 
     * @param areaId (optional) 
     * @param countryId (optional) 
     * @param promoCode (optional) 
     * @param supportedLocationId (optional) 
     * @param distance (optional) 
     * @param minimumPrice (optional) 
     * @param fixedPrice (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    serviceFees(serviceTypeId: OrderType | undefined, areaId: number | undefined, countryId: number | undefined, promoCode: string | undefined, supportedLocationId: number | undefined, distance: number | undefined, minimumPrice: number | undefined, fixedPrice: number | undefined, pickupLocation_Latitude: number, pickupLocation_Longitude: number, dropLocation_Latitude: number, dropLocation_Longitude: number, accept_Language: any | undefined): Observable<ServiceFeesDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFare/ServiceFees?";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (promoCode === null)
            throw new Error("The parameter 'promoCode' cannot be null.");
        else if (promoCode !== undefined)
            url_ += "PromoCode=" + encodeURIComponent("" + promoCode) + "&";
        if (supportedLocationId === null)
            throw new Error("The parameter 'supportedLocationId' cannot be null.");
        else if (supportedLocationId !== undefined)
            url_ += "SupportedLocationId=" + encodeURIComponent("" + supportedLocationId) + "&";
        if (distance === null)
            throw new Error("The parameter 'distance' cannot be null.");
        else if (distance !== undefined)
            url_ += "Distance=" + encodeURIComponent("" + distance) + "&";
        if (minimumPrice === null)
            throw new Error("The parameter 'minimumPrice' cannot be null.");
        else if (minimumPrice !== undefined)
            url_ += "MinimumPrice=" + encodeURIComponent("" + minimumPrice) + "&";
        if (fixedPrice === null)
            throw new Error("The parameter 'fixedPrice' cannot be null.");
        else if (fixedPrice !== undefined)
            url_ += "FixedPrice=" + encodeURIComponent("" + fixedPrice) + "&";
        if (pickupLocation_Latitude === undefined || pickupLocation_Latitude === null)
            throw new Error("The parameter 'pickupLocation_Latitude' must be defined and cannot be null.");
        else
            url_ += "PickupLocation.Latitude=" + encodeURIComponent("" + pickupLocation_Latitude) + "&";
        if (pickupLocation_Longitude === undefined || pickupLocation_Longitude === null)
            throw new Error("The parameter 'pickupLocation_Longitude' must be defined and cannot be null.");
        else
            url_ += "PickupLocation.Longitude=" + encodeURIComponent("" + pickupLocation_Longitude) + "&";
        if (dropLocation_Latitude === undefined || dropLocation_Latitude === null)
            throw new Error("The parameter 'dropLocation_Latitude' must be defined and cannot be null.");
        else
            url_ += "DropLocation.Latitude=" + encodeURIComponent("" + dropLocation_Latitude) + "&";
        if (dropLocation_Longitude === undefined || dropLocation_Longitude === null)
            throw new Error("The parameter 'dropLocation_Longitude' must be defined and cannot be null.");
        else
            url_ += "DropLocation.Longitude=" + encodeURIComponent("" + dropLocation_Longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceFees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceFees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFeesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFeesDto>;
        }));
    }

    protected processServiceFees(response: HttpResponseBase): Observable<ServiceFeesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFeesDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    extraStoreFee(accept_Language: any | undefined): Observable<ServiceExtraStoreFeeDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFare/ExtraStoreFee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtraStoreFee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtraStoreFee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceExtraStoreFeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceExtraStoreFeeDto>;
        }));
    }

    protected processExtraStoreFee(response: HttpResponseBase): Observable<ServiceExtraStoreFeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceExtraStoreFeeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class 1ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param areaOfWorkId (optional) 
     * @param serviceType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    serviceFareDashboard(areaOfWorkId: number | undefined, serviceType: OrderType[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ServiceFareDto[]> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard?";
        if (areaOfWorkId === null)
            throw new Error("The parameter 'areaOfWorkId' cannot be null.");
        else if (areaOfWorkId !== undefined)
            url_ += "AreaOfWorkId=" + encodeURIComponent("" + areaOfWorkId) + "&";
        if (serviceType === null)
            throw new Error("The parameter 'serviceType' cannot be null.");
        else if (serviceType !== undefined)
            serviceType && serviceType.forEach(item => { url_ += "ServiceType=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceFareDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceFareDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDto[]>;
        }));
    }

    protected processServiceFareDashboard(response: HttpResponseBase): Observable<ServiceFareDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    storePormotionDashboard(id: number, accept_Language: any | undefined): Observable<StorePormotionDto> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStorePormotionDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStorePormotionDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StorePormotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StorePormotionDto>;
        }));
    }

    protected processStorePormotionDashboard(response: HttpResponseBase): Observable<StorePormotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorePormotionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ServiceFareDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param areaOfWorkId (optional) 
     * @param serviceType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(areaOfWorkId: number | undefined, serviceType: OrderType[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ServiceFareDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/page?";
        if (areaOfWorkId === null)
            throw new Error("The parameter 'areaOfWorkId' cannot be null.");
        else if (areaOfWorkId !== undefined)
            url_ += "AreaOfWorkId=" + encodeURIComponent("" + areaOfWorkId) + "&";
        if (serviceType === null)
            throw new Error("The parameter 'serviceType' cannot be null.");
        else if (serviceType !== undefined)
            serviceType && serviceType.forEach(item => { url_ += "ServiceType=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<ServiceFareDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    get(id: number, accept_Language: any | undefined): Observable<ServiceFareDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ServiceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: ServiceFareCreateDto | undefined): Observable<ServiceFareDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    createDefaultSerivesFare(accept_Language: any | undefined, body: ServiceFareCreateAreaOfWorkDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/createDefaultSerivesFare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDefaultSerivesFare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDefaultSerivesFare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateDefaultSerivesFare(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setActivation(accept_Language: any | undefined, body: ServiceFareActivateDto | undefined): Observable<ServiceFareDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/setActivation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetActivation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetActivation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDto>;
        }));
    }

    protected processSetActivation(response: HttpResponseBase): Observable<ServiceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: ServiceFareUpdateDto | undefined): Observable<ServiceFareDto> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceFareDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ServiceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(accept_Language: any | undefined, body: ServiceFareDeleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ServiceFareDashboard/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StorePormotionDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(keyword: string | undefined, isActive: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<StorePormotionDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/All?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StorePormotionDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StorePormotionDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<StorePormotionDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorePormotionDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateStorePormotionDto | undefined): Observable<StorePormotionDto> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StorePormotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StorePormotionDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<StorePormotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorePormotionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateStorePormotionDto | undefined): Observable<StorePormotionDto> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StorePormotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StorePormotionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StorePormotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorePormotionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    active(accept_Language: any | undefined, body: StorePormotionIsActiveToggleDto | undefined): Observable<StorePormotionDto> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/Active";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StorePormotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StorePormotionDto>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<StorePormotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorePormotionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    id(accept_Language: any | undefined, body: StorePormotionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    test(keyword: string | undefined, accept_Language: any | undefined): Observable<StorePormotion> {
        let url_ = this.baseUrl + "/api/1/StorePormotionDashboard/Test?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StorePormotion>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StorePormotion>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<StorePormotion> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorePormotion;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WelcomeUserPolicyDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: NewUserWelcomePolicyInputDto | undefined): Observable<NewUserWelcomePolicyDto> {
        let url_ = this.baseUrl + "/api/1/WelcomeUserPolicyDashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewUserWelcomePolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewUserWelcomePolicyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<NewUserWelcomePolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NewUserWelcomePolicyDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: NewUserWelcomePolicyActivateDto | undefined): Observable<NewUserWelcomePolicyDto> {
        let url_ = this.baseUrl + "/api/1/WelcomeUserPolicyDashboard/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewUserWelcomePolicyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewUserWelcomePolicyDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<NewUserWelcomePolicyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NewUserWelcomePolicyDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param policyName (optional) 
     * @param code (optional) 
     * @param count (optional) 
     * @param isActive (optional) 
     * @param validPeriod (optional) 
     * @param amount (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(policyName: string | undefined, code: string | undefined, count: number | undefined, isActive: boolean | undefined, validPeriod: number | undefined, amount: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<NewUserWelcomePolicyDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/WelcomeUserPolicyDashboard/Page?";
        if (policyName === null)
            throw new Error("The parameter 'policyName' cannot be null.");
        else if (policyName !== undefined)
            url_ += "PolicyName=" + encodeURIComponent("" + policyName) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (validPeriod === null)
            throw new Error("The parameter 'validPeriod' cannot be null.");
        else if (validPeriod !== undefined)
            url_ += "ValidPeriod=" + encodeURIComponent("" + validPeriod) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewUserWelcomePolicyDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewUserWelcomePolicyDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<NewUserWelcomePolicyDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NewUserWelcomePolicyDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface AllDriverCurrentStatusDto {
    driversCurrentStatusList: DriverCurrentStatusDto[] | undefined;
    readonly totalCount: number;
    readonly onlineCount: number;
    readonly offlineCount: number;
    readonly busyCount: number;
    readonly freeCount: number;
    readonly availableCount: number;
    readonly requestedCount: number;
    readonly assignedCount: number;
}

export interface AttachmentCreateDto {
    attachmentName: string | undefined;
    attachmentContent: string | undefined;
}

export interface AvailablePromoCodesResponseDto {
    promoCodeId: number;
    aliasName: string | undefined;
    code: string | undefined;
    isPercentageDiscount: boolean;
    discountValue: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    userUsageCount: number;
    userRemainingUsageCount: number;
    remainingUsageCount: number;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    readonly uid: string | undefined;
}

export interface CalculateSendNotificationaffectedUserCountDto {
    count: string | undefined;
}

export interface CancellationReasonByDayDto {
    date: string | undefined;
    cancellationReasonId: number;
    cancellationReasonName: string | undefined;
    count: number;
}

export interface CancellationReasonDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    orderType: OrderType[] | undefined;
    orderStatus: OrderStatus[] | undefined;
    userType: UserType;
    userTypeSt: string | undefined;
    ordering: number;
    isFinalClosure: boolean;
    isActive: boolean;
}

export interface CancellationReasonDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CancellationReasonDto[] | undefined;
}

export interface CancellationReasonEnableDto {
    id: number;
    isActive: boolean;
}

export interface CancellationReasonIsFinalClosureToggleDto {
    id: number;
    isFinalClosure: boolean;
}

export interface CancellationReasonLightDto {
    id: number;
    name: string | undefined;
    isFinalClosure: boolean;
}

export interface CashbackExternalVoucherCreateDto {
    partnerId: string;
    userId: string;
    policyId: string | undefined;
    amount: number | undefined;
}

export interface CashbackVoucherDto {
    id: string;
    partnerCashbackPolicyId: string;
    partnerId: string | undefined;
    storeIds: string[] | undefined;
    value: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    minimumOrderToConsume: number;
    referenceOrderId: string;
    buyerId: string;
    voucherNumber: string | undefined;
    voucherType: VoucherType;
    partnerName: string | undefined;
    name: string | undefined;
}

export interface CashbackVoucherDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CashbackVoucherDto[] | undefined;
}

export interface ChangingDriverReasonDto {
    id: number;
    nameEn: string | undefined;
    nameAr: string | undefined;
    name: string | undefined;
    ordering: number;
    isActive: boolean;
}

export interface ChangingDriverReasonDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ChangingDriverReasonDto[] | undefined;
}

export interface ChangingDriverReasonLightDto {
    id: number;
    name: string | undefined;
}

export enum ChatContentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export interface ChatMessageReader {
    id: string;
    name: string | undefined;
    profilePictureUrl: string | undefined;
}

export interface ChatModel {
    id: string | undefined;
    orderId: string;
    connectionId: string | undefined;
    message: string | undefined;
    type: ChatContentType;
    imageBase64: string | undefined;
    imageUrl: string | undefined;
    voiceNoteUrl: string | undefined;
    voiceNoteBase64: string | undefined;
    voiceLength: number;
    location: LocationSocketObject;
    isDriver: boolean;
    messageDate: moment.Moment;
    senderId: string;
    senderName: string | undefined;
    receiverIds: string[] | undefined;
    senderType: UserType;
    senderImageUrl: string | undefined;
    readonly readers: ChatMessageReader[] | undefined;
}

export interface ClosingReasonCreateDto {
    nameAr: string | undefined;
    nameEn: string | undefined;
    isActive: boolean;
    isCritical: boolean;
}

export interface ClosingReasonDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isActive: boolean;
    isCritical: boolean;
}

export interface ClosingReasonDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ClosingReasonDto[] | undefined;
}

export interface CreateCancellationReasonDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    orderType: OrderType[] | undefined;
    orderStatus: OrderStatus[] | undefined;
    userType: UserType;
    ordering: number;
    isActive: boolean | undefined;
    isFinalClosure: boolean | undefined;
}

export interface CreateChangingDriverReasonDto {
    id: number;
    name: LocalizedFieldDto;
    ordering: number;
    isActive: boolean;
}

export interface CreateIntegrationOrderFromStoreRequestDto {
    id: string;
    pickupLocation: LocationDto;
    pickupLocationDetails: string;
    pickupGeoLocation: string;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
    imageBase64String: string | undefined;
    imageUrl: string | undefined;
    note: string | undefined;
    promoCode: string | undefined;
    orderStatus: OrderStatus;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    buyerId: string;
    price: number;
    deliveryFee: number;
    distance: number;
    extraFee: number;
    extraStoreFee: number;
    storeDiscount: number;
    areaId: number;
    areaOfWorkId: number;
    isUserExist: boolean;
    storeId: string;
}

export interface CreateIntegrationOrderResponseDto {
    id: string;
    orderNumber: string | undefined;
    integrationOrderId: string;
    orderStatus: OrderStatus;
    orderStatusUpdateDate: moment.Moment;
}

export interface CreateOrderDto {
    id: string;
    items: OrderItemDto[];
    pickupLocation: LocationDto;
    pickupLocationDetails: string;
    pickupGeoLocation: string;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string;
    dropOffGeoLocation: string;
    imageBase64String: string | undefined;
    imageUrl: string | undefined;
    note: string | undefined;
    promoCode: string | undefined;
    partnerPromoCode: string | undefined;
    cashbackVoucherId: string | undefined;
    orderStatus: OrderStatus;
    orderType: OrderType;
    paymentType: PaymentType;
    deliveryFee: number;
    distance: number;
    extraFee: number;
    extraStoreFee: number;
    areaId: number;
    areaOfWorkId: number;
    isFemale: boolean;
    femaleFee: number;
    partnerId: string | undefined;
    storeId: string | undefined;
    storeDiscount: number;
    price: number;
    estimatingOrderPrice: EstimatingOrderPrice;
    isIntegration: boolean;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
}

export interface CreateOrderFromIntegrationDto {
    id: string;
    pickupLocation: LocationDto;
    pickupGeoLocation: string | undefined;
    dropOffLocation: LocationDto;
    dropOffGeoLocation: string | undefined;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    buyerId: string;
    integrationUserId: string;
    price: number;
    deliveryFee: number;
    deliveryFeeAfterDiscount: number;
    distance: number;
    areaId: number;
    areaOfWorkId: number;
    storeName: string | undefined;
    buyerPhoneNumber: string | undefined;
    accessToken: string | undefined;
    isPaid: boolean;
    isDelivered: boolean;
    consignmentNo: string | undefined;
    noOfPieces: number;
    weightKg: number;
    orderDescription: string | undefined;
    storeDiscount: number;
    orderType: OrderType;
    orderNumber: string | undefined;
    pickup_Details: string | undefined;
    dropOff_Details: string | undefined;
    storeId: string | undefined;
    isInvoiceIssued: boolean;
    extraStoreFee: number;
    items: OrderItemsFromIntegrationDto[] | undefined;
    orderExtraInfo: string | undefined;
}

export interface CreateOrderFromStoreDto {
    id: string;
    pickupLocation: LocationDto;
    pickupLocationDetails: string;
    pickupGeoLocation: string;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
    imageBase64String: string | undefined;
    imageUrl: string | undefined;
    note: string | undefined;
    promoCode: string | undefined;
    orderStatus: OrderStatus;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    buyerId: string;
    price: number;
    deliveryFee: number;
    distance: number;
    extraFee: number;
    extraStoreFee: number;
    storeDiscount: number;
    areaId: number;
    areaOfWorkId: number;
    isUserExist: boolean;
    partnerId: string | undefined;
}

export interface CreateOrderResponseDto {
    id: string;
    orderNumber: string | undefined;
}

export interface CreatePartnerOrderDto {
    items: PartnerOrderItemDto[];
    pickupLocation: LocationDto;
    pickupLocationDetails: string;
    pickupGeoLocation: string;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string;
    dropOffGeoLocation: string;
    note: string | undefined;
    paymentType: PaymentType;
    deliveryFeeAfterDiscount: number;
    distance: number;
    extraFee: number;
    extraStoreFee: number;
    areaId: number;
    areaOfWorkId: number;
    partnerId: string | undefined;
    storeId: string | undefined;
    storeDiscount: number;
    price: number;
    buyerId: string;
    isUserExist: boolean;
    orderType: OrderType;
    orderNumber: string | undefined;
}

export interface CreateStorePormotionDto {
    storeName: string;
    discount: number;
    notification: string;
    isActive: boolean;
}

export interface DashBoardCashbackPolicyCreateDto {
    partnerId: string | undefined;
    policyName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    validAfterPreviousOrder: number | undefined;
    validPeriod: number;
    isPercentage: boolean;
    value: number;
    capLimit: number | undefined;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPriceToCreate: number | undefined;
    minimumOrderToConsume: number | undefined;
    isActive: boolean;
    policyType: VoucherType;
    promoCodeCount: number;
}

export interface DashBoardCashbackPolicyUpdateDto {
    id: string;
    partnerId: string | undefined;
    policyName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    validAfterPreviousOrder: number | undefined;
    validPeriod: number;
    isPercentage: boolean;
    value: number;
    capLimit: number | undefined;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPriceToCreate: number | undefined;
    minimumOrderToConsume: number | undefined;
    isActive: boolean;
    policyType: VoucherType;
    promoCodeCount: number;
}

export interface DefaultFareDto {
    minimumDestination: number;
    minimumDestinationFare: number;
    extraDistanceAmount: number;
    extraDistanceAmountFare: number;
}

export enum DeliveryPaymentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export interface DriverCurrentStatusDto {
    id: string;
    readonly fullName: string | undefined;
    name: string | undefined;
    lastName: string | undefined;
    profileImageUrl: string | undefined;
    rating: number;
    lastTimeUpdated: moment.Moment | undefined;
    isOnline: boolean;
    isBusy: boolean;
    lastDriverStatus: DriverStatus;
    lastDriverStatusName: string | undefined;
    latitude: number;
    longitude: number;
    language: string | undefined;
    phoneNumber: string | undefined;
    currentOrderId: string | undefined;
    orderNumber: string | undefined;
    isDedicatedCourier: boolean;
}

export interface DriverDatailsDto {
    id: string;
    readonly fullName: string | undefined;
    name: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    profilePictureUrl: string | undefined;
    rating: number;
    isBusy: boolean;
    status: string | undefined;
}

export interface DriverDto {
    id: string;
    name: string | undefined;
    phoneNumber: string | undefined;
    profilePictureUrl: string | undefined;
    rating: number;
    isBusy: boolean;
    status: DriverStatus;
}

export enum DriverStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface DriverStatusDto {
    isOnline: boolean;
    latitude: number;
    longitude: number;
    driverId: string | undefined;
}

export enum EstimatingOrderPrice {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export interface GetOrderStatus {
    orderId: string;
    orderStatus: OrderStatus;
}

export interface GreetingResponse {
    result: string | undefined;
}

export interface Int64ReOrderingDto {
    id: number;
    ordering: number;
}

export interface LastCompeletedOrder {
    orderId: string;
    driverId: string;
    driverName: string | undefined;
    driverProfilePictureUrl: string | undefined;
    orderType: OrderType;
    partnerId: string | undefined;
    storeId: string | undefined;
    storeName: string | undefined;
    storeProfilePictureUrl: string | undefined;
    orderNumber: string | undefined;
}

export interface LocalizedFieldDto {
    ar: string | undefined;
    en: string | undefined;
}

export interface Location {
    latitude: number;
    longitude: number;
}

export interface LocationDto {
    latitude: number;
    longitude: number;
}

export interface LocationSocketObject {
    latitude: number;
    longitude: number;
}

export interface MyOrderDto {
    id: string;
    orderStatus: string | undefined;
    pickup_Details: string | undefined;
    dropOff_Details: string | undefined;
    name: string | undefined;
    finalTotal: number;
    orderNumber: string | undefined;
    createdAt: moment.Moment;
}

export interface NewUserWelcomePolicyActivateDto {
    id: string;
    isActivated: boolean;
}

export interface NewUserWelcomePolicyDto {
    id: string;
    policyName: string | undefined;
    code: string | undefined;
    count: number;
    isActive: boolean;
    validPeriod: number | undefined;
    amount: number;
    newUserWelcomePolicySegmentDto: NewUserWelcomePolicySegmentDto[] | undefined;
}

export interface NewUserWelcomePolicyDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: NewUserWelcomePolicyDto[] | undefined;
}

export interface NewUserWelcomePolicyInputDto {
    policyName: string;
    code: string;
    count: number;
    isActive: boolean;
    validPeriod: number | undefined;
    amount: number;
    newUserWelcomePolicySegmentDto: NewUserWelcomePolicySegmentDto[] | undefined;
}

export interface NewUserWelcomePolicySegmentDto {
    percentage: number;
    minimumOrderPriceToConsume: number;
    capLimit: number;
    paymentTypes: PaymentType[] | undefined;
}

export interface OrderCanceledReasonFullDto {
    userName: string | undefined;
    canceledReasonAr: string | undefined;
    canceledReasonEn: string | undefined;
    isFinalClosure: boolean;
    userType: string | undefined;
}

export interface OrderCancellationReasonDto {
    name: string | undefined;
}

export interface OrderCurrentStatusDto {
    orderDriverId: string;
    readonly fullName: string | undefined;
    name: string | undefined;
    lastName: string | undefined;
    profileImageUrl: string | undefined;
    rating: number;
    lastTimeUpdated: moment.Moment | undefined;
    orderStatusName: string | undefined;
    orderStatus: OrderStatus;
    lastDriverStatusName: string | undefined;
    latitude: number;
    longitude: number;
    language: string | undefined;
    phoneNumber: string | undefined;
    orderId: string | undefined;
    orderNumber: string | undefined;
    isOnline: boolean;
    isBusy: boolean;
    note: string | undefined;
}

export interface OrderDdlDto {
    id: string;
    orderNumber: string | undefined;
}

export interface OrderDeliveredConfirmation {
    orderId: string;
    isDelivered: boolean | undefined;
}

export interface OrderDetailsDto {
    id: string;
    orderStatus: string | undefined;
    items: OrderItemDto[] | undefined;
    orderHistory: OrderHistoryDto[] | undefined;
    buyer: UserProfileDto;
    store: UserProfileDto;
    buyerId: string | undefined;
    driverId: string | undefined;
    storeId: string | undefined;
    driver: DriverDatailsDto;
    pickup_Latitude: number;
    pickup_Longitude: number;
    pickup_Details: string | undefined;
    pickup_Address: string | undefined;
    dropOff_Latitude: number;
    dropOff_Longitude: number;
    dropOff_Details: string | undefined;
    dropOff_Address: string | undefined;
    price: number;
    deliveryFee: number;
    extraFee: number;
    extraStoreFee: number;
    deliveryFeeAfterDiscount: number;
    finalTotal: number;
    promoCodeAliasName: string | undefined;
    promoCode: string | undefined;
    partnerPromoCodeAliasName: string | undefined;
    partnerPromoCode: string | undefined;
    partnerPromoCodeDetails: PartnerPromoCodeDto;
    cancellationReason: OrderCancellationReasonDto;
    notes: string | undefined;
    userRating: number;
    driverRating: number;
    orderNumber: string | undefined;
    distance: number;
    invoiceImageUrl: string | undefined;
    isInvoiceIssued: boolean;
    updatedAt: moment.Moment | undefined;
    orderType: OrderType;
    isPaid: boolean;
    isDelivered: boolean;
    paymentType: PaymentType;
    readonly paymentTypeName: string | undefined;
    deliveryPaymentType: DeliveryPaymentType;
    readonly deliveryPaymentTypeName: string | undefined;
    storeDiscount: number;
    femaleFee: number;
    isFemale: boolean;
    partnerAcceptOrder: boolean | undefined;
    partnerId: string | undefined;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    isStoreConfirmedPickup: boolean;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    inPreparation: boolean | undefined;
}

export interface OrderDriverCanceledReasonDto {
    driverId: string;
    driverName: string | undefined;
    canceledReasonAr: string | undefined;
    canceledReasonEn: string | undefined;
    isFinalClosure: boolean;
}

export interface OrderDriverLocation {
    id: string | undefined;
    orderId: string;
    driverId: string;
    createdAt: moment.Moment;
    location: Location;
}

export interface OrderDriverResultDto {
    order: OrderDriverStateResultDto;
}

export interface OrderDriverStateResultDto {
    id: string;
    pickupLocation: LocationDto;
    pickupLocationDetails: string | undefined;
    pickupGeoLocation: string | undefined;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
    invoiceImageUrl: string | undefined;
    promoCode: string | undefined;
    storeInfo: UserVM;
    items: OrderItemDto[] | undefined;
    distance: number;
    orderNumber: string | undefined;
    price: number;
    finalTotal: number;
    deliveryFee: number;
    deliveryFeeAfterDiscount: number;
    notes: string | undefined;
    extraFee: number;
    extraStoreFee: number;
    femaleFee: number;
    orderType: OrderType;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    areaId: number;
    areaOfWorkId: number;
    buyerId: string;
    storeId: string | undefined;
    driverId: string | undefined;
    orderStatus: OrderStatus;
    isPaid: boolean;
    isDelivered: boolean;
    isStoreConfirmedPickup: boolean;
    createdAt: moment.Moment;
    promoCodeId: number | undefined;
    promoDiscount: number;
    storeDiscount: number;
    partnerPromoCode: string | undefined;
    partnerPromoCodeId: number | undefined;
    partnerPromoDiscount: number;
    orderExtraInfo: string | undefined;
    estimatingOrderPrice: EstimatingOrderPrice;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    readonly storeReceivables: number;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    cashToStore: number;
    cashFromCustomer: number;
    partnerAcceptOrder: boolean | undefined;
    partnerId: string | undefined;
    readonly totalDiscount: number;
    buyerInfo: UserVM;
}

export interface OrderDto {
    id: string;
    orderStatus: OrderStatus;
    orderType: OrderType;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    items: OrderItemDto[] | undefined;
    buyerId: string;
    storeId: string | undefined;
    partnerId: string | undefined;
    storeDiscount: number;
    driverId: string | undefined;
    driver: DriverDto;
    pickup_Latitude: number;
    pickup_Longitude: number;
    pickup_Details: string | undefined;
    pickup_Address: string | undefined;
    dropOff_Latitude: number;
    dropOff_Longitude: number;
    dropOff_Details: string | undefined;
    dropOff_Address: string | undefined;
    price: number;
    deliveryFee: number;
    deliveryFeeAfterDiscount: number;
    extraFee: number;
    extraStoreFee: number;
    femaleFee: number;
    readonly finalTotal: number;
    promoCode: PromoCodeDto;
    partnerPromoCode: PartnerPromoCodeDto;
    promoCodeId: number | undefined;
    promoDiscount: number;
    cancellationReasonId: number | undefined;
    notes: string | undefined;
    userRating: number;
    driverRating: number;
    orderNumber: string | undefined;
    distance: number;
    customerName: string | undefined;
    courierName: string | undefined;
    invoicePrice: number;
    invoicePicture: string | undefined;
    invoiceImageUrl: string | undefined;
    createdAt: moment.Moment;
    createdBy: string | undefined;
    areaId: number | undefined;
    areaOfWorkId: number | undefined;
    orderExtraInfo: string | undefined;
    partnerPromoCodeId: number | undefined;
    partnerPromoDiscount: number;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    cancelledBy: string;
}

export interface OrderDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: OrderDto[] | undefined;
}

export interface OrderEditDto {
    orderId: string;
    invoicePrice: number;
    attachedFiles: AttachmentCreateDto[] | undefined;
    dropOffLocation: LocationDto;
    deliveryFee: number;
    distance: number;
    notes: string | undefined;
    dropOffDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
}

export interface OrderGetAllInputDto {
    pageIndex: number;
    pageSize: number;
    sorting: string | undefined;
    orderStatus: OrderStatus[] | undefined;
    orderType: OrderType[] | undefined;
    paymentType: PaymentType[] | undefined;
    createdAt: moment.Moment | undefined;
    orderNumber: string | undefined;
    freeSearch: string | undefined;
    userName: string | undefined;
    userPhoneNumber: string | undefined;
    courierName: string | undefined;
    courierPhoneNumber: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
    storeIds: string[] | undefined;
    delayedOrders: OrderStatus;
    delayedOrderMin: number | undefined;
    closingReasonId: number[] | undefined;
}

export interface OrderHistoryDto {
    orderStatus: string | undefined;
    buyerId: string;
    driverId: string | undefined;
    createdBy: string | undefined;
    createdAt: moment.Moment;
    updatedAt: moment.Moment | undefined;
}

export interface OrderHitMap {
    orderId: string;
    latitude: number;
    longitude: number;
}

export interface OrderIdDto {
    orderId: string;
}

export interface OrderItemDto {
    orderId: string;
    name: string;
    quantity: number;
    imageUrl: string | undefined;
    imageBase64: string | undefined;
    note: string | undefined;
    isExtra: boolean;
    extraPrice: number;
    isFromCatalog: boolean;
    itemDetail: string | undefined;
}

export interface OrderItemsFromIntegrationDto {
    name: string | undefined;
    quantity: number;
    imageUrl: string | undefined;
    price: number;
    note: string | undefined;
    itemDetail: string | undefined;
}

export interface OrderPaidConfirmation {
    orderId: string;
    isPaid: boolean | undefined;
}

export interface OrderPaymentMethod {
    orderId: string;
    paymentType: PaymentType;
}

export interface OrderPaymentStatus {
    id: string;
    paymentType: PaymentType;
    isPaid: boolean;
    isDelivered: boolean;
}

export interface OrderPaymentStatusRequestDto {
    id: string;
    paymentType: PaymentType;
}

export interface OrderPreparationDto {
    orderId: string;
    inPreparation: boolean | undefined;
}

export interface OrderStateResultDto {
    id: string;
    pickupLocation: LocationDto;
    pickupLocationDetails: string | undefined;
    pickupGeoLocation: string | undefined;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
    invoiceImageUrl: string | undefined;
    promoCode: string | undefined;
    storeInfo: UserVM;
    items: OrderItemDto[] | undefined;
    distance: number;
    orderNumber: string | undefined;
    price: number;
    finalTotal: number;
    deliveryFee: number;
    deliveryFeeAfterDiscount: number;
    notes: string | undefined;
    extraFee: number;
    extraStoreFee: number;
    femaleFee: number;
    orderType: OrderType;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    areaId: number;
    areaOfWorkId: number;
    buyerId: string;
    storeId: string | undefined;
    driverId: string | undefined;
    orderStatus: OrderStatus;
    isPaid: boolean;
    isDelivered: boolean;
    isStoreConfirmedPickup: boolean;
    createdAt: moment.Moment;
    promoCodeId: number | undefined;
    promoDiscount: number;
    storeDiscount: number;
    partnerPromoCode: string | undefined;
    partnerPromoCodeId: number | undefined;
    partnerPromoDiscount: number;
    orderExtraInfo: string | undefined;
    estimatingOrderPrice: EstimatingOrderPrice;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    readonly storeReceivables: number;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    cashToStore: number;
    cashFromCustomer: number;
    partnerAcceptOrder: boolean | undefined;
    partnerId: string | undefined;
    readonly totalDiscount: number;
    buyerInfo: UserVM;
}

export enum OrderStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export interface OrderStoreResultDto {
    order: OrderStoreStateResultDto;
}

export interface OrderStoreStateResultDto {
    id: string;
    pickupLocation: LocationDto;
    pickupLocationDetails: string | undefined;
    pickupGeoLocation: string | undefined;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
    invoiceImageUrl: string | undefined;
    promoCode: string | undefined;
    storeInfo: UserVM;
    items: OrderItemDto[] | undefined;
    distance: number;
    orderNumber: string | undefined;
    price: number;
    finalTotal: number;
    deliveryFee: number;
    deliveryFeeAfterDiscount: number;
    notes: string | undefined;
    extraFee: number;
    extraStoreFee: number;
    femaleFee: number;
    orderType: OrderType;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    areaId: number;
    areaOfWorkId: number;
    buyerId: string;
    storeId: string | undefined;
    driverId: string | undefined;
    orderStatus: OrderStatus;
    isPaid: boolean;
    isDelivered: boolean;
    isStoreConfirmedPickup: boolean;
    createdAt: moment.Moment;
    promoCodeId: number | undefined;
    promoDiscount: number;
    storeDiscount: number;
    partnerPromoCode: string | undefined;
    partnerPromoCodeId: number | undefined;
    partnerPromoDiscount: number;
    orderExtraInfo: string | undefined;
    estimatingOrderPrice: EstimatingOrderPrice;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    readonly storeReceivables: number;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    cashToStore: number;
    cashFromCustomer: number;
    partnerAcceptOrder: boolean | undefined;
    partnerId: string | undefined;
    readonly totalDiscount: number;
    driverInfo: UserVM;
    buyerInfo: UserVM;
}

export enum OrderType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
}

export interface OrderUserResultDto {
    order: OrderUserStateResultDto;
}

export interface OrderUserStateResultDto {
    id: string;
    pickupLocation: LocationDto;
    pickupLocationDetails: string | undefined;
    pickupGeoLocation: string | undefined;
    dropOffLocation: LocationDto;
    dropOffLocationDetails: string | undefined;
    dropOffGeoLocation: string | undefined;
    invoiceImageUrl: string | undefined;
    promoCode: string | undefined;
    storeInfo: UserVM;
    items: OrderItemDto[] | undefined;
    distance: number;
    orderNumber: string | undefined;
    price: number;
    finalTotal: number;
    deliveryFee: number;
    deliveryFeeAfterDiscount: number;
    notes: string | undefined;
    extraFee: number;
    extraStoreFee: number;
    femaleFee: number;
    orderType: OrderType;
    paymentType: PaymentType;
    deliveryPaymentType: DeliveryPaymentType;
    areaId: number;
    areaOfWorkId: number;
    buyerId: string;
    storeId: string | undefined;
    driverId: string | undefined;
    orderStatus: OrderStatus;
    isPaid: boolean;
    isDelivered: boolean;
    isStoreConfirmedPickup: boolean;
    createdAt: moment.Moment;
    promoCodeId: number | undefined;
    promoDiscount: number;
    storeDiscount: number;
    partnerPromoCode: string | undefined;
    partnerPromoCodeId: number | undefined;
    partnerPromoDiscount: number;
    orderExtraInfo: string | undefined;
    estimatingOrderPrice: EstimatingOrderPrice;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    readonly storeReceivables: number;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    cashToStore: number;
    cashFromCustomer: number;
    partnerAcceptOrder: boolean | undefined;
    partnerId: string | undefined;
    readonly totalDiscount: number;
    driverInfo: UserVM;
}

export interface OrderingNoteCreateDto {
    note: string | undefined;
    orderId: string | undefined;
}

export interface OrderingNoteDto {
    id: string;
    note: string | undefined;
    orderId: string | undefined;
    createdAt: moment.Moment;
    createdBy: string | undefined;
}

export interface OrderingNoteDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: OrderingNoteDto[] | undefined;
}

export interface OrdersChatUnReadMessageCountDto {
    orderId: string;
    unReadedMessageCount: number;
}

export interface OrdersCurrentStatusDto {
    ordersCurrentStatusList: OrderCurrentStatusDto[] | undefined;
    readonly totalCount: number;
    readonly assignedCount: number;
    readonly pickingUpCount: number;
    readonly deliveringCount: number;
}

export interface OrdersPerDayDto {
    id: string;
    orderNumber: string | undefined;
    orderStatusValue: string | undefined;
    orderStatus: OrderStatus;
    deliveryFee: number;
    pickupLocation: LocationDto;
    dropOffLocation: LocationDto;
    pickupLocationDetails: string | undefined;
    dropOffLocationDetails: string | undefined;
}

export interface OrdersPerWeekDayDto {
    orders: number;
    profits: number;
    orderDate: moment.Moment;
}

export interface OrdersPerYearDto {
    orders: number;
    profits: number;
    date: string | undefined;
    dateFrom: moment.Moment;
    dateTo: moment.Moment;
}

export interface OrdersViewDto {
    id: string;
    createdAt: moment.Moment;
    updatedAt: moment.Moment | undefined;
    buyerFullName: string | undefined;
    driverFullName: string | undefined;
    pickup_Address: string | undefined;
    dropOff_Address: string | undefined;
    orderStatus: string | undefined;
    orderType: string | undefined;
    paymentType: string | undefined;
    orderNumber: string | undefined;
    isInvoiceIssued: boolean;
    promoCode: string | undefined;
    partnerPromoCode: string | undefined;
    orderPeriod: string | undefined;
    inPreparation: boolean | undefined;
    orderStatusId: OrderStatus;
    orderTypeId: OrderType;
    paymentTypeId: PaymentType;
}

export interface OrdersViewDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: OrdersViewDto[] | undefined;
}

export interface PartnerCashbackPolicyActivateDto {
    id: string;
    partnerId: string | undefined;
    isActive: boolean;
}

export interface PartnerCashbackPolicyCodeDto {
    code: string | undefined;
}

export interface PartnerCashbackPolicyCreateDto {
    partnerId: string;
    policyName: string;
    startDate: string;
    endDate: string;
    validAfterPreviousOrder: number;
    validPeriod: number;
    isPercentage: boolean;
    value: number;
    capLimit: number;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPriceToCreate: number;
    minimumOrderToConsume: number;
    isActive: boolean;
    promoCodeCount: number;
}

export interface PartnerCashbackPolicyDto {
    id: string;
    partnerId: string | undefined;
    policyName: string | undefined;
    storeIds: string[] | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    validAfterPreviousOrder: number;
    validPeriod: number;
    isPercentage: boolean;
    value: number;
    capLimit: number;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPriceToCreate: number;
    minimumOrderToConsume: number;
    paymentTypes: PaymentType[] | undefined;
    isActive: boolean;
    createdAt: moment.Moment;
    createdBy: string | undefined;
    updatedAt: moment.Moment | undefined;
    updateBy: string | undefined;
    policyType: VoucherType;
    promoCodeCount: number;
}

export interface PartnerCashbackPolicyDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: PartnerCashbackPolicyDto[] | undefined;
}

export interface PartnerCashbackPolicyUpdateDto {
    id: string;
    partnerId: string;
    policyName: string;
    startDate: string;
    endDate: string;
    validAfterPreviousOrder: number;
    validPeriod: number;
    isPercentage: boolean;
    value: number;
    capLimit: number;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPriceToCreate: number;
    minimumOrderToConsume: number;
    isActive: boolean;
    promoCodeCount: number;
}

export interface PartnerOrderItemDto {
    name: string;
    quantity: number;
    imageUrl: string | undefined;
    note: string | undefined;
    itemDetail: string | undefined;
}

export interface PartnerPageExcelDto {
    excelUrl: string | undefined;
}

export interface PartnerPromoCodeActivateDto {
    id: number;
    isActive: boolean;
    partnerId: string | undefined;
    partnerPromoCodeType: PartnerPromoCodeType;
}

export interface PartnerPromoCodeAvailableResultDto {
    id: number;
    code: string | undefined;
    capLimitAmount: number | undefined;
    isCapLimited: boolean;
    discountValue: number;
    isPercentageDiscount: boolean;
    minimumOrderPrice: number;
    aliasName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    paymentTypes: PaymentType[] | undefined;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    userUsageCount: number;
    userRemainingUsageCount: number;
    remainingUsageCount: number;
    expectedDiscount: number;
    expectedPrice: number;
    readonly uid: string | undefined;
}

export enum PartnerPromoCodeBeneficiaryType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface PartnerPromoCodeConsumeResultDto {
    id: number;
    code: string | undefined;
    isActive: boolean;
    capLimitAmount: number | undefined;
    isCapLimited: boolean;
    discountValue: number;
    isPercentageDiscount: boolean;
    minimumOrderPrice: number;
    aliasName: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    paymentTypes: PaymentType[] | undefined;
    expectedDiscount: number;
    expectedPrice: number;
    promoAffectType: PromoAffectType;
    maxUserUsageCount: number | undefined;
    userRemainingUsageCount: number | undefined;
    readonly uid: string | undefined;
}

export interface PartnerPromoCodeConsumingResultDto {
    id: number;
    promoCode: string | undefined;
    aliasName: string | undefined;
    partnerName: string | undefined;
    totalCount: number;
    completedCount: number;
}

export interface PartnerPromoCodeConsumingResultDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: PartnerPromoCodeConsumingResultDto[] | undefined;
}

export interface PartnerPromoCodeCreateDto {
    id: number;
    aliasName: string | undefined;
    code: string | undefined;
    partnerId: string | undefined;
    storeList: string[] | undefined;
    paymentTypes: PaymentType[] | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPrice: number;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    isActive: boolean;
    timeZone: number;
    partnerPromoCodeType: PartnerPromoCodeType;
}

export interface PartnerPromoCodeDeleteDto {
    id: number;
    partnerId: string | undefined;
    partnerPromoCodeType: PartnerPromoCodeType;
}

export interface PartnerPromoCodeDto {
    id: number;
    aliasName: string | undefined;
    code: string | undefined;
    partnerId: string | undefined;
    storeList: string[] | undefined;
    paymentTypes: PaymentType[] | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPrice: number;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    isActive: boolean;
    partnerPromoCodeType: PartnerPromoCodeType;
}

export interface PartnerPromoCodeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: PartnerPromoCodeDto[] | undefined;
}

export enum PartnerPromoCodeType {
    _1 = 1,
    _2 = 2,
}

export interface PartnerPromoCodeUpdateDto {
    id: number;
    aliasName: string | undefined;
    code: string | undefined;
    partnerId: string | undefined;
    storeList: string[] | undefined;
    paymentTypes: PaymentType[] | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    beneficiaryType: PartnerPromoCodeBeneficiaryType;
    minimumOrderPrice: number;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    isActive: boolean;
    timeZone: number;
    partnerPromoCodeType: PartnerPromoCodeType;
}

export interface PartnerReceivedOrderDto {
    id: string;
    orderStatus: OrderStatus;
    items: OrderItemDto[] | undefined;
    storeId: string | undefined;
    price: number;
    orderNumber: string | undefined;
    courierName: string | undefined;
    createdAt: moment.Moment;
    updatedAt: moment.Moment | undefined;
    buyerInfo: UserVM;
    paymentType: PaymentType;
    orderType: OrderType;
}

export enum PaymentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum PromoAffectType {
    _1 = 1,
    _2 = 2,
}

export enum PromoCodeBeneficiaryType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface PromoCodeByDayDto {
    date: moment.Moment;
    totalCount: number;
    completedCount: number;
}

export interface PromoCodeConsumeResultDto {
    promoCodeId: number;
    aliasName: string | undefined;
    code: string | undefined;
    isPercentageDiscount: boolean;
    discountValue: number;
    isActive: boolean;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    userUsageCount: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    userRemainingUsageCount: number;
    readonly uid: string | undefined;
}

export interface PromoCodeConsumingResultDto {
    id: number;
    promoCode: string | undefined;
    aliasName: string | undefined;
    totalCount: number;
    completedCount: number;
}

export interface PromoCodeConsumingResultDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: PromoCodeConsumingResultDto[] | undefined;
}

export interface PromoCodeCreateDto {
    id: number;
    aliasName: string;
    code: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    isActive: boolean;
    beneficiaryType: PromoCodeBeneficiaryType;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    userIds: string[] | undefined;
    forSelectedServices: boolean;
    serviceTypeIds: number[] | undefined;
    supportedLocationId: number | undefined;
    referenceUserId: string | undefined;
    referenceUserAmount: number | undefined;
}

export interface PromoCodeDto {
    id: number;
    aliasName: string;
    code: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    isActive: boolean;
    beneficiaryType: PromoCodeBeneficiaryType;
    beneficiaryTypeName: string | undefined;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    forSelectedServices: boolean;
    supportedLocationId: number | undefined;
    referenceUserId: string | undefined;
    referenceUserAmount: number | undefined;
}

export interface PromoCodeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: PromoCodeDto[] | undefined;
}

export interface PromoCodeEnableDto {
    id: number;
    isActive: boolean;
}

export interface PromoCodeGeneralConsumeResultDto {
    id: number;
    aliasName: string | undefined;
    code: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUserUsageLimit: number;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    forSelectedServices: boolean;
    promoCodeServices: OrderType[] | undefined;
    supportedLocationId: number | undefined;
    readonly uid: string | undefined;
}

export interface PromoCodeResponseVM {
    isPercentageDiscount: boolean;
    discountValue: number;
}

export interface PromoCodeServiceDeleteDto {
    promoCodeId: number;
    serviceTypeId: number;
}

export interface PromoCodeSummaryDto {
    systemPromoCodeCount: number;
    availableSystemPromoCodes: AvailablePromoCodesResponseDto[] | undefined;
    partnerPromoCodeCount: number;
    availablePartnerPromoCodes: PartnerPromoCodeAvailableResultDto[] | undefined;
    totalPromoCodeCount: number;
    hasDonationPartners: boolean;
}

export interface PromoCodeUpdateDto {
    id: number;
    aliasName: string;
    code: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isPercentageDiscount: boolean;
    discountValue: number;
    maxUsageLimit: number;
    maxUserUsageLimit: number;
    isActive: boolean;
    beneficiaryType: PromoCodeBeneficiaryType;
    isCapLimited: boolean;
    capLimitAmount: number | undefined;
    userIds: string[] | undefined;
    forSelectedServices: boolean;
    serviceTypeIds: number[] | undefined;
    supportedLocationId: number | undefined;
    referenceUserId: string | undefined;
    referenceUserAmount: number | undefined;
}

export interface PromoCodeUserDeleteDto {
    promoCodeId: number;
    userId: string;
}

export interface ReceivedOrderQueueEventModel {
    id: string;
    pickupLocationDetails: string | undefined;
    pickupLocation: LocationDto;
    storeId: string | undefined;
    distance: number;
    deliveryFee: number;
    extraFee: number;
    extraStoreFee: number;
    orderType: OrderType;
    paymentType: PaymentType;
    estimatingOrderPrice: EstimatingOrderPrice;
    isFemale: boolean;
    finalTotal: number;
    pickup_Longitude: number;
    pickup_Latitude: number;
    cashFromCustomer: number;
    cashToStore: number;
}

export interface ServiceExtraStoreFeeDto {
    extraStoreFee: number;
}

export interface ServiceFareActivateDto {
    id: number;
    isActive: boolean;
}

export interface ServiceFareCreateAreaOfWorkDto {
    areaOfWorkId: number | undefined;
}

export interface ServiceFareCreateDto {
    serviceTypeId: OrderType;
    minimumDestination: number | undefined;
    minimumDestinationFare: number | undefined;
    extraDistanceAmount: number | undefined;
    extraDistanceAmountFare: number | undefined;
    fixedPrice: number | undefined;
    minimumPrice: number | undefined;
    isActive: boolean;
    areaOfWorkId: number | undefined;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    countryId: number | undefined;
    regionId: number | undefined;
    provinceId: number | undefined;
    cityId: number | undefined;
    districtId: number | undefined;
}

export interface ServiceFareDeleteDto {
    id: number;
}

export interface ServiceFareDto {
    id: number;
    minimumDestination: number | undefined;
    minimumDestinationFare: number | undefined;
    extraDistanceAmount: number | undefined;
    extraDistanceAmountFare: number | undefined;
    serviceTypeId: OrderType;
    readonly serviceTypeName: string | undefined;
    fixedPrice: number | undefined;
    minimumPrice: number | undefined;
    isActive: boolean;
    areaOfWorkId: number | undefined;
}

export interface ServiceFareDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ServiceFareDto[] | undefined;
}

export interface ServiceFareUpdateDto {
    id: number;
    serviceTypeId: OrderType;
    minimumDestination: number | undefined;
    minimumDestinationFare: number | undefined;
    extraDistanceAmount: number | undefined;
    extraDistanceAmountFare: number | undefined;
    fixedPrice: number | undefined;
    minimumPrice: number | undefined;
    isActive: boolean;
    areaOfWorkId: number | undefined;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    regionId: number | undefined;
    provinceId: number | undefined;
    cityId: number | undefined;
    districtId: number | undefined;
    countryId: number | undefined;
}

export interface ServiceFeesDto {
    deliveryFee: number;
    distance: number;
}

export interface ServiceTypeDto {
    id: number;
    serviceTypeName: string | undefined;
}

export interface ServiceTypeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ServiceTypeDto[] | undefined;
}

export interface StatisticsOrderDto {
    allOrders: number;
    submittedOrder: number;
    assigningCourier: number;
    courierAssigned: number;
    pickingUp: number;
    deliveringOrder: number;
    deliveredOrder: number;
    canceledOrder: number;
    closedOrderBySystem: number;
    closedBySupport: number;
}

export interface StatusResult {
    status: string | undefined;
    message: string | undefined;
    response: any | undefined;
}

export interface StorePickupConfirmationDto {
    orderId: string;
    isStoreConfirmedPickup: boolean | undefined;
}

export interface StorePormotion {
    id: number;
    createdAt: moment.Moment;
    createdBy: string | undefined;
    isDeleted: boolean;
    deletedAt: moment.Moment | undefined;
    deletedBy: string | undefined;
    updatedAt: moment.Moment | undefined;
    updateBy: string | undefined;
    storeName: string | undefined;
    discount: number;
    notification: string | undefined;
    isActive: boolean;
}

export interface StorePormotionDto {
    id: number;
    storeName: string | undefined;
    discount: number;
    notification: string | undefined;
    isActive: boolean;
}

export interface StorePormotionDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: StorePormotionDto[] | undefined;
}

export interface StorePormotionIsActiveToggleDto {
    id: number;
    isActive: boolean;
}

export interface TopUserDto {
    id: string;
    userType: string | undefined;
    orderState: string | undefined;
    name: string | undefined;
    count: number;
}

export interface TopUserDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: TopUserDto[] | undefined;
}

export interface UpdateChangingDriverReasonDto {
    id: number;
    name: LocalizedFieldDto;
    ordering: number;
    isActive: boolean;
}

export interface UpdateStorePormotionDto {
    id: number;
    storeName: string;
    discount: number;
    notification: string;
    isActive: boolean;
}

export interface UserAndDriverOrderDto {
    id: string;
    orderStatus: OrderStatus;
    pickup_Details: string | undefined;
    dropOff_Details: string | undefined;
    name: string | undefined;
    price: number;
    deliveryFeeAfterDiscount: number;
    extraStoreFee: number;
    extraFee: number;
    femaleFee: number;
    readonly finalTotal: number;
    orderNumber: string | undefined;
    createdAt: moment.Moment;
    pickupLocationLatitude: number;
    pickupLocationLongitude: number;
    pickupLocation: LocationDto;
    dropOffLocationLatitude: number;
    dropOffLocationLongitude: number;
    dropOffLocation: LocationDto;
    profileImageURL: string | undefined;
    orderType: OrderType;
    paymentType: PaymentType;
    phoneNumber: string | undefined;
    isPaid: boolean;
    isInvoiceIssued: boolean;
    isDelivered: boolean;
    orderExtraInfo: string | undefined;
    storeImageURL: string | undefined;
    storeName: string | undefined;
    partnerPromoCodeId: number | undefined;
    partnerPromoDiscount: number;
    donatedAmount: number;
    donatedPartnerId: string | undefined;
    cashbackVoucherId: string | undefined;
    cashbackVoucherValue: number;
    cashFromCustomer: number;
    cashToStore: number;
    deliveryFee: number;
    estimatingOrderPrice: EstimatingOrderPrice;
    isStoreConfirmedPickup: boolean;
    invoiceImageUrl: string | undefined;
    storeDiscount: number;
    readonly storeReceivables: number;
    inPreparation: boolean | undefined;
    buyerName: string | undefined;
    buyerRate: number;
    driverProfileImageURL: string | undefined;
    driverName: string | undefined;
}

export interface UserDto {
    id: string;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    profilePictureUrl: string | undefined;
    rate: number;
    language: string | undefined;
    userType: UserType;
    userTypeId: UserType;
    isActivated: boolean;
    isSuspended: boolean;
}

export interface UserDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: UserDto[] | undefined;
}

export interface UserOrdersCountDto {
    count: number;
    isAnyOrderNotPaid: boolean;
}

export interface UserProfileDto {
    readonly fullName: string | undefined;
    name: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    profilePictureUrl: string | undefined;
    rating: number;
}

export enum UserType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export interface UserVM {
    id: string;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    profilePictureUrl: string | undefined;
    rate: number;
}

export enum VoucherStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum VoucherType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}