//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class CityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param governorateId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByGovernorate(governorateId: number | undefined, accept_Language: any | undefined): Observable<CitySimpleDto[]> {
        let url_ = this.baseUrl + "/api/1/City/GetByGovernorate?";
        if (governorateId === null)
            throw new Error("The parameter 'governorateId' cannot be null.");
        else if (governorateId !== undefined)
            url_ += "governorateId=" + encodeURIComponent("" + governorateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByGovernorate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByGovernorate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CitySimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CitySimpleDto[]>;
        }));
    }

    protected processGetByGovernorate(response: HttpResponseBase): Observable<CitySimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CitySimpleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CityDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<CityDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/CityDashBoard/All?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<CityDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CityDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param governorateId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByGovernorate(governorateId: number | undefined, accept_Language: any | undefined): Observable<CityLightDto[]> {
        let url_ = this.baseUrl + "/api/1/CityDashBoard/GetByGovernorate?";
        if (governorateId === null)
            throw new Error("The parameter 'governorateId' cannot be null.");
        else if (governorateId !== undefined)
            url_ += "governorateId=" + encodeURIComponent("" + governorateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByGovernorate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByGovernorate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityLightDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityLightDto[]>;
        }));
    }

    protected processGetByGovernorate(response: HttpResponseBase): Observable<CityLightDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CityLightDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cityId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByCity(cityId: number | undefined, accept_Language: any | undefined): Observable<CityLightDto[]> {
        let url_ = this.baseUrl + "/api/1/CityDashBoard/GetByCity?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityLightDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityLightDto[]>;
        }));
    }

    protected processGetByCity(response: HttpResponseBase): Observable<CityLightDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CityLightDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    country(id: number, accept_Language: any | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/1/Country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processCountry(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driverAchievementGuarantee(id: number, accept_Language: any | undefined): Observable<DriverAchievementGuaranteeDto> {
        let url_ = this.baseUrl + "/api/1/DriverAchievementGuarantee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverAchievementGuarantee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverAchievementGuarantee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverAchievementGuaranteeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverAchievementGuaranteeDto>;
        }));
    }

    protected processDriverAchievementGuarantee(response: HttpResponseBase): Observable<DriverAchievementGuaranteeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverAchievementGuaranteeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driverShift(id: number, accept_Language: any | undefined): Observable<DriverShiftDetailsAndDaysDto> {
        let url_ = this.baseUrl + "/api/1/DriverShift/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDetailsAndDaysDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDetailsAndDaysDto>;
        }));
    }

    protected processDriverShift(response: HttpResponseBase): Observable<DriverShiftDetailsAndDaysDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDetailsAndDaysDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driverShiftDashBoard(id: number, accept_Language: any | undefined): Observable<DriverShiftDto> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverShiftDashBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverShiftDashBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDto>;
        }));
    }

    protected processDriverShiftDashBoard(response: HttpResponseBase): Observable<DriverShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    governorateDashBoard(id: number, accept_Language: any | undefined): Observable<GovernorateDto> {
        let url_ = this.baseUrl + "/api/1/GovernorateDashBoard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGovernorateDashBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGovernorateDashBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateDto>;
        }));
    }

    protected processGovernorateDashBoard(response: HttpResponseBase): Observable<GovernorateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GovernorateDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    guaranteeConfiguration(id: number, accept_Language: any | undefined): Observable<GuaranteeConfigurationDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfiguration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuaranteeConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuaranteeConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeConfigurationDto>;
        }));
    }

    protected processGuaranteeConfiguration(response: HttpResponseBase): Observable<GuaranteeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeConfigurationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    guaranteeConfigurationDashBoard(id: number, accept_Language: any | undefined): Observable<GuaranteeConfigurationDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuaranteeConfigurationDashBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuaranteeConfigurationDashBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeConfigurationDto>;
        }));
    }

    protected processGuaranteeConfigurationDashBoard(response: HttpResponseBase): Observable<GuaranteeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeConfigurationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    guaranteeShiftDashboard(id: number, accept_Language: any | undefined): Observable<GuaranteeShiftDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuaranteeShiftDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuaranteeShiftDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeShiftDto>;
        }));
    }

    protected processGuaranteeShiftDashboard(response: HttpResponseBase): Observable<GuaranteeShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    zoneDashBoard(id: number, accept_Language: any | undefined): Observable<ZoneDto> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processZoneDashBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processZoneDashBoard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDto>;
        }));
    }

    protected processZoneDashBoard(response: HttpResponseBase): Observable<ZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, id: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<CountryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Country/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<CountryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CountryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DriverAchievementGuaranteeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param isApprove (optional) 
     * @param name (optional) 
     * @param phoneNumber (optional) 
     * @param driverAchievementStatus (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, id: number | undefined, isApprove: boolean | undefined, name: string | undefined, phoneNumber: string | undefined, driverAchievementStatus: DriverAchievementStatus | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<DriverAchievementGuaranteeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/DriverAchievementGuarantee/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isApprove === null)
            throw new Error("The parameter 'isApprove' cannot be null.");
        else if (isApprove !== undefined)
            url_ += "IsApprove=" + encodeURIComponent("" + isApprove) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (driverAchievementStatus === null)
            throw new Error("The parameter 'driverAchievementStatus' cannot be null.");
        else if (driverAchievementStatus !== undefined)
            url_ += "DriverAchievementStatus=" + encodeURIComponent("" + driverAchievementStatus) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverAchievementGuaranteeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverAchievementGuaranteeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<DriverAchievementGuaranteeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverAchievementGuaranteeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateDriverAchievementGuaranteeDto | undefined): Observable<DriverAchievementGuaranteeDto> {
        let url_ = this.baseUrl + "/api/1/DriverAchievementGuarantee/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverAchievementGuaranteeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverAchievementGuaranteeDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<DriverAchievementGuaranteeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverAchievementGuaranteeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateDriverAchievementGuaranteeDto | undefined): Observable<DriverAchievementGuaranteeDto> {
        let url_ = this.baseUrl + "/api/1/DriverAchievementGuarantee/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverAchievementGuaranteeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverAchievementGuaranteeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverAchievementGuaranteeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverAchievementGuaranteeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    sendAchievementDriver(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverAchievementGuarantee/SendAchievementDriver?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAchievementDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAchievementDriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendAchievementDriver(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    rejectSendAchievementDriver(accept_Language: any | undefined, body: RejectSendAchievementDriverDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverAchievementGuarantee/RejectSendAchievementDriver";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectSendAchievementDriver(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectSendAchievementDriver(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRejectSendAchievementDriver(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DriversServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    statusGet(accept_Language: any | undefined): Observable<DriverStatusDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverStatusDto>;
        }));
    }

    protected processStatusGet(response: HttpResponseBase): Observable<DriverStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    statusPost(accept_Language: any | undefined, body: DriverStatusDto | undefined): Observable<DriverStatusDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverStatusDto>;
        }));
    }

    protected processStatusPost(response: HttpResponseBase): Observable<DriverStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    nearestdrivers(latitude: number | undefined, longitude: number | undefined, accept_Language: any | undefined): Observable<DriverDto[]> {
        let url_ = this.baseUrl + "/api/1/Drivers/nearestdrivers?";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNearestdrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNearestdrivers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverDto[]>;
        }));
    }

    protected processNearestdrivers(response: HttpResponseBase): Observable<DriverDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    asyncDriverLocation(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Drivers/AsyncDriverLocation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsyncDriverLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsyncDriverLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAsyncDriverLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param driverId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    lastDriverLocationByDriverId(driverId: string | undefined, accept_Language: any | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/LastDriverLocationByDriverId?";
        if (driverId === null)
            throw new Error("The parameter 'driverId' cannot be null.");
        else if (driverId !== undefined)
            url_ += "driverId=" + encodeURIComponent("" + driverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLastDriverLocationByDriverId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLastDriverLocationByDriverId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationDto>;
        }));
    }

    protected processLastDriverLocationByDriverId(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LocationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getActiveShifts(accept_Language: any | undefined): Observable<RunningShiftDto[]> {
        let url_ = this.baseUrl + "/api/1/Drivers/GetActiveShifts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveShifts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveShifts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RunningShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RunningShiftDto[]>;
        }));
    }

    protected processGetActiveShifts(response: HttpResponseBase): Observable<RunningShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RunningShiftDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param shiftId (optional) 
     * @param date (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getShiftDetailsForDate(shiftId: number | undefined, date: moment.Moment | undefined, accept_Language: any | undefined): Observable<DriverAchievementGuaranteeDetailsDto> {
        let url_ = this.baseUrl + "/api/1/Drivers/GetShiftDetailsForDate?";
        if (shiftId === null)
            throw new Error("The parameter 'shiftId' cannot be null.");
        else if (shiftId !== undefined)
            url_ += "shiftId=" + encodeURIComponent("" + shiftId) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShiftDetailsForDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShiftDetailsForDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverAchievementGuaranteeDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverAchievementGuaranteeDetailsDto>;
        }));
    }

    protected processGetShiftDetailsForDate(response: HttpResponseBase): Observable<DriverAchievementGuaranteeDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverAchievementGuaranteeDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    testHttp(firstName: string | undefined, lastName: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Drivers/testHttp?";
        if (firstName === null)
            throw new Error("The parameter 'firstName' cannot be null.");
        else if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName === null)
            throw new Error("The parameter 'lastName' cannot be null.");
        else if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestHttp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestHttp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestHttp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CourierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param freeSearch (optional) 
     * @param driverStatus (optional) 
     * @param courierId (optional) 
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    currentstatus(freeSearch: string | undefined, driverStatus: DriverStatus | undefined, courierId: string | undefined, latitude: number | undefined, longitude: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<DriverCurrentStatusDto[]> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/Currentstatus?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (driverStatus === null)
            throw new Error("The parameter 'driverStatus' cannot be null.");
        else if (driverStatus !== undefined)
            url_ += "DriverStatus=" + encodeURIComponent("" + driverStatus) + "&";
        if (courierId === null)
            throw new Error("The parameter 'courierId' cannot be null.");
        else if (courierId !== undefined)
            url_ += "CourierId=" + encodeURIComponent("" + courierId) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrentstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrentstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverCurrentStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverCurrentStatusDto[]>;
        }));
    }

    protected processCurrentstatus(response: HttpResponseBase): Observable<DriverCurrentStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverCurrentStatusDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param freeSearch (optional) 
     * @param driverStatus (optional) 
     * @param courierId (optional) 
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allCurrentstatus(freeSearch: string | undefined, driverStatus: DriverStatus | undefined, courierId: string | undefined, latitude: number | undefined, longitude: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<AllDriverCurrentStatusDto> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/AllCurrentstatus?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (driverStatus === null)
            throw new Error("The parameter 'driverStatus' cannot be null.");
        else if (driverStatus !== undefined)
            url_ += "DriverStatus=" + encodeURIComponent("" + driverStatus) + "&";
        if (courierId === null)
            throw new Error("The parameter 'courierId' cannot be null.");
        else if (courierId !== undefined)
            url_ += "CourierId=" + encodeURIComponent("" + courierId) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "Latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "Longitude=" + encodeURIComponent("" + longitude) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllCurrentstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllCurrentstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AllDriverCurrentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AllDriverCurrentStatusDto>;
        }));
    }

    protected processAllCurrentstatus(response: HttpResponseBase): Observable<AllDriverCurrentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AllDriverCurrentStatusDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    removeDriverNotUpdatedHisLocations(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/courier/RemoveDriverNotUpdatedHisLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDriverNotUpdatedHisLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDriverNotUpdatedHisLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDriverNotUpdatedHisLocations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DriversDashbBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getAllDriverShiftsOrders(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/GetAllDriverShiftsOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDriverShiftsOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDriverShiftsOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllDriverShiftsOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param shiftId (optional) 
     * @param date (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getShiftDetailsForDate(shiftId: number | undefined, date: moment.Moment | undefined, accept_Language: any | undefined): Observable<DriverAchievementGuaranteeDetailsDto> {
        let url_ = this.baseUrl + "/api/1/DriversDashbBoard/GetShiftDetailsForDate?";
        if (shiftId === null)
            throw new Error("The parameter 'shiftId' cannot be null.");
        else if (shiftId !== undefined)
            url_ += "shiftId=" + encodeURIComponent("" + shiftId) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShiftDetailsForDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShiftDetailsForDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverAchievementGuaranteeDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverAchievementGuaranteeDetailsDto>;
        }));
    }

    protected processGetShiftDetailsForDate(response: HttpResponseBase): Observable<DriverAchievementGuaranteeDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverAchievementGuaranteeDetailsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DriverShiftServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    createDriverSelectShiftsDto(accept_Language: any | undefined, body: CreateDriverObjectDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverShift/CreateDriverSelectShiftsDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDriverSelectShiftsDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDriverSelectShiftsDto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateDriverSelectShiftsDto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param driverShift (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allDriverShift(driverShift: DriverShiftStatus | undefined, accept_Language: any | undefined): Observable<DriverShiftDetailsDto[]> {
        let url_ = this.baseUrl + "/api/1/DriverShift/AllDriverShift?";
        if (driverShift === null)
            throw new Error("The parameter 'driverShift' cannot be null.");
        else if (driverShift !== undefined)
            url_ += "DriverShift=" + encodeURIComponent("" + driverShift) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllDriverShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllDriverShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDetailsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDetailsDto[]>;
        }));
    }

    protected processAllDriverShift(response: HttpResponseBase): Observable<DriverShiftDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDetailsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DriverShiftDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param isApprove (optional) 
     * @param name (optional) 
     * @param phoneNumber (optional) 
     * @param driverStatus (optional) 
     * @param timeFrom (optional) 
     * @param timeTo (optional) 
     * @param cityId (optional) 
     * @param governorateId (optional) 
     * @param zoneId (optional) 
     * @param codeDriverShift (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, id: number | undefined, isApprove: boolean | undefined, name: string | undefined, phoneNumber: string | undefined, driverStatus: DriverShiftStatus | undefined, timeFrom: string | undefined, timeTo: string | undefined, cityId: number | undefined, governorateId: number | undefined, zoneId: number | undefined, codeDriverShift: string | undefined, startDate: string | undefined, endDate: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<DriverShiftDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isApprove === null)
            throw new Error("The parameter 'isApprove' cannot be null.");
        else if (isApprove !== undefined)
            url_ += "IsApprove=" + encodeURIComponent("" + isApprove) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (driverStatus === null)
            throw new Error("The parameter 'driverStatus' cannot be null.");
        else if (driverStatus !== undefined)
            url_ += "DriverStatus=" + encodeURIComponent("" + driverStatus) + "&";
        if (timeFrom === null)
            throw new Error("The parameter 'timeFrom' cannot be null.");
        else if (timeFrom !== undefined)
            url_ += "TimeFrom=" + encodeURIComponent("" + timeFrom) + "&";
        if (timeTo === null)
            throw new Error("The parameter 'timeTo' cannot be null.");
        else if (timeTo !== undefined)
            url_ += "TimeTo=" + encodeURIComponent("" + timeTo) + "&";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&";
        if (governorateId === null)
            throw new Error("The parameter 'governorateId' cannot be null.");
        else if (governorateId !== undefined)
            url_ += "GovernorateId=" + encodeURIComponent("" + governorateId) + "&";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "ZoneId=" + encodeURIComponent("" + zoneId) + "&";
        if (codeDriverShift === null)
            throw new Error("The parameter 'codeDriverShift' cannot be null.");
        else if (codeDriverShift !== undefined)
            url_ += "CodeDriverShift=" + encodeURIComponent("" + codeDriverShift) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<DriverShiftDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateDriverShiftDto | undefined): Observable<DriverShiftDto> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<DriverShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    createDriversShifts(accept_Language: any | undefined, body: SupportCreateDriverShiftDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/CreateDriversShifts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDriversShifts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDriversShifts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateDriversShifts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateDriverShiftDto | undefined): Observable<DriverShiftDto> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    rejectDriverShift(accept_Language: any | undefined, body: RejectDriverShiftDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/RejectDriverShift";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectDriverShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectDriverShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRejectDriverShift(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    approveDriverShift(accept_Language: any | undefined, body: ApproveDriverShiftDto | undefined): Observable<DriverShiftDto> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/ApproveDriverShift";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveDriverShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveDriverShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDto>;
        }));
    }

    protected processApproveDriverShift(response: HttpResponseBase): Observable<DriverShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    supportUpdateDriverShift(accept_Language: any | undefined, body: SupportUpdateDriverShiftDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/SupportUpdateDriverShift";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupportUpdateDriverShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupportUpdateDriverShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSupportUpdateDriverShift(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getUserDriverShiftPage(userId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<DriverShiftDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/GetUserDriverShiftPage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDriverShiftPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDriverShiftPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDtoPaginatedList>;
        }));
    }

    protected processGetUserDriverShiftPage(response: HttpResponseBase): Observable<DriverShiftDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param zoneId (optional) 
     * @param fromDateStr (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param days (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getZoneDriverShift(zoneId: number | undefined, fromDateStr: string | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined, days: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ZoneDriverShiftDto[]> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/GetZoneDriverShift?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "ZoneId=" + encodeURIComponent("" + zoneId) + "&";
        if (fromDateStr === null)
            throw new Error("The parameter 'fromDateStr' cannot be null.");
        else if (fromDateStr !== undefined)
            url_ += "FromDateStr=" + encodeURIComponent("" + fromDateStr) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZoneDriverShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZoneDriverShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDriverShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDriverShiftDto[]>;
        }));
    }

    protected processGetZoneDriverShift(response: HttpResponseBase): Observable<ZoneDriverShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDriverShiftDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getShiftDetailsById(id: number, accept_Language: any | undefined): Observable<DriverShiftDetailsAndDaysDto> {
        let url_ = this.baseUrl + "/api/1/DriverShiftDashBoard/GetShiftDetailsById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShiftDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShiftDetailsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverShiftDetailsAndDaysDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverShiftDetailsAndDaysDto>;
        }));
    }

    protected processGetShiftDetailsById(response: HttpResponseBase): Observable<DriverShiftDetailsAndDaysDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DriverShiftDetailsAndDaysDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GovernorateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param countryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByCountry(countryId: number | undefined, accept_Language: any | undefined): Observable<GovernorateSimpleDto[]> {
        let url_ = this.baseUrl + "/api/1/Governorate/GetByCountry?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateSimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateSimpleDto[]>;
        }));
    }

    protected processGetByCountry(response: HttpResponseBase): Observable<GovernorateSimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GovernorateSimpleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GovernorateDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, id: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GovernorateDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/GovernorateDashBoard/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<GovernorateDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GovernorateDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param countryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByCountry(countryId: number | undefined, accept_Language: any | undefined): Observable<GovernorateLightDto[]> {
        let url_ = this.baseUrl + "/api/1/GovernorateDashBoard/GetByCountry?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateLightDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateLightDto[]>;
        }));
    }

    protected processGetByCountry(response: HttpResponseBase): Observable<GovernorateLightDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GovernorateLightDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GuaranteeConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getGuaranteeConfiguration(accept_Language: any | undefined): Observable<GuaranteeConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfiguration/GetGuaranteeConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuaranteeConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuaranteeConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeConfigurationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeConfigurationDto[]>;
        }));
    }

    protected processGetGuaranteeConfiguration(response: HttpResponseBase): Observable<GuaranteeConfigurationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeConfigurationDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GuaranteeConfigurationDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param configurationType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByType(configurationType: GuaranteeConfigurationType | undefined, accept_Language: any | undefined): Observable<ReturnValueDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/GetByType?";
        if (configurationType === null)
            throw new Error("The parameter 'configurationType' cannot be null.");
        else if (configurationType !== undefined)
            url_ += "configurationType=" + encodeURIComponent("" + configurationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReturnValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReturnValueDto>;
        }));
    }

    protected processGetByType(response: HttpResponseBase): Observable<ReturnValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReturnValueDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GuaranteeConfigurationDashboradDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/All?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeConfigurationDashboradDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeConfigurationDashboradDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<GuaranteeConfigurationDashboradDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeConfigurationDashboradDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateGuaranteeConfigurationDto | undefined): Observable<GuaranteeConfigurationDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeConfigurationDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<GuaranteeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeConfigurationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateGuaranteeConfigurationDto | undefined): Observable<GuaranteeConfigurationDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeConfigurationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GuaranteeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeConfigurationDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/GuaranteeConfigurationDashBoard/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GuaranteeShiftServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param zoneId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    shiftsByZone(zoneId: number | undefined, accept_Language: any | undefined): Observable<ShiftDto[]> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShift/ShiftsByZone?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "zoneId=" + encodeURIComponent("" + zoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShiftsByZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShiftsByZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShiftDto[]>;
        }));
    }

    protected processShiftsByZone(response: HttpResponseBase): Observable<ShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShiftDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    calculateShiftPrice(accept_Language: any | undefined, body: CalculateOpjectDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShift/CalculateShiftPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateShiftPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateShiftPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCalculateShiftPrice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GuaranteeShiftDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, id: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GuaranteeShiftDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeShiftDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeShiftDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<GuaranteeShiftDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeShiftDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    allBasic(accept_Language: any | undefined): Observable<GuaranteeShiftDto[]> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/AllBasic";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllBasic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeShiftDto[]>;
        }));
    }

    protected processAllBasic(response: HttpResponseBase): Observable<GuaranteeShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeShiftDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param zoneId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allWithZoneId(zoneId: number | undefined, accept_Language: any | undefined): Observable<GuaranteeShiftDto[]> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/AllWithZoneId?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "zoneId=" + encodeURIComponent("" + zoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllWithZoneId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllWithZoneId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeShiftDto[]>;
        }));
    }

    protected processAllWithZoneId(response: HttpResponseBase): Observable<GuaranteeShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeShiftDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateGuaranteeShiftDto | undefined): Observable<GuaranteeShiftDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeShiftDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<GuaranteeShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveList(accept_Language: any | undefined, body: CreateGuaranteeShiftDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/SaveList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateGuaranteeShiftDto | undefined): Observable<GuaranteeShiftDto> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GuaranteeShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GuaranteeShiftDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GuaranteeShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GuaranteeShiftDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/GuaranteeShiftDashboard/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RejectShiftReasonDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isActive (optional) 
     * @param rejectType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(isActive: boolean | undefined, rejectType: RejectType | undefined, accept_Language: any | undefined): Observable<RejectShiftReasonDto[]> {
        let url_ = this.baseUrl + "/api/1/RejectShiftReasonDashboard/All?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (rejectType === null)
            throw new Error("The parameter 'rejectType' cannot be null.");
        else if (rejectType !== undefined)
            url_ += "RejectType=" + encodeURIComponent("" + rejectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectShiftReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectShiftReasonDto[]>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<RejectShiftReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RejectShiftReasonDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<RejectShiftReasonDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/RejectShiftReasonDashboard/Page?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectShiftReasonDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectShiftReasonDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<RejectShiftReasonDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RejectShiftReasonDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: RejectShiftReasonCreateDto | undefined): Observable<RejectShiftReasonDto> {
        let url_ = this.baseUrl + "/api/1/RejectShiftReasonDashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectShiftReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectShiftReasonDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RejectShiftReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RejectShiftReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: RejectShiftReasonDto | undefined): Observable<RejectShiftReasonDto> {
        let url_ = this.baseUrl + "/api/1/RejectShiftReasonDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectShiftReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectShiftReasonDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RejectShiftReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RejectShiftReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ZoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param cityId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByCity(cityId: number | undefined, accept_Language: any | undefined): Observable<ZoneSimpleDto[]> {
        let url_ = this.baseUrl + "/api/1/Zone/GetByCity?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneSimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneSimpleDto[]>;
        }));
    }

    protected processGetByCity(response: HttpResponseBase): Observable<ZoneSimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneSimpleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    zoneDetails(accept_Language: any | undefined): Observable<ZoneDetailsDto[]> {
        let url_ = this.baseUrl + "/api/1/Zone/ZoneDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processZoneDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processZoneDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDetailsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDetailsDto[]>;
        }));
    }

    protected processZoneDetails(response: HttpResponseBase): Observable<ZoneDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDetailsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ZoneDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param name (optional) 
     * @param maxHours (optional) 
     * @param minHours (optional) 
     * @param cityId (optional) 
     * @param governorateId (optional) 
     * @param isActive (optional) 
     * @param isGuarantee (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, id: number | undefined, name: string | undefined, maxHours: number | undefined, minHours: number | undefined, cityId: number | undefined, governorateId: number | undefined, isActive: boolean | undefined, isGuarantee: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ZoneDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (maxHours === null)
            throw new Error("The parameter 'maxHours' cannot be null.");
        else if (maxHours !== undefined)
            url_ += "MaxHours=" + encodeURIComponent("" + maxHours) + "&";
        if (minHours === null)
            throw new Error("The parameter 'minHours' cannot be null.");
        else if (minHours !== undefined)
            url_ += "MinHours=" + encodeURIComponent("" + minHours) + "&";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&";
        if (governorateId === null)
            throw new Error("The parameter 'governorateId' cannot be null.");
        else if (governorateId !== undefined)
            url_ += "GovernorateId=" + encodeURIComponent("" + governorateId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isGuarantee === null)
            throw new Error("The parameter 'isGuarantee' cannot be null.");
        else if (isGuarantee !== undefined)
            url_ += "IsGuarantee=" + encodeURIComponent("" + isGuarantee) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ZoneDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateZoneDto | undefined): Observable<ZoneDto> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateZoneDto | undefined): Observable<ZoneDto> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cityId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByCityWithPologon(cityId: number | undefined, accept_Language: any | undefined): Observable<ZoneDto[]> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/GetByCityWithPologon?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCityWithPologon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCityWithPologon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDto[]>;
        }));
    }

    protected processGetByCityWithPologon(response: HttpResponseBase): Observable<ZoneDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cityId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getZoneByCity(cityId: number | undefined, accept_Language: any | undefined): Observable<ZoneNameDto[]> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/GetZoneByCity?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZoneByCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZoneByCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneNameDto[]>;
        }));
    }

    protected processGetZoneByCity(response: HttpResponseBase): Observable<ZoneNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneNameDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cityId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getByCity(cityId: number | undefined, accept_Language: any | undefined): Observable<ZoneSimpleDto[]> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/GetByCity?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneSimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneSimpleDto[]>;
        }));
    }

    protected processGetByCity(response: HttpResponseBase): Observable<ZoneSimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneSimpleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activeZone(accept_Language: any | undefined, body: ActiveZoneDto | undefined): Observable<ZoneDto> {
        let url_ = this.baseUrl + "/api/1/ZoneDashBoard/ActiveZone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDto>;
        }));
    }

    protected processActiveZone(response: HttpResponseBase): Observable<ZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ActiveZoneDto {
    id: number;
    isActive: boolean;
}

export interface AllDriverCurrentStatusDto {
    driversCurrentStatusList: DriverCurrentStatusDto[] | null;
    readonly totalCount: number;
    readonly onlineCount: number;
    readonly offlineCount: number;
    readonly busyCount: number;
    readonly freeCount: number;
    readonly availableCount: number;
    readonly requestedCount: number;
    readonly assignedCount: number;
}

export interface ApproveDriverShiftDto {
    id: number;
    isApproved: boolean;
}

export interface CalculateOpjectDto {
    calculateShiftPriceList: CalculateShiftPriceDto[] | null;
}

export interface CalculateShiftPriceDto {
    zoneId: number;
    timeFrom: string | null;
    timeTo: string | null;
}

export interface CityDto {
    id: number;
    name: LocalizedFieldDto;
    isActive: boolean;
    governorateId: number;
    readonly nameLight: string | null;
}

export interface CityDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CityDto[] | null;
}

export interface CityLightDto {
    id: number;
    name: string | null;
    governorateId: number;
}

export interface CitySimpleDto {
    id: number;
    name: LocalizedFieldDto;
}

export interface CountryDto {
    id: number;
    name: LocalizedFieldDto;
    shorName: string | null;
    imageUrl: string | null;
    isActive: boolean;
}

export interface CountryDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CountryDto[] | null;
}

export interface CreateDriverAchievementGuaranteeDto {
    totalAmount: number;
    actualAmount: number;
    driverAchievementStatus: DriverAchievementStatus;
    totalOrder: number;
    achievementOrder: number;
    shiftHours: number;
    driverId: string;
}

export interface CreateDriverObjectDto {
    driverSelectShiftsList: CreateDriverSelectShiftsDto[] | null;
}

export interface CreateDriverSelectShiftsDto {
    zoneId: number;
    timeFrom: string;
    timeTo: string;
}

export interface CreateDriverShiftDto {
    driverId: string;
    timeFrom: string | null;
    timeTo: string | null;
    isApproved: boolean | null;
    supportChangeShiftDescription: string | null;
    rejectDescription: string | null;
    rejectReasonShiftId: number;
    startDate: moment.Moment | null;
    endDate: moment.Moment | null;
    numberOfDay: number;
    codeDriverShift: string | null;
}

export interface CreateGuaranteeConfigurationDto {
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    image: LocalizedFieldDto;
    valueType: ValueTypeEnum;
    guaranteeConfigurationType: GuaranteeConfigurationType;
    value: string | null;
}

export interface CreateGuaranteeShiftDto {
    shiftName: string;
    timeFrom: string;
    timeTo: string;
    price: number;
    isActive: boolean;
    zoneId: number;
}

export interface CreateZoneDto {
    name: LocalizedFieldDto;
    polygon: string;
    isActive: boolean;
    maxHours: number;
    minHours: number;
    cityId: number;
    isGuarantee: boolean;
    mapImage: string;
}

export interface DaysDto {
    day: moment.Moment;
    isActive: boolean;
}

export interface DriverAchievementGuaranteeDetailsDto {
    totalAmount: number;
    actualAmount: number;
    totalOrder: number;
    timeOutOrder: number;
    declinedOrder: number;
    cancelOrder: number;
    acceptOrder: number;
    shiftHours: number;
    timeFrom: string | null;
    timeTo: string | null;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isGuarantee: boolean;
}

export interface DriverAchievementGuaranteeDto {
    id: number;
    totalAmount: number;
    actualAmount: number;
    driverAchievementStatus: string | null;
    totalOrder: number;
    achievementOrder: number;
    shiftHours: number;
    timeFrom: string | null;
    timeTo: string | null;
    driverId: string;
    driverName: string | null;
    isApproved: boolean | null;
    createdAt: moment.Moment;
    readonly isAllowApproved: boolean;
    zoneName: string | null;
    zoneId: string | null;
}

export interface DriverAchievementGuaranteeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: DriverAchievementGuaranteeDto[] | null;
}

export type DriverAchievementStatus = 1 | 2 | 3 | 4 | 5;

export interface DriverCurrentStatusDto {
    id: string;
    readonly fullName: string | null;
    name: string | null;
    lastName: string | null;
    profileImageUrl: string | null;
    rating: number;
    lastTimeUpdated: moment.Moment | null;
    isOnline: boolean;
    isBusy: boolean;
    lastDriverStatus: DriverStatus;
    lastDriverStatusName: string | null;
    latitude: number;
    longitude: number;
    language: string | null;
    phoneNumber: string | null;
    isDedicatedCourier: boolean;
    orderNumber: string | null;
    currentOrderId: string | null;
}

export interface DriverDto {
    id: string;
    rating: number;
    isBusy: boolean;
    status: DriverStatus;
}

export interface DriverShiftDetailsAndDaysDto {
    id: number;
    timeFrom: string | null;
    timeTo: string | null;
    rejectDescription: string | null;
    driverStatus: DriverShiftStatus;
    mapImage: string | null;
    amount: number;
    rejectName: LocalizedFieldDto;
    city: LocalizedFieldDto;
    governorate: LocalizedFieldDto;
    zone: LocalizedFieldDto;
    zoneId: number;
    createdAt: moment.Moment;
    startDate: moment.Moment | null;
    endDate: moment.Moment | null;
    numberOfDay: number;
    days: DaysDto[] | null;
    codeDriverShift: string | null;
}

export interface DriverShiftDetailsDto {
    id: number;
    timeFrom: string | null;
    timeTo: string | null;
    rejectDescription: string | null;
    driverStatus: DriverShiftStatus;
    mapImage: string | null;
    amount: number;
    rejectName: LocalizedFieldDto;
    city: LocalizedFieldDto;
    governorate: LocalizedFieldDto;
    zone: LocalizedFieldDto;
    zoneId: number;
    createdAt: moment.Moment;
    startDate: moment.Moment | null;
    endDate: moment.Moment | null;
    numberOfDay: number;
    codeDriverShift: string | null;
}

export interface DriverShiftDto {
    id: number;
    driverId: string;
    timeFrom: string | null;
    timeTo: string | null;
    isApproved: boolean | null;
    driverStatus: DriverShiftStatus;
    driverStatusName: string | null;
    supportChangeShiftDescription: string | null;
    rejectDescription: string | null;
    rejectReasonShiftId: number;
    driverName: string | null;
    zoneName: string | null;
    zoneId: string | null;
    numberOfDay: number;
    startDate: moment.Moment | null;
    endDate: moment.Moment | null;
    codeDriverShift: string | null;
}

export interface DriverShiftDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: DriverShiftDto[] | null;
}

export type DriverShiftStatus = 1 | 2 | 3 | 4 | 5 | 6;

export type DriverStatus = 0 | 1 | 2;

export interface DriverStatusDto {
    isOnline: boolean;
    latitude: number;
    longitude: number;
    driverId: string | null;
}

export interface GovernorateDto {
    id: number;
    name: LocalizedFieldDto;
    isActive: boolean;
    countryId: number;
}

export interface GovernorateDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GovernorateDto[] | null;
}

export interface GovernorateLightDto {
    id: number;
    name: string | null;
}

export interface GovernorateSimpleDto {
    id: number;
    name: LocalizedFieldDto;
}

export interface GuaranteeConfigurationDashboradDto {
    id: number;
    valueType: ValueTypeEnum;
    guaranteeConfigurationType: GuaranteeConfigurationType;
    value: string | null;
    nameAr: string | null;
    nameEn: string | null;
    descriptionAr: string | null;
    descriptionEn: string | null;
    meetRequired: boolean | null;
    image: LocalizedFieldDto;
}

export interface GuaranteeConfigurationDashboradDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GuaranteeConfigurationDashboradDto[] | null;
}

export interface GuaranteeConfigurationDto {
    id: number;
    guaranteeConfigurationType: GuaranteeConfigurationType;
    value: string | null;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    image: LocalizedFieldDto;
    meetRequired: boolean | null;
}

export type GuaranteeConfigurationType = 1 | 2 | 3;

export interface GuaranteeShiftDto {
    id: number;
    shiftName: string | null;
    timeFrom: string | null;
    timeTo: string | null;
    price: number;
    isActive: boolean;
    zoneId: number | null;
}

export interface GuaranteeShiftDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GuaranteeShiftDto[] | null;
}

export interface LocalizedFieldDto {
    ar: string | null;
    en: string | null;
}

export interface LocationDto {
    latitude: number;
    longitude: number;
}

export interface RejectDriverShiftDto {
    id: number;
    isApproved: boolean | null;
    driverStatus: DriverShiftStatus;
    rejectDescription: string | null;
    rejectReasonShiftId: number;
}

export interface RejectSendAchievementDriverDto {
    id: number;
    rejectDescription: string | null;
}

export interface RejectShiftReasonCreateDto {
    name: LocalizedFieldDto;
    isActive: boolean;
    rejectType: RejectType;
}

export interface RejectShiftReasonDto {
    id: number;
    name: LocalizedFieldDto;
    nameAr: string | null;
    nameEn: string | null;
    isActive: boolean;
    rejectType: RejectType;
    rejectTypeValue: string | null;
}

export interface RejectShiftReasonDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: RejectShiftReasonDto[] | null;
}

export type RejectType = 2 | 4 | 6;

export interface ReturnValueDto {
    value: string | null;
}

export interface RunningShiftDto {
    shfitHour: number;
    timeFrom: string | null;
    timeTo: string | null;
    city: LocalizedFieldDto;
    governorate: LocalizedFieldDto;
    zone: LocalizedFieldDto;
    totalOrder: number;
    totalAcceptedOrder: number;
    percentageAcceptedOrder: number;
    zoneId: number;
    isRunning: boolean;
    currentRunningDay: number;
    guaranteeDays: number;
    startDate: moment.Moment | null;
    endDate: moment.Moment | null;
    guaranteeAmount: number | null;
    codeDriverShift: string | null;
}

export interface ShiftDto {
    timeFrom: string | null;
    timeTo: string | null;
    price: number;
}

export interface SupportCreateDriverShiftDto {
    id: number;
    timeFrom: string | null;
    timeTo: string | null;
    driverStatus: DriverShiftStatus;
    driverId: string;
    zoneId: number;
    numberOfDay: number;
}

export interface SupportUpdateDriverShiftDto {
    id: number;
    timeFrom: string | null;
    timeTo: string | null;
    supportChangeShiftDescription: string | null;
    numberOfDay: number;
}

export interface UpdateDriverAchievementGuaranteeDto {
    id: number;
    totalAmount: number;
    actualAmount: number;
    driverAchievementStatus: DriverAchievementStatus;
    totalOrder: number;
    achievementOrder: number;
    shiftHours: number;
    driverId: string;
}

export interface UpdateDriverShiftDto {
    id: number;
    driverId: string;
    timeFrom: string | null;
    timeTo: string | null;
    isApproved: boolean | null;
    supportChangeShiftDescription: string | null;
    rejectDescription: string | null;
    rejectReasonShiftId: number;
    driverStatus: DriverShiftStatus;
    numberOfDay: number;
}

export interface UpdateGuaranteeConfigurationDto {
    id: number;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    image: LocalizedFieldDto;
    valueType: ValueTypeEnum;
    value: string | null;
    guaranteeConfigurationType: GuaranteeConfigurationType;
}

export interface UpdateGuaranteeShiftDto {
    id: number;
    shiftName: string | null;
    timeFrom: string | null;
    timeTo: string | null;
    price: number;
    isActive: boolean;
    zoneId: number | null;
}

export interface UpdateZoneDto {
    id: number;
    name: LocalizedFieldDto;
    polygon: string | null;
    isActive: boolean;
    maxHours: number;
    minHours: number;
    cityId: number | null;
    isGuarantee: boolean;
    mapImage: string;
}

export type ValueTypeEnum = 1 | 2 | 3 | 4;

export interface ZoneDetailsDto {
    id: number;
    polygon: any | null;
    mapImage: string | null;
}

export interface ZoneDriverShiftDto {
    approved: number;
    reject: number;
    pending: number;
    blocked: number;
    completed: number;
    suspend: number;
    date: moment.Moment | null;
}

export interface ZoneDto {
    id: number;
    name: LocalizedFieldDto;
    nameLight: string | null;
    polygon: string | null;
    isActive: boolean;
    maxHours: number;
    minHours: number;
    cityId: number | null;
    isGuarantee: boolean;
    mapImage: string | null;
}

export interface ZoneDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ZoneDto[] | null;
}

export interface ZoneNameDto {
    id: string | null;
    name: string | null;
    minHours: number;
    maxHours: number;
}

export interface ZoneSimpleDto {
    id: number;
    name: LocalizedFieldDto;
    maxHours: number;
    minHours: number;
    mapImage: string | null;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}