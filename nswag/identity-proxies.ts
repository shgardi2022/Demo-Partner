//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    login(accept_Language: any | undefined, body: LoginInputDto | undefined): Observable<StatusResult> {
        let url_ = this.baseUrl + "/api/2/Account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusResult>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<StatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    loginWithPassword(accept_Language: any | undefined, body: LoginWithPasswordDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/Account/LoginWithPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginWithPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginWithPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processLoginWithPassword(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    fcmTokenGet(userId: string | undefined, accept_Language: any | undefined): Observable<FmcTokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/FcmToken?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFcmTokenGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFcmTokenGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FmcTokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FmcTokenResultDto>;
        }));
    }

    protected processFcmTokenGet(response: HttpResponseBase): Observable<FmcTokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FmcTokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    fcmTokenPost(accept_Language: any | undefined, body: UpdateFcmTokenDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/FcmToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFcmTokenPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFcmTokenPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processFcmTokenPost(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    userLanguage(userId: string | undefined, accept_Language: any | undefined): Observable<GetUserLanguageResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/UserLanguage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserLanguageResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserLanguageResultDto>;
        }));
    }

    protected processUserLanguage(response: HttpResponseBase): Observable<GetUserLanguageResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUserLanguageResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    language(accept_Language: any | undefined, body: UpdateLanguageInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/Language";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processLanguage(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    profileGet(userId: string | undefined, accept_Language: any | undefined): Observable<UserProfileResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileResultDto>;
        }));
    }

    protected processProfileGet(response: HttpResponseBase): Observable<UserProfileResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    profilePost(accept_Language: any | undefined, body: CompleteProfileInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfilePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfilePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processProfilePost(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    profilePut(accept_Language: any | undefined, body: UpdateProfileInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfilePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfilePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processProfilePut(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getUserActivationStatus(accept_Language: any | undefined): Observable<GetUserActivationResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/GetUserActivationStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActivationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActivationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserActivationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserActivationResultDto>;
        }));
    }

    protected processGetUserActivationStatus(response: HttpResponseBase): Observable<GetUserActivationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUserActivationResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    logout(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/Account/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    refreshToken(accept_Language: any | undefined, body: RefreshTokenInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    adminRefreshToken(accept_Language: any | undefined, body: RefreshTokenInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/AdminRefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processAdminRefreshToken(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkSession(accept_Language: any | undefined, body: CheckSessionInputDto | undefined): Observable<CheckSessionOutputDto> {
        let url_ = this.baseUrl + "/api/2/Account/CheckSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckSessionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckSessionOutputDto>;
        }));
    }

    protected processCheckSession(response: HttpResponseBase): Observable<CheckSessionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckSessionOutputDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    donationPartners(accept_Language: any | undefined): Observable<DonationPartnersDto[]> {
        let url_ = this.baseUrl + "/api/2/Account/DonationPartners";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDonationPartners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDonationPartners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DonationPartnersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DonationPartnersDto[]>;
        }));
    }

    protected processDonationPartners(response: HttpResponseBase): Observable<DonationPartnersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DonationPartnersDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateUserFCMTokenAndLanguage(accept_Language: any | undefined, body: UpdateUserFCMTokenAndLanguageInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/Account/UpdateUserFCMTokenAndLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserFCMTokenAndLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserFCMTokenAndLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserFCMTokenAndLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateNotificationToken(accept_Language: any | undefined, body: VmUpdateToken | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/Account/UpdateNotificationToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotificationToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param checkToken (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkToken(checkToken: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/Account/CheckToken?";
        if (checkToken === null)
            throw new Error("The parameter 'checkToken' cannot be null.");
        else if (checkToken !== undefined)
            url_ += "checkToken=" + encodeURIComponent("" + checkToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param model (optional) 
     * @return Success
     */
    changeProfileImagePut(accept_Language: any | undefined, model: ChangeProfileImageDto[] | undefined): Observable<GetChangeProfileImageDto> {
        let url_ = this.baseUrl + "/api/2/Account/ChangeProfileImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (model === null || model === undefined)
            throw new Error("The parameter 'model' cannot be null.");
        else
            model.forEach(item_ => content_.append("model", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeProfileImagePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeProfileImagePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetChangeProfileImageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetChangeProfileImageDto>;
        }));
    }

    protected processChangeProfileImagePut(response: HttpResponseBase): Observable<GetChangeProfileImageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetChangeProfileImageDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    changeProfileImageGet(code: string | undefined, userId: string | undefined, accept_Language: any | undefined): Observable<GetChangeProfileImageDto> {
        let url_ = this.baseUrl + "/api/2/Account/ChangeProfileImage?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeProfileImageGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeProfileImageGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetChangeProfileImageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetChangeProfileImageDto>;
        }));
    }

    protected processChangeProfileImageGet(response: HttpResponseBase): Observable<GetChangeProfileImageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetChangeProfileImageDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    approveChangeProfileImage(accept_Language: any | undefined, body: ApproveRejectChangeProfileRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/Account/ApproveChangeProfileImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveChangeProfileImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveChangeProfileImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveChangeProfileImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param phonenumber (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    encryptPhoneNumber(phonenumber: string | undefined, accept_Language: any | undefined): Observable<EncrptDto> {
        let url_ = this.baseUrl + "/api/3.1/Account/encryptPhoneNumber?";
        if (phonenumber === null)
            throw new Error("The parameter 'phonenumber' cannot be null.");
        else if (phonenumber !== undefined)
            url_ += "phonenumber=" + encodeURIComponent("" + phonenumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEncryptPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEncryptPhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EncrptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EncrptDto>;
        }));
    }

    protected processEncryptPhoneNumber(response: HttpResponseBase): Observable<EncrptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EncrptDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getLastVerficationCode(phonenumber: string, accept_Language: any | undefined): Observable<PhoneCodeDto> {
        let url_ = this.baseUrl + "/api/3.1/Account/GetLastVerficationCode/{phonenumber}";
        if (phonenumber === undefined || phonenumber === null)
            throw new Error("The parameter 'phonenumber' must be defined.");
        url_ = url_.replace("{phonenumber}", encodeURIComponent("" + phonenumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastVerficationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastVerficationCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhoneCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhoneCodeDto>;
        }));
    }

    protected processGetLastVerficationCode(response: HttpResponseBase): Observable<PhoneCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhoneCodeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    verifyAccount(accept_Language: any | undefined, body: VerifyAccountInputEncDto | undefined): Observable<VerifyAccountResultDto> {
        let url_ = this.baseUrl + "/api/3.1/Account/VerifyAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerifyAccountResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerifyAccountResultDto>;
        }));
    }

    protected processVerifyAccount(response: HttpResponseBase): Observable<VerifyAccountResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VerifyAccountResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    verifyPhoneNumber(accept_Language: any | undefined, body: ValidatePhoneNumberInputEncrptDto | undefined): Observable<VerifyPhoneNumberResultDto> {
        let url_ = this.baseUrl + "/api/3.1/Account/VerifyPhoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyPhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerifyPhoneNumberResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerifyPhoneNumberResultDto>;
        }));
    }

    protected processVerifyPhoneNumber(response: HttpResponseBase): Observable<VerifyPhoneNumberResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VerifyPhoneNumberResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    retrySMSCode(accept_Language: any | undefined, body: RetryUserSMSCodeEncrptDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/3.1/Account/RetrySMSCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrySMSCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrySMSCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRetrySMSCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    preForgetPassword(accept_Language: any | undefined, body: PreForgetPasswordEncrptDto | undefined): Observable<PreForgetPasswordResultDto> {
        let url_ = this.baseUrl + "/api/3.1/Account/PreForgetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreForgetPasswordResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreForgetPasswordResultDto>;
        }));
    }

    protected processPreForgetPassword(response: HttpResponseBase): Observable<PreForgetPasswordResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PreForgetPasswordResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkPhoneNumberWithPassword(accept_Language: any | undefined, body: CheckphoneNumberWithPasswordInputDto | undefined): Observable<CheckphoneNumberWithPasswordResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile/CheckPhoneNumberWithPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPhoneNumberWithPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPhoneNumberWithPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckphoneNumberWithPasswordResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckphoneNumberWithPasswordResultDto>;
        }));
    }

    protected processCheckPhoneNumberWithPassword(response: HttpResponseBase): Observable<CheckphoneNumberWithPasswordResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckphoneNumberWithPasswordResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkUserExists(accept_Language: any | undefined, body: CheckUserExistsInputDto | undefined): Observable<CheckUserExistsResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile/CheckUserExists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckUserExistsResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckUserExistsResultDto>;
        }));
    }

    protected processCheckUserExists(response: HttpResponseBase): Observable<CheckUserExistsResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckUserExistsResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setUserPassword(accept_Language: any | undefined, body: SetUserPasswordInputDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/Account/profile/SetUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processSetUserPassword(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeUserPassword(accept_Language: any | undefined, body: ChangeUserPasswordInputDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/Account/profile/ChangeUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processChangeUserPassword(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    forgetUserPassword(accept_Language: any | undefined, body: ForgetUserPasswordInputDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/Account/profile/ForgetUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processForgetUserPassword(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    hasPassword(accept_Language: any | undefined): Observable<HasPasswordResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile/HasPassword";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HasPasswordResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HasPasswordResultDto>;
        }));
    }

    protected processHasPassword(response: HttpResponseBase): Observable<HasPasswordResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HasPasswordResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    validatephoneNumber(accept_Language: any | undefined, body: ValidatePhoneNumberInputDto | undefined): Observable<ValidatePhoneNumberResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile/validatephoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatephoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatephoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidatePhoneNumberResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidatePhoneNumberResultDto>;
        }));
    }

    protected processValidatephoneNumber(response: HttpResponseBase): Observable<ValidatePhoneNumberResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidatePhoneNumberResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    phoneNumber(accept_Language: any | undefined, body: UpdateUserPhoneNumberInputDto | undefined): Observable<UpdateUserPhoneNumberResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/Account/profile/phoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateUserPhoneNumberResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateUserPhoneNumberResultDtoStatusResult>;
        }));
    }

    protected processPhoneNumber(response: HttpResponseBase): Observable<UpdateUserPhoneNumberResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateUserPhoneNumberResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    validateNationalID(nationalId: string, userTypeId: UserType, accept_Language: any | undefined): Observable<GetValidateNationalNumberDto> {
        let url_ = this.baseUrl + "/api/2/Account/profile/ValidateNationalID?";
        if (nationalId === undefined || nationalId === null)
            throw new Error("The parameter 'nationalId' must be defined and cannot be null.");
        else
            url_ += "NationalId=" + encodeURIComponent("" + nationalId) + "&";
        if (userTypeId === undefined || userTypeId === null)
            throw new Error("The parameter 'userTypeId' must be defined and cannot be null.");
        else
            url_ += "UserTypeId=" + encodeURIComponent("" + userTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateNationalID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateNationalID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetValidateNationalNumberDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetValidateNationalNumberDto>;
        }));
    }

    protected processValidateNationalID(response: HttpResponseBase): Observable<GetValidateNationalNumberDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetValidateNationalNumberDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    profilePost(accept_Language: any | undefined, body: CompleteDriverProfileInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/Account/driver/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfilePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfilePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processProfilePost(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    profilePut(accept_Language: any | undefined, body: UpdateDriverProfileInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/Account/driver/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfilePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfilePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProfilePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    images(accept_Language: any | undefined, body: UploadUserImagesDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/driver/images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AccountNoteDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(userId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<AccountNoteDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/AccountNoteDashBoard/page?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountNoteDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountNoteDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<AccountNoteDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountNoteDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: AccountNoteCreateDto | undefined): Observable<AccountNoteDto> {
        let url_ = this.baseUrl + "/api/1/AccountNoteDashBoard/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountNoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountNoteDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AccountNoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountNoteDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    adminlogin(accept_Language: any | undefined, body: AdminLoginViewModel | undefined): Observable<AdminLoginResultViewModel> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/adminlogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminlogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminlogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminLoginResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminLoginResultViewModel>;
        }));
    }

    protected processAdminlogin(response: HttpResponseBase): Observable<AdminLoginResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminLoginResultViewModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    changePassword(accept_Language: any | undefined, body: ChangePasswordViewModel | undefined): Observable<AdminLoginResultViewModel> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminLoginResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminLoginResultViewModel>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<AdminLoginResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminLoginResultViewModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getRolesAndDeviceTypes(accept_Language: any | undefined): Observable<LookupDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/GetRolesAndDeviceTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAndDeviceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAndDeviceTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupDto>;
        }));
    }

    protected processGetRolesAndDeviceTypes(response: HttpResponseBase): Observable<LookupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LookupDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fullName (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkFullNameExists(fullName: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/CheckFullNameExists?";
        if (fullName === null)
            throw new Error("The parameter 'fullName' cannot be null.");
        else if (fullName !== undefined)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckFullNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckFullNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckFullNameExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userName (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkUserNameExists(userName: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/CheckUserNameExists?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckUserNameExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkPhoneNumberRelatedToUser(phoneNumber: string, userId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/CheckPhoneNumberRelatedToUser?";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined and cannot be null.");
        else
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPhoneNumberRelatedToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPhoneNumberRelatedToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckPhoneNumberRelatedToUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param email (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkEmailExists(email: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/CheckEmailExists?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmailExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmailExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckEmailExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param name (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @param userType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(sortDirection: string | undefined, filter: string | undefined, name: string | undefined, email: string | undefined, phone: string | undefined, userType: UserType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<UserProfileDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/All?";
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<UserProfileDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    createAdminUser(accept_Language: any | undefined, body: CreateUserStaffProfileDto | undefined): Observable<UserStaffProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/CreateAdminUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdminUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdminUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserStaffProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserStaffProfileDto>;
        }));
    }

    protected processCreateAdminUser(response: HttpResponseBase): Observable<UserStaffProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserStaffProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    roles(accept_Language: any | undefined, body: UserRoleInputDto | undefined): Observable<UserStaffProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserStaffProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserStaffProfileDto>;
        }));
    }

    protected processRoles(response: HttpResponseBase): Observable<UserStaffProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserStaffProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(accept_Language: any | undefined, body: UserProfileDeleteDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    deletePartner(id: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/DeletePartner?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeletePartner(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    editUser(accept_Language: any | undefined, body: UpdateUserStaffProfileDto | undefined): Observable<UserStaffProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/EditUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserStaffProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserStaffProfileDto>;
        }));
    }

    protected processEditUser(response: HttpResponseBase): Observable<UserStaffProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserStaffProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activateDeactivateStaffUser(accept_Language: any | undefined, body: ActivateDeactivateStaffUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/ActivateDeactivateStaffUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateDeactivateStaffUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateDeactivateStaffUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateDeactivateStaffUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    editSuspendAndUnsuspended(accept_Language: any | undefined, body: SuspendAndUnsuspendedDto | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/EditSuspendAndUnsuspended";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditSuspendAndUnsuspended(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditSuspendAndUnsuspended(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processEditSuspendAndUnsuspended(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activateDeactivateCourior(accept_Language: any | undefined, body: ActivateDeactivateCouriorDto | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/ActivateDeactivateCourior";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateDeactivateCourior(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateDeactivateCourior(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processActivateDeactivateCourior(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param userType (optional) 
     * @param name (optional) 
     * @param email (optional) 
     * @param phoneNumber (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param isActive (optional) 
     * @param isSuspended (optional) 
     * @param hasPendingRequests (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allUsersDrivers(sortDirection: string | undefined, filter: string | undefined, userType: UserType | undefined, name: string | undefined, email: string | undefined, phoneNumber: string | undefined, dateFrom: moment.Moment | undefined, dateTo: moment.Moment | undefined, isActive: boolean | undefined, isSuspended: boolean | undefined, hasPendingRequests: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<UserProfileDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/AllUsersDrivers?";
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isSuspended === null)
            throw new Error("The parameter 'isSuspended' cannot be null.");
        else if (isSuspended !== undefined)
            url_ += "IsSuspended=" + encodeURIComponent("" + isSuspended) + "&";
        if (hasPendingRequests === null)
            throw new Error("The parameter 'hasPendingRequests' cannot be null.");
        else if (hasPendingRequests !== undefined)
            url_ += "HasPendingRequests=" + encodeURIComponent("" + hasPendingRequests) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllUsersDrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllUsersDrivers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDtoPaginatedList>;
        }));
    }

    protected processAllUsersDrivers(response: HttpResponseBase): Observable<UserProfileDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param userType (optional) 
     * @param id (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    filterUsers(filter: string | undefined, userType: UserType | undefined, id: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<UserSimpleProfileDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/FilterUsers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilterUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserSimpleProfileDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserSimpleProfileDtoPaginatedList>;
        }));
    }

    protected processFilterUsers(response: HttpResponseBase): Observable<UserSimpleProfileDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserSimpleProfileDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param name (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @param userType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getCustomerCouriors(sortDirection: string | undefined, filter: string | undefined, name: string | undefined, email: string | undefined, phone: string | undefined, userType: UserType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<UserProfileDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/GetCustomerCouriors?";
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerCouriors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerCouriors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDtoPaginatedList>;
        }));
    }

    protected processGetCustomerCouriors(response: HttpResponseBase): Observable<UserProfileDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    suspend(accept_Language: any | undefined, body: UserSuspendDto | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/Suspend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuspend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuspend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processSuspend(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: UserActivateDto | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getUserRoles(userId: string, filter: string | undefined, accept_Language: any | undefined): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/GetUserRoles/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    removeUserRole(accept_Language: any | undefined, body: RemoveUserRoleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/RemoveUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activateUserRole(accept_Language: any | undefined, body: ActivateUserRoleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/ActivateUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateUserRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    dedicatedCourier(accept_Language: any | undefined, body: DedicatedCourierDto | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/DedicatedCourier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDedicatedCourier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDedicatedCourier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processDedicatedCourier(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sortDirection (optional) 
     * @param name (optional) 
     * @param phoneNumber (optional) 
     * @param email (optional) 
     * @param isActive (optional) 
     * @param isDonatedPartner (optional) 
     * @param isFodx (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allPartners(filter: string | undefined, sortDirection: string | undefined, name: string | undefined, phoneNumber: string | undefined, email: string | undefined, isActive: boolean | undefined, isDonatedPartner: boolean | undefined, isFodx: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerUserDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/AllPartners?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isDonatedPartner === null)
            throw new Error("The parameter 'isDonatedPartner' cannot be null.");
        else if (isDonatedPartner !== undefined)
            url_ += "IsDonatedPartner=" + encodeURIComponent("" + isDonatedPartner) + "&";
        if (isFodx === null)
            throw new Error("The parameter 'isFodx' cannot be null.");
        else if (isFodx !== undefined)
            url_ += "IsFodx=" + encodeURIComponent("" + isFodx) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllPartners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllPartners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerUserDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerUserDtoPaginatedList>;
        }));
    }

    protected processAllPartners(response: HttpResponseBase): Observable<PartnerUserDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerUserDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    selectedPartners(accept_Language: any | undefined, body: string[] | undefined): Observable<GetSelectedPartnerInfoDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/SelectedPartners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectedPartners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectedPartners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSelectedPartnerInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSelectedPartnerInfoDto[]>;
        }));
    }

    protected processSelectedPartners(response: HttpResponseBase): Observable<GetSelectedPartnerInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetSelectedPartnerInfoDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DashboardAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    user(id: string, accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processUser(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    isEmailVerified(id: string, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/IsEmailVerified/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsEmailVerified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsEmailVerified(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsEmailVerified(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    userInfo(accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/UserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processUserInfo(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    role(id: string, accept_Language: any | undefined): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processRole(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getRoleById(id: string, accept_Language: any | undefined): Observable<RoleFullDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetRoleById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleFullDto>;
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<RoleFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    searchPartners(input: string | undefined, accept_Language: any | undefined): Observable<UserProfileDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/searchPartners?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPartners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPartners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto[]>;
        }));
    }

    protected processSearchPartners(response: HttpResponseBase): Observable<UserProfileDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isFox (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    updateUserIsDonatedProperties(userId: string | undefined, isFox: boolean | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/UpdateUserIsDonatedProperties?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (isFox === null)
            throw new Error("The parameter 'isFox' cannot be null.");
        else if (isFox !== undefined)
            url_ += "isFox=" + encodeURIComponent("" + isFox) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserIsDonatedProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserIsDonatedProperties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserIsDonatedProperties(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isFox (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    updateUserIsFoxProperties(userId: string | undefined, isFox: boolean | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/UpdateUserIsFoxProperties?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (isFox === null)
            throw new Error("The parameter 'isFox' cannot be null.");
        else if (isFox !== undefined)
            url_ += "isFox=" + encodeURIComponent("" + isFox) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserIsFoxProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserIsFoxProperties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserIsFoxProperties(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isFedus (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    updateUserIsFeedusProperties(userId: string | undefined, isFedus: boolean | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/UpdateUserIsFeedusProperties?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (isFedus === null)
            throw new Error("The parameter 'isFedus' cannot be null.");
        else if (isFedus !== undefined)
            url_ += "isFedus=" + encodeURIComponent("" + isFedus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserIsFeedusProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserIsFeedusProperties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserIsFeedusProperties(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerDonatedStatus(partnerId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetPartnerDonatedStatus?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerDonatedStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerDonatedStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetPartnerDonatedStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getUserType(userId: string | undefined, accept_Language: any | undefined): Observable<UserType> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetUserType?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserType>;
        }));
    }

    protected processGetUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserType;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerFodx(partnerId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetPartnerFodx?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerFodx(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerFodx(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetPartnerFodx(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerFeedus(partnerId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetPartnerFeedus?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerFeedus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerFeedus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetPartnerFeedus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerBurgerKing(partnerId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetPartnerBurgerKing?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerBurgerKing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerBurgerKing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetPartnerBurgerKing(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isBurgerKing (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    updateUserIsBurgerKingProperties(userId: string | undefined, isBurgerKing: boolean | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/UpdateUserIsBurgerKingProperties?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (isBurgerKing === null)
            throw new Error("The parameter 'isBurgerKing' cannot be null.");
        else if (isBurgerKing !== undefined)
            url_ += "isBurgerKing=" + encodeURIComponent("" + isBurgerKing) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserIsBurgerKingProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserIsBurgerKingProperties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserIsBurgerKingProperties(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param partnerId (optional) 
     * @param partnerDocsType (optional) 
     * @param userType (optional) 
     * @param docFile (optional) 
     * @return Success
     */
    createPartnerDoc(accept_Language: any | undefined, partnerId: string | undefined, partnerDocsType: PartnerDocsType | undefined, userType: UserType | undefined, docFile: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/CreatePartnerDoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (partnerId === null || partnerId === undefined)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else
            content_.append("PartnerId", partnerId.toString());
        if (partnerDocsType === null || partnerDocsType === undefined)
            throw new Error("The parameter 'partnerDocsType' cannot be null.");
        else
            content_.append("PartnerDocsType", partnerDocsType.toString());
        if (userType === null || userType === undefined)
            throw new Error("The parameter 'userType' cannot be null.");
        else
            content_.append("UserType", userType.toString());
        if (docFile === null || docFile === undefined)
            throw new Error("The parameter 'docFile' cannot be null.");
        else
            content_.append("DocFile", docFile.data, docFile.fileName ? docFile.fileName : "DocFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePartnerDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePartnerDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePartnerDoc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerDocList(partnerId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<PartnerDocDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetPartnerDocList?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerDocList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerDocList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerDocDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerDocDtoPaginatedList>;
        }));
    }

    protected processGetPartnerDocList(response: HttpResponseBase): Observable<PartnerDocDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerDocDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param docId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerDoc(docId: string | undefined, accept_Language: any | undefined): Observable<PartnerDocDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/GetPartnerDoc?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerDocDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerDocDto>;
        }));
    }

    protected processGetPartnerDoc(response: HttpResponseBase): Observable<PartnerDocDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerDocDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param docId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    deletePartnerDoc(docId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/DeletePartnerDoc?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePartnerDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePartnerDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePartnerDoc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param freeSearch (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(freeSearch: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<RoleFullDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/Page?";
        if (freeSearch === null)
            throw new Error("The parameter 'freeSearch' cannot be null.");
        else if (freeSearch !== undefined)
            url_ += "FreeSearch=" + encodeURIComponent("" + freeSearch) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleFullDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleFullDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<RoleFullDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleFullDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateRole(accept_Language: any | undefined, body: UpdateRoleDescriptionInputDto | undefined): Observable<RoleFullDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleFullDto>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<RoleFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    all(accept_Language: any | undefined): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    userAvailable(userId: string, accept_Language: any | undefined): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/UserAvailable/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processUserAvailable(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param platformType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    active(platformType: PlatformType | undefined, accept_Language: any | undefined): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/active?";
        if (platformType === null)
            throw new Error("The parameter 'platformType' cannot be null.");
        else if (platformType !== undefined)
            url_ += "platformType=" + encodeURIComponent("" + platformType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: RoleCreateDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    enable(accept_Language: any | undefined, body: RoleEnableDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: RoleUpdateInputDto | undefined): Observable<RoleFullDto> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleFullDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param roleName (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkRoleNameExists(roleName: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/Role/CheckRoleNameExists?";
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "roleName=" + encodeURIComponent("" + roleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRoleNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRoleNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckRoleNameExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RoleUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param roleId (optional) 
     * @param fullName (optional) 
     * @param phoneNumber (optional) 
     * @param email (optional) 
     * @param userType (optional) 
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(roleId: string | undefined, fullName: string | undefined, phoneNumber: string | undefined, email: string | undefined, userType: UserType | undefined, filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<UserProfileDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardAccount/RoleUsers/Page?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (fullName === null)
            throw new Error("The parameter 'fullName' cannot be null.");
        else if (fullName !== undefined)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (userType === null)
            throw new Error("The parameter 'userType' cannot be null.");
        else if (userType !== undefined)
            url_ += "UserType=" + encodeURIComponent("" + userType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<UserProfileDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class 2ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    dashboardEditProfileRequestRejectionReason(id: string, accept_Language: any | undefined): Observable<EditProfileRequestRejectionReasonDto> {
        let url_ = this.baseUrl + "/api/2/DashboardEditProfileRequestRejectionReason/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardEditProfileRequestRejectionReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardEditProfileRequestRejectionReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditProfileRequestRejectionReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditProfileRequestRejectionReasonDto>;
        }));
    }

    protected processDashboardEditProfileRequestRejectionReason(response: HttpResponseBase): Observable<EditProfileRequestRejectionReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EditProfileRequestRejectionReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DashboardEditProfileRequestRejectionReasonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param flag (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, flag: boolean | undefined, accept_Language: any | undefined): Observable<EditProfileRequestRejectionReasonDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardEditProfileRequestRejectionReason/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (flag === null)
            throw new Error("The parameter 'flag' cannot be null.");
        else if (flag !== undefined)
            url_ += "flag=" + encodeURIComponent("" + flag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditProfileRequestRejectionReasonDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditProfileRequestRejectionReasonDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<EditProfileRequestRejectionReasonDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EditProfileRequestRejectionReasonDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateEditProfileRequestRejectionReasonDto | undefined): Observable<EditProfileRequestRejectionReasonDto> {
        let url_ = this.baseUrl + "/api/2/DashboardEditProfileRequestRejectionReason/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditProfileRequestRejectionReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditProfileRequestRejectionReasonDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<EditProfileRequestRejectionReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EditProfileRequestRejectionReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateEditProfileRequestRejectionReasonDto | undefined): Observable<EditProfileRequestRejectionReasonDto> {
        let url_ = this.baseUrl + "/api/2/DashboardEditProfileRequestRejectionReason/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditProfileRequestRejectionReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditProfileRequestRejectionReasonDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EditProfileRequestRejectionReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EditProfileRequestRejectionReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardEditProfileRequestRejectionReason/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setActivation(accept_Language: any | undefined, body: EditProfileRequestRejectionReasonActivationDto | undefined): Observable<EditProfileRequestRejectionReasonDto> {
        let url_ = this.baseUrl + "/api/2/DashboardEditProfileRequestRejectionReason/SetActivation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetActivation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetActivation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditProfileRequestRejectionReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditProfileRequestRejectionReasonDto>;
        }));
    }

    protected processSetActivation(response: HttpResponseBase): Observable<EditProfileRequestRejectionReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EditProfileRequestRejectionReasonDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MenuItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    userMenu(accept_Language: any | undefined): Observable<MenuItemDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/UserMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemDto[]>;
        }));
    }

    protected processUserMenu(response: HttpResponseBase): Observable<MenuItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    userMenuLogistics(accept_Language: any | undefined): Observable<MenuItemDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/UserMenu-logistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserMenuLogistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserMenuLogistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemDto[]>;
        }));
    }

    protected processUserMenuLogistics(response: HttpResponseBase): Observable<MenuItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(sortDirection: string | undefined, filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<MenuItemFullDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/Page?";
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemFullDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemFullDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<MenuItemFullDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemFullDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param platformType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    parentMenuItem(platformType: PlatformType | undefined, accept_Language: any | undefined): Observable<MenuItemFullDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/ParentMenuItem?";
        if (platformType === null)
            throw new Error("The parameter 'platformType' cannot be null.");
        else if (platformType !== undefined)
            url_ += "platformType=" + encodeURIComponent("" + platformType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParentMenuItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParentMenuItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemFullDto[]>;
        }));
    }

    protected processParentMenuItem(response: HttpResponseBase): Observable<MenuItemFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: MenuItemCreate | undefined): Observable<MenuItemFullDto> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemFullDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MenuItemFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: MenuItemUpdate | undefined): Observable<MenuItemFullDto> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemFullDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MenuItemFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(accept_Language: any | undefined, body: MenuItemDelete | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: MenuItemActivate | undefined): Observable<MenuItemFullDto> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemFullDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<MenuItemFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param platformType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allActivate(platformType: PlatformType | undefined, accept_Language: any | undefined): Observable<MenuItemFullDto[]> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItem/AllActivate?";
        if (platformType === null)
            throw new Error("The parameter 'platformType' cannot be null.");
        else if (platformType !== undefined)
            url_ += "platformType=" + encodeURIComponent("" + platformType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemFullDto[]>;
        }));
    }

    protected processAllActivate(response: HttpResponseBase): Observable<MenuItemFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerMenu(accept_Language: any | undefined): Observable<MenuItemDto[]> {
        let url_ = this.baseUrl + "/api/2/PartnerMenu/MenuItem/PartnerMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemDto[]>;
        }));
    }

    protected processPartnerMenu(response: HttpResponseBase): Observable<MenuItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MenuItemRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: MenuItemRoleCreate | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItemRole/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: MenuItemRoleActivate | undefined): Observable<MenuItemRoleDto> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItemRole/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemRoleDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<MenuItemRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemRoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: MenuItemRoleUpdate | undefined): Observable<MenuItemRoleDto> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItemRole/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemRoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemRoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MenuItemRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemRoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(sortDirection: string | undefined, filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<MenuItemRoleFullDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/DashboardMenu/MenuItemRole/Page?";
        if (sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MenuItemRoleFullDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MenuItemRoleFullDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<MenuItemRoleFullDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MenuItemRoleFullDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class EmailVerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendVerifyEmail(accept_Language: any | undefined, body: UserEmailConfirmationInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/EmailVerification/SendVerifyEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerifyEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerifyEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerifyEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    verifyLater(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/EmailVerification/VerifyLater";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyLater(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyLater(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifyLater(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    verifyEmail(accept_Language: any | undefined, body: VerifyUserEmailConfirmationInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/EmailVerification/VerifyEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifyEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IntegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    fodx(partnerId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/Integration/Fodx?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFodx(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFodx(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processFodx(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IntegrationAdapterDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    authorizeUrl(accept_Language: any | undefined): Observable<ResponseAuthorizeDto> {
        let url_ = this.baseUrl + "/api/2/IntegrationAdapterDashBoard/AuthorizeUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorizeUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorizeUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseAuthorizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseAuthorizeDto>;
        }));
    }

    protected processAuthorizeUrl(response: HttpResponseBase): Observable<ResponseAuthorizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseAuthorizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    getUserPartnerToken(accept_Language: any | undefined, body: GetTokenInputDto | undefined): Observable<TokenDto> {
        let url_ = this.baseUrl + "/api/2/IntegrationAdapterDashBoard/GetUserPartnerToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPartnerToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPartnerToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDto>;
        }));
    }

    protected processGetUserPartnerToken(response: HttpResponseBase): Observable<TokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getCustomersCreatedUsers(accept_Language: any | undefined): Observable<CustomerResponseDto[]> {
        let url_ = this.baseUrl + "/api/2/IntegrationAdapterDashBoard/GetCustomersCreatedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersCreatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersCreatedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerResponseDto[]>;
        }));
    }

    protected processGetCustomersCreatedUsers(response: HttpResponseBase): Observable<CustomerResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomerResponseDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    hasPartnerFodxToken(accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/IntegrationAdapterDashBoard/HasPartnerFodxToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasPartnerFodxToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasPartnerFodxToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasPartnerFodxToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LogsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param rowId (optional) 
     * @param tableName (optional) 
     * @param columnName (optional) 
     * @param originalValue (optional) 
     * @param currentValue (optional) 
     * @param url (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    page(rowId: string | undefined, tableName: string | undefined, columnName: string | undefined, originalValue: string | undefined, currentValue: string | undefined, url: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<LogsDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/2/Logs/page?";
        if (rowId === null)
            throw new Error("The parameter 'rowId' cannot be null.");
        else if (rowId !== undefined)
            url_ += "RowId=" + encodeURIComponent("" + rowId) + "&";
        if (tableName === null)
            throw new Error("The parameter 'tableName' cannot be null.");
        else if (tableName !== undefined)
            url_ += "TableName=" + encodeURIComponent("" + tableName) + "&";
        if (columnName === null)
            throw new Error("The parameter 'columnName' cannot be null.");
        else if (columnName !== undefined)
            url_ += "ColumnName=" + encodeURIComponent("" + columnName) + "&";
        if (originalValue === null)
            throw new Error("The parameter 'originalValue' cannot be null.");
        else if (originalValue !== undefined)
            url_ += "OriginalValue=" + encodeURIComponent("" + originalValue) + "&";
        if (currentValue === null)
            throw new Error("The parameter 'currentValue' cannot be null.");
        else if (currentValue !== undefined)
            url_ += "CurrentValue=" + encodeURIComponent("" + currentValue) + "&";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "Url=" + encodeURIComponent("" + url) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogsDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogsDtoPaginatedList>;
        }));
    }

    protected processPage(response: HttpResponseBase): Observable<LogsDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LogsDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    suspendedInfo(userId: string | undefined, accept_Language: any | undefined): Observable<LogsSuspendedInfoOutPutDto> {
        let url_ = this.baseUrl + "/api/2/Logs/SuspendedInfo?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuspendedInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuspendedInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogsSuspendedInfoOutPutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogsSuspendedInfoOutPutDto>;
        }));
    }

    protected processSuspendedInfo(response: HttpResponseBase): Observable<LogsSuspendedInfoOutPutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LogsSuspendedInfoOutPutDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PartnerAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partner(id: string, accept_Language: any | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/Partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    editPartner(accept_Language: any | undefined, body: UpdateUserStaffProfileDto | undefined): Observable<UserStaffProfileDto> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/EditPartner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserStaffProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserStaffProfileDto>;
        }));
    }

    protected processEditPartner(response: HttpResponseBase): Observable<UserStaffProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserStaffProfileDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userName (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkUserNameExists(userName: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/CheckUserNameExists?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckUserNameExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fullName (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkFullNameExists(fullName: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/CheckFullNameExists?";
        if (fullName === null)
            throw new Error("The parameter 'fullName' cannot be null.");
        else if (fullName !== undefined)
            url_ += "fullName=" + encodeURIComponent("" + fullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckFullNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckFullNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckFullNameExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param email (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    checkEmailExists(email: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/CheckEmailExists?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmailExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmailExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckEmailExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    changePassword(accept_Language: any | undefined, body: ChangePasswordViewModel | undefined): Observable<AdminLoginResultViewModel> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/changePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminLoginResultViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminLoginResultViewModel>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<AdminLoginResultViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdminLoginResultViewModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPartnerBurgerKing(partnerId: string | undefined, accept_Language: any | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/PartnerAccount/GetPartnerBurgerKing?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerBurgerKing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerBurgerKing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetPartnerBurgerKing(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    refreshToken(accept_Language: any | undefined, body: RefreshTokenInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreAccount/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    logout(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreAccount/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    store(accept_Language: any | undefined): Observable<StoreAccountDto> {
        let url_ = this.baseUrl + "/api/2/StoreAccount/store";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreAccountDto>;
        }));
    }

    protected processStore(response: HttpResponseBase): Observable<StoreAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreAccountDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getUserActivationStatus(accept_Language: any | undefined): Observable<GetUserActivationStatusResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreAccount/GetUserActivationStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserActivationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserActivationStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserActivationStatusResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserActivationStatusResultDto>;
        }));
    }

    protected processGetUserActivationStatus(response: HttpResponseBase): Observable<GetUserActivationStatusResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUserActivationStatusResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    partnerActivate(accept_Language: any | undefined, body: UserPartnerActivateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreAccountDashboard/StoreAccount/PartnerActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartnerActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    partnerSuspend(accept_Language: any | undefined, body: PartnerSuspendDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreAccountDashboard/StoreAccount/PartnerSuspend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerSuspend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerSuspend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartnerSuspend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    login(accept_Language: any | undefined, body: StoreLoginInputDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/StoreAccount/store/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    loginWithPassword(accept_Language: any | undefined, body: StoreLoginWithPasswordInputDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/StoreAccount/store/loginWithPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginWithPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginWithPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processLoginWithPassword(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreAccountDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: StoreUserActivateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreAccountDashboard/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    suspend(accept_Language: any | undefined, body: StoreUserSuspendDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreAccountDashboard/suspend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuspend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuspend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSuspend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PartnerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    login(accept_Language: any | undefined, body: LoginDto | undefined): Observable<AuthenticateResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticateResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthenticateResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    register(accept_Language: any | undefined, body: PartnerRegisterDto | undefined): Observable<PartnerRegisterResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerRegisterResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerRegisterResultDto>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<PartnerRegisterResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerRegisterResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setWebToken(accept_Language: any | undefined, body: SetPartnerWebTokenDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/SetWebToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetWebToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetWebToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetWebToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateRegister(accept_Language: any | undefined, body: PartnerRegisterDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/ValidateRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateRegister(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    loggedUserInfo(accept_Language: any | undefined): Observable<LoggedUserInfoDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/LoggedUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoggedUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoggedUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoggedUserInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoggedUserInfoDto>;
        }));
    }

    protected processLoggedUserInfo(response: HttpResponseBase): Observable<LoggedUserInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoggedUserInfoDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    changePassword(accept_Language: any | undefined, body: ChangeUserPasswordInputDto | undefined): Observable<LoginResultDtoStatusResult> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDtoStatusResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDtoStatusResult>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<LoginResultDtoStatusResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResultDtoStatusResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    forgetPassword(accept_Language: any | undefined, body: OnSendForgetPasswordEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/ForgetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    newPassword(accept_Language: any | undefined, body: SetNewPasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/NewPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNewPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    userLanguage(userId: string | undefined, accept_Language: any | undefined): Observable<GetUserLanguageResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/UserLanguage?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserLanguageResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserLanguageResultDto>;
        }));
    }

    protected processUserLanguage(response: HttpResponseBase): Observable<GetUserLanguageResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUserLanguageResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    profile(userId: string | undefined, accept_Language: any | undefined): Observable<UserProfileResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/Profile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileResultDto>;
        }));
    }

    protected processProfile(response: HttpResponseBase): Observable<UserProfileResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    logout(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    refreshToken(accept_Language: any | undefined, body: RefreshTokenInputDto | undefined): Observable<TokenResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResultDto>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<TokenResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkSession(accept_Language: any | undefined, body: CheckSessionInputDto | undefined): Observable<CheckSessionOutputDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Partner/CheckSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckSessionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckSessionOutputDto>;
        }));
    }

    protected processCheckSession(response: HttpResponseBase): Observable<CheckSessionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckSessionOutputDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    createStoreUser(accept_Language: any | undefined, body: CreateStoreUserDto | undefined): Observable<StoreUserResultDto> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Stores/CreateStoreUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStoreUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStoreUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreUserResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreUserResultDto>;
        }));
    }

    protected processCreateStoreUser(response: HttpResponseBase): Observable<StoreUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreUserResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateCreateStoreUser(accept_Language: any | undefined, body: CreateStoreUserDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/Stores/ValidateCreateStoreUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCreateStoreUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCreateStoreUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateCreateStoreUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StoreManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    storeEmailAndPhoneNumber(accept_Language: any | undefined, body: UpdateStoreEmailAndPhoneNumberDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/2/StoreManagement/StoreEmailAndPhoneNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreEmailAndPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreEmailAndPhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreEmailAndPhoneNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WebPortalAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driverAccountById(id: string, accept_Language: any | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/2/WebPortalAccount/DriverAccountById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverAccountById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverAccountById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processDriverAccountById(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    driverAccountByPhone(phoneNumber: string, accept_Language: any | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/2/WebPortalAccount/DriverAccountByPhone/{phoneNumber}";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDriverAccountByPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDriverAccountByPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processDriverAccountByPhone(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface AccountNoteCreateDto {
    note: string;
    userId: string;
}

export interface AccountNoteDto {
    id?: string;
    note?: string | undefined;
    userId?: string | undefined;
    createdAt?: moment.Moment;
    createdBy?: string | undefined;
}

export interface AccountNoteDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: AccountNoteDto[] | undefined;
}

export interface ActivateDeactivateCouriorDto {
    id?: string | undefined;
    isActivated?: boolean;
}

export interface ActivateDeactivateStaffUserDto {
    id?: string | undefined;
    isActivated?: boolean;
}

export interface ActivateUserRoleDto {
    userId?: string | undefined;
    roleId?: string | undefined;
    isActive?: boolean;
}

export interface AddressesResponseDto {
    id?: string;
    name?: string | undefined;
    nameLocalized?: string | undefined;
    created_at?: moment.Moment;
    updatedAt?: moment.Moment;
    deletedAt?: moment.Moment;
    customerId?: string;
    deliveryZoneId?: string;
    description?: string | undefined;
    latitude?: number;
    longitude?: number;
}

export interface AdminLoginResultViewModel {
    profileImageURL?: string | undefined;
    nationalIdImageURL?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
    access_token?: string | undefined;
    refreshToken?: string | undefined;
    isComplete?: boolean;
    isActivated?: boolean;
}

export interface AdminLoginViewModel {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export interface ApproveRejectChangeProfileRequestDto {
    id: string;
    approved: boolean;
    rejectReasonId?: string | undefined;
}

export interface AttachmentCreateDto {
    attachmentName?: string | undefined;
    attachmentContent?: string | undefined;
}

export interface AuthenticateResultDto {
    accessToken?: string | undefined;
    readonly access_token?: string | undefined;
    refreshToken?: string | undefined;
    isComplete?: boolean;
    isNewDriver?: boolean;
    isActivated?: boolean;
    isSuspended?: boolean;
    hasPassword?: boolean;
    userName?: string | undefined;
    image?: string | undefined;
    caverImage?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean | undefined;
    showConfimation?: boolean | undefined;
    userId?: string | undefined;
    userType?: UserType;
    expireInSeconds?: number;
}

export interface ChangePasswordViewModel {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;
}

export type ChangeProfileImage = 1 | 2 | 3;

export interface ChangeProfileImageDto {
    imageType?: ProfilePhotoType;
    image: string;
}

export interface ChangeProfileImageResultDto {
    id?: string;
    imageType?: ProfilePhotoType;
    url?: string | undefined;
    currentUrl?: string | undefined;
    status?: ChangeProfileImage;
    rejectReason?: LocalizedFieldDto;
}

export interface ChangeUserPasswordInputDto {
    currentPassword: string;
    newPassword: string;
    confirmPassword: string;
    fcmToken?: string | undefined;
}

export interface CheckSessionInputDto {
    refreshToken?: string | undefined;
}

export interface CheckSessionOutputDto {
    accessTokenIsValid?: boolean;
    refreshTokenIsValid?: boolean;
}

export interface CheckUserExistsInputDto {
    phoneNumber: string;
    userType: UserType;
}

export interface CheckUserExistsResultDto {
    exists?: boolean;
    userProfileResultDto?: UserProfileResultDto;
}

export interface CheckphoneNumberWithPasswordInputDto {
    phoneNumber: string;
    userType: UserType;
}

export interface CheckphoneNumberWithPasswordResultDto {
    hasPassword?: boolean;
    exists?: boolean;
}

export interface CompleteDriverProfileInputDto {
    fullName: string;
    email: string;
    gender: string;
    profilePicture: string;
    nationalId?: string | undefined;
    nationalIdPicture: string;
    areaId: number;
    cityId: number;
    licenseNumber?: string | undefined;
    licenseNumberPicture?: string | undefined;
}

export interface CompleteProfileInputDto {
    fullName: string;
    email?: string | undefined;
    gender: string;
    profilePicture?: string | undefined;
}

export interface CreateEditProfileRequestRejectionReasonDto {
    nameAr: string;
    nameEn: string;
}

export interface CreateStoreUserDto {
    name: string;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    userType?: UserType;
    isActivated?: boolean;
    password: string;
    confirmPassword: string;
    loginName: string;
    storeLogoName?: string | undefined;
    storeLogoContent?: string | undefined;
    storeLogoUrl?: string | undefined;
}

export interface CreateUserStaffProfileDto {
    telephone: string;
    fullName: string;
    email: string;
    deviceTypeId?: number;
    tempPassword?: string | undefined;
    loginName?: string | undefined;
    gender?: Gender;
}

export interface CustomerResponseDto {
    id?: string;
    name?: string | undefined;
    nameLocalized?: string | undefined;
    createdAt?: moment.Moment;
    updatedAt?: moment.Moment;
    deletedAt?: moment.Moment;
    addresses?: AddressesResponseDto[] | undefined;
    houseAccountBalance?: number;
    loyaltyBalance?: number;
    dialCode?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    gender?: number;
    birthDate?: moment.Moment;
    isBlacklisted?: boolean;
    isHouseAccountEnabled?: boolean;
    houseAccountLimit?: number;
    isLoyaltyEnabled?: string | undefined;
}

export interface DedicatedCourierDto {
    id: string;
    isDedicatedCourier: boolean;
}

export type DeviceType = 1 | 2 | 3 | 4;

export interface DeviceTypeViewModel {
    id?: number;
    name: string;
}

export interface DonationPartnersDto {
    partnerId?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    logoUrl?: string | undefined;
}

export interface EditProfileRequestRejectionReasonActivationDto {
    id?: string;
    isActivated?: boolean;
}

export interface EditProfileRequestRejectionReasonDto {
    id?: string;
    nameAr: string;
    nameEn: string;
    isActive?: boolean;
}

export interface EditProfileRequestRejectionReasonDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: EditProfileRequestRejectionReasonDto[] | undefined;
}

export interface EncrptDto {
    encreptObj?: string | undefined;
}

export interface FmcTokenResultDto {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    readonly access_token?: string | undefined;
    fcmToken?: string | undefined;
}

export interface ForgetUserPasswordInputDto {
    newPassword: string;
    fcmToken?: string | undefined;
}

export type Gender = 1 | 2;

export interface GetChangeProfileImageDto {
    isComplete?: boolean;
    images?: ChangeProfileImageResultDto[] | undefined;
}

export interface GetSelectedPartnerInfoDto {
    partnerId?: string | undefined;
    fullName?: string | undefined;
}

export interface GetTokenInputDto {
    code?: string | undefined;
    state?: string | undefined;
}

export interface GetUserActivationResultDto {
    isActivated?: boolean;
    isSuspended?: boolean;
    isCompleted?: boolean;
    isNewDriver?: boolean;
    hasPassword?: boolean;
}

export interface GetUserActivationStatusResultDto {
    isActivated?: boolean;
    isSuspended?: boolean;
    isCompleted?: boolean;
    isNewDriver?: boolean;
}

export interface GetUserLanguageResultDto {
    language?: string | undefined;
}

export interface GetValidateNationalNumberDto {
    isAvailable?: boolean;
    phoneNumberEncrypted?: string | undefined;
    phoneNumber?: string | undefined;
}

export interface HasPasswordResultDto {
    hasPassword?: boolean;
}

export interface LocalizedFieldDto {
    ar?: string | undefined;
    en?: string | undefined;
}

export interface LoggedUserInfoDto {
    id?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    userType?: UserType;
    deviceType?: string | undefined;
    language?: string | undefined;
}

export interface LoginDto {
    userName: string;
    password: string;
}

export interface LoginInputDto {
    phoneNumber: string;
    userType: UserType;
    deviceType: DeviceType;
    fcmToken?: string | undefined;
    userVerificationId?: string | undefined;
    fromShgardiWeb?: boolean;
}

export interface LoginResultDto {
    accessToken?: string | undefined;
    readonly access_token?: string | undefined;
    refreshToken?: string | undefined;
    isComplete?: boolean;
    isNewDriver?: boolean;
    isActivated?: boolean;
    isSuspended?: boolean;
    hasPassword?: boolean;
    userName?: string | undefined;
    image?: string | undefined;
    caverImage?: string | undefined;
    userId?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean | undefined;
    showConfimation?: boolean | undefined;
}

export interface LoginResultDtoStatusResult {
    status?: string | undefined;
    message?: string | undefined;
    response?: LoginResultDto;
}

export interface LoginWithPasswordDto {
    phoneNumber: string;
    password: string;
    userType: UserType;
    deviceType: string;
    fcmToken?: string | undefined;
}

export interface LogsDto {
    id?: number;
    rowId?: string | undefined;
    tableName?: string | undefined;
    columnName?: string | undefined;
    originalValue?: string | undefined;
    currentValue?: string | undefined;
    createdAt?: moment.Moment;
    createdBy?: string | undefined;
    url?: string | undefined;
}

export interface LogsDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: LogsDto[] | undefined;
}

export interface LogsSuspendedInfoOutPutDto {
    createdAt?: moment.Moment;
    createdBy?: string | undefined;
    createUserName?: string | undefined;
}

export interface LookupDto {
    roles?: RoleDto[] | undefined;
    deviceType?: DeviceTypeViewModel[] | undefined;
}

export interface MenuItemActivate {
    id?: string;
    isActive?: boolean;
}

export interface MenuItemCreate {
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    icon?: string | undefined;
    page?: string | undefined;
    parentId?: string | undefined;
    description?: string | undefined;
    orderMenuNumber?: number;
    platformType?: PlatformType;
}

export interface MenuItemDelete {
    id?: string;
}

export interface MenuItemDto {
    id?: string;
    title?: string | undefined;
    icon?: string | undefined;
    page?: string | undefined;
    parentId?: string | undefined;
    isActive?: boolean;
    readonly root?: boolean;
    submenu?: MenuItemDto[] | undefined;
    roleDto?: RoleDto;
}

export interface MenuItemFullDto {
    id?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    description?: string | undefined;
    orderMenuNumber?: number;
    icon?: string | undefined;
    page?: string | undefined;
    parentId?: string | undefined;
    isActive?: boolean;
    platformType?: PlatformType;
}

export interface MenuItemFullDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: MenuItemFullDto[] | undefined;
}

export interface MenuItemRoleActivate {
    id?: string;
    isActive?: boolean;
}

export interface MenuItemRoleCreate {
    roleId?: string | undefined;
    menuItemId?: string[] | undefined;
    isActive?: boolean;
}

export interface MenuItemRoleDto {
    id?: string;
    isActive?: boolean;
    roleId?: string | undefined;
    menuItemId?: string;
}

export interface MenuItemRoleFullDto {
    id?: string;
    isActive?: boolean;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    page?: string | undefined;
    roleName?: string | undefined;
    description?: string | undefined;
}

export interface MenuItemRoleFullDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: MenuItemRoleFullDto[] | undefined;
}

export interface MenuItemRoleUpdate {
    id?: string;
    roleId?: string | undefined;
    menuItemId?: string;
    isActive?: boolean;
}

export interface MenuItemUpdate {
    id?: string;
    titleAr?: string | undefined;
    titleEn?: string | undefined;
    icon?: string | undefined;
    page?: string | undefined;
    parentId?: string | undefined;
    isActive?: boolean;
    description?: string | undefined;
    orderMenuNumber?: number;
    platformType?: PlatformType;
}

export interface OnSendForgetPasswordEmailDto {
    email: string;
    link: string;
    userTypes?: UserType[] | undefined;
}

export interface PartnerCompanyCreateDto {
    id?: string;
    name?: LocalizedFieldDto;
    partnerId?: string | undefined;
}

export interface PartnerCompanyDto {
    id?: string;
    name?: LocalizedFieldDto;
    partnerId?: string | undefined;
}

export interface PartnerCompanyUpdateDto {
    id?: string;
    name?: LocalizedFieldDto;
    partnerId?: string | undefined;
}

export interface PartnerDocDto {
    id?: string;
    partnerId: string;
    partnerDocsType: PartnerDocsType;
    userType: UserType;
    docSrc?: string | undefined;
    docFile: string;
}

export interface PartnerDocDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: PartnerDocDto[] | undefined;
}

export type PartnerDocsType = 1 | 2 | 3;

export interface PartnerRegisterDto {
    phoneNumber: string;
    email?: string | undefined;
    password: string;
    storeLogo: string;
    profileImageURL?: string | undefined;
    userType?: UserType;
    storeName: string;
    industriesIds?: string[] | undefined;
    isActivated?: boolean;
    nationalId?: string | undefined;
    loginName: string;
    inputStoreUser?: CreateStoreUserDto;
    partnerCompany?: PartnerCompanyCreateDto;
    fristName: string;
    lastName: string;
    storeLogoUrl?: string | undefined;
}

export interface PartnerRegisterResultDto {
    partnerId?: string;
    storeId?: string;
}

export interface PartnerSuspendDto {
    userId?: string | undefined;
    suspend?: boolean;
    suspensionReason?: string | undefined;
}

export interface PartnerUserDto {
    id?: string | undefined;
    telephone: string;
    fullName: string;
    email: string;
    roleId?: string | undefined;
    roleName?: string | undefined;
    userType?: string | undefined;
    deviceTypeId?: number;
    deviceTypeName?: string | undefined;
    isActivated?: boolean;
    isSuspended?: boolean;
    isDedicatedCourier?: boolean;
    suspensionReason?: string | undefined;
    createdAt?: moment.Moment;
    profileImageURL?: string | undefined;
    nationalIdImageURL?: string | undefined;
    nationalId?: string | undefined;
    licenseNumberImageURL?: string | undefined;
    gender?: Gender;
    partnerCompany?: PartnerCompanyDto;
    loginName?: string | undefined;
    photoWithIdImageURL?: string | undefined;
    vehicleRegistrationImageURL?: string | undefined;
    userExtraProperty?: UserExtraPropertyDto;
}

export interface PartnerUserDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: PartnerUserDto[] | undefined;
}

export interface PhoneCodeDto {
    phoneCode?: string | undefined;
}

export type PlatformType = 0 | 1 | 2 | 3;

export interface PreForgetPasswordEncrptDto {
    phoneNumber: string;
    userType: UserType;
}

export interface PreForgetPasswordResultDto {
    valid?: boolean;
    isSMSSent?: boolean;
}

export type ProfilePhotoType = 1 | 2 | 3 | 4 | 5;

export interface RefreshTokenInputDto {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
}

export interface RemoveUserRoleDto {
    userId?: string | undefined;
    roleId?: string | undefined;
}

export interface ResponseAuthorizeDto {
    url?: string | undefined;
}

export interface RetryUserSMSCodeEncrptDto {
    phoneNumber: string;
    userType: UserType;
    smsType?: SmsType;
}

export interface RoleCreateDto {
    isActive?: boolean;
    name?: string | undefined;
    details?: string | undefined;
    platformType?: PlatformType;
}

export interface RoleDto {
    id?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    platformType?: PlatformType;
}

export interface RoleEnableDto {
    id?: string | undefined;
    isActive?: boolean;
}

export interface RoleFullDto {
    id?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    details?: string | undefined;
    platformType?: PlatformType;
}

export interface RoleFullDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: RoleFullDto[] | undefined;
}

export interface RoleUpdateInputDto {
    id?: string | undefined;
    isActive?: boolean;
    details?: string | undefined;
    platformType?: PlatformType;
}

export interface SetNewPasswordDto {
    newPassword: string;
    forgetPasswordToken: string;
}

export interface SetPartnerWebTokenDto {
    webToken?: string | undefined;
}

export interface SetUserPasswordInputDto {
    password: string;
    fcmToken?: string | undefined;
}

export type SmsType = 0 | 1 | 2 | 3 | 4;

export interface StatusResult {
    status?: string | undefined;
    message?: string | undefined;
    response?: any | undefined;
}

export interface StoreAccountDto {
    id?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    storeName?: string | undefined;
    storeLogoUrl?: string | undefined;
    commercialRegistrationPhotoUrl?: string | undefined;
    commercialRegistration?: string | undefined;
    twitterAccount?: string | undefined;
    instagramAccount?: string | undefined;
    youtubeAccount?: string | undefined;
    facebookAccount?: string | undefined;
    snapchatAccount?: string | undefined;
    gender?: string | undefined;
    partnerId?: string | undefined;
}

export interface StoreLoginInputDto {
    phoneNumber: string;
    userType: UserType;
    deviceType: string;
    fcmToken?: string | undefined;
    userVerificationId?: string | undefined;
}

export interface StoreLoginWithPasswordInputDto {
    phoneNumber: string;
    password: string;
    userType: UserType;
    deviceType: string;
    fcmToken?: string | undefined;
}

export interface StoreUserActivateDto {
    userId?: string | undefined;
    activate?: boolean;
}

export interface StoreUserResultDto {
    id?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    userType?: UserType;
    deviceType?: string | undefined;
    language?: string | undefined;
}

export interface StoreUserSuspendDto {
    userId?: string | undefined;
    suspend?: boolean;
    suspensionReason?: string | undefined;
}

export interface SuspendAndUnsuspendedDto {
    id?: string | undefined;
    isSuspended?: boolean;
}

export interface TokenDto {
    id?: string | undefined;
    token?: string | undefined;
}

export interface TokenResultDto {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    readonly access_token?: string | undefined;
}

export interface UpdateDriverProfileInputDto {
    fullName: string;
    email: string;
    gender: string;
    profilePicture: string;
    licenseNumber?: string | undefined;
    licenseNumberPicture?: string | undefined;
    nationalId?: string | undefined;
    nationalIdPicture: string;
}

export interface UpdateEditProfileRequestRejectionReasonDto {
    id?: string;
    nameAr: string;
    nameEn: string;
}

export interface UpdateFcmTokenDto {
    fcmToken: string;
}

export interface UpdateLanguageInputDto {
    language: string;
}

export interface UpdateProfileInputDto {
    fullName: string;
    email?: string | undefined;
    gender: string;
    profilePicture?: string | undefined;
}

export interface UpdateRoleDescriptionInputDto {
    roleId?: string | undefined;
    isActive?: boolean;
    details?: string | undefined;
    platformType?: PlatformType;
}

export interface UpdateStoreEmailAndPhoneNumberDto {
    loginName: string;
    userStoreName: string;
    storeId?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    storeLogoName?: string | undefined;
    storeLogoContent?: string | undefined;
    storeLogoUrl?: string | undefined;
}

export interface UpdateUserFCMTokenAndLanguageInputDto {
    from: number;
    to: number;
}

export interface UpdateUserPhoneNumberInputDto {
    newPhoneNumber: string;
    userType: UserType;
    fcmToken?: string | undefined;
}

export interface UpdateUserPhoneNumberResultDto {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    isComplete?: boolean;
    isNewDriver?: boolean;
    isActivated?: boolean;
    isSuspended?: boolean;
    hasPassword?: boolean;
}

export interface UpdateUserPhoneNumberResultDtoStatusResult {
    status?: string | undefined;
    message?: string | undefined;
    response?: UpdateUserPhoneNumberResultDto;
}

export interface UpdateUserStaffProfileDto {
    id?: string | undefined;
    telephone: string;
    fullName: string;
    email: string;
    tempPassword?: string | undefined;
    userType?: number;
    deviceTypeId?: number;
    profileImageURL?: string | undefined;
    gender?: Gender;
    loginName?: string | undefined;
    partnerCompany?: PartnerCompanyUpdateDto;
    nationalId?: string | undefined;
}

export interface UploadUserImagesDto {
    attachment?: AttachmentCreateDto;
    imageType: string;
    userId: string;
}

export interface UserActivateDto {
    id?: string | undefined;
    activate?: boolean;
}

export interface UserDto {
    id?: string | undefined;
    telephone?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    userType?: string | undefined;
    isActivated?: boolean;
    isSuspended?: boolean;
    isDedicatedCourier?: boolean;
    suspensionReason?: string | undefined;
    createdAt?: moment.Moment;
}

export interface UserEmailConfirmationInputDto {
    verificationEmail: string;
}

export interface UserExtraProperty {
    isIntegrationPartner?: boolean;
    isDonatedUser?: boolean;
    isFedus?: boolean;
    isFodx?: boolean;
    isBurgerKing?: boolean;
    isDeliverect?: boolean;
    fodxToken?: string | undefined;
    fodxTokenExpire?: string | undefined;
    deliverectChannelToken?: string | undefined;
    deliverectDispatchToken?: string | undefined;
}

export interface UserExtraPropertyDto {
    isIntegrationPartner?: boolean;
    isDonatedUser?: boolean;
    isFedus?: boolean;
    isFodx?: boolean;
    isBurgerKing?: boolean;
}

export interface UserPartnerActivateDto {
    id?: string | undefined;
    activate?: boolean;
}

export interface UserProfileDeleteDto {
    id?: string | undefined;
}

export interface UserProfileDto {
    id?: string | undefined;
    telephone: string;
    fullName: string;
    email: string;
    roleId?: string | undefined;
    roleName?: string | undefined;
    userType?: string | undefined;
    deviceTypeId?: number;
    deviceTypeName?: string | undefined;
    isActivated?: boolean;
    isSuspended?: boolean;
    isDedicatedCourier?: boolean;
    suspensionReason?: string | undefined;
    createdAt?: moment.Moment;
    profileImageURL?: string | undefined;
    nationalIdImageURL?: string | undefined;
    nationalId?: string | undefined;
    licenseNumberImageURL?: string | undefined;
    gender?: Gender;
    partnerCompany?: PartnerCompanyDto;
    loginName?: string | undefined;
    photoWithIdImageURL?: string | undefined;
    vehicleRegistrationImageURL?: string | undefined;
}

export interface UserProfileDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: UserProfileDto[] | undefined;
}

export interface UserProfileResultDto {
    id?: string | undefined;
    profilePictureUrl?: string | undefined;
    fullName?: string | undefined;
    gender?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    language?: string | undefined;
    nationalIdImageUrl?: string | undefined;
    nationalId?: string | undefined;
    licenseNumber?: string | undefined;
    licenseNumberPicture?: string | undefined;
    photoWithIdImageURL?: string | undefined;
    userExtraProperty?: UserExtraProperty;
    vehicleRegistrationImageURL?: string | undefined;
    emailConfirmed?: boolean | undefined;
    showConfimation?: boolean | undefined;
}

export interface UserRoleInputDto {
    userId?: string | undefined;
    roleIds?: string[] | undefined;
}

export interface UserSimpleProfileDto {
    id?: string | undefined;
    telephone?: string | undefined;
    fullName?: string | undefined;
}

export interface UserSimpleProfileDtoPaginatedList {
    pageIndex?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    items?: UserSimpleProfileDto[] | undefined;
}

export interface UserStaffProfileDto {
    id?: string | undefined;
    telephone: string;
    fullName: string;
    email: string;
    tempPassword?: string | undefined;
    roleIds?: string[] | undefined;
    userType?: string | undefined;
    deviceTypeId?: number;
    isActivated?: boolean;
}

export interface UserSuspendDto {
    id: string;
    suspend: boolean;
    reasons: string;
}

export type UserType = 1 | 2 | 3 | 4 | 5 | 6 | 7;

export interface ValidatePhoneNumberInputDto {
    phoneNumber: string;
}

export interface ValidatePhoneNumberInputEncrptDto {
    phoneNumber: string;
}

export interface ValidatePhoneNumberResultDto {
    valid?: boolean;
}

export interface VerifyAccountInputEncDto {
    phoneNumber: string;
    userType: UserType;
}

export interface VerifyAccountResultDto {
    hasPassword?: boolean;
    phoneNumberExist?: boolean;
    isSuspended?: boolean;
    isSMSSent?: boolean;
}

export interface VerifyPhoneNumberResultDto {
    valid?: boolean;
    isSMSSent?: boolean;
}

export interface VerifyUserEmailConfirmationInputDto {
    verificationCode: string;
}

export interface VmUpdateToken {
    title?: string | undefined;
    body?: string | undefined;
    token?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}