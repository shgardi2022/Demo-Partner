//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class 1ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param industryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    bannerAd(location_Latitude: number, location_Longitude: number, industryId: number | undefined, bannerAdPlacment: BannerAdPlacements, accept_Language: any | undefined): Observable<GetMobileBannerAdsOutputDto[]> {
        let url_ = this.baseUrl + "/api/1/BannerAd?";
        if (location_Latitude === undefined || location_Latitude === null)
            throw new Error("The parameter 'location_Latitude' must be defined and cannot be null.");
        else
            url_ += "Location.Latitude=" + encodeURIComponent("" + location_Latitude) + "&";
        if (location_Longitude === undefined || location_Longitude === null)
            throw new Error("The parameter 'location_Longitude' must be defined and cannot be null.");
        else
            url_ += "Location.Longitude=" + encodeURIComponent("" + location_Longitude) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (bannerAdPlacment === undefined || bannerAdPlacment === null)
            throw new Error("The parameter 'bannerAdPlacment' must be defined and cannot be null.");
        else
            url_ += "BannerAdPlacment=" + encodeURIComponent("" + bannerAdPlacment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBannerAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBannerAd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMobileBannerAdsOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMobileBannerAdsOutputDto[]>;
        }));
    }

    protected processBannerAd(response: HttpResponseBase): Observable<GetMobileBannerAdsOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetMobileBannerAdsOutputDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    cartDelete(id: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Cart?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCartDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param storeId (optional) 
     * @param id (optional) 
     * @param orderType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    cartGet(pageIndex: number | undefined, pageSize: number | undefined, location_Latitude: number, location_Longitude: number, status: CartStatus | undefined, storeId: string | undefined, id: string | undefined, orderType: OrderType | undefined, accept_Language: any | undefined): Observable<CartDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Cart?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (location_Latitude === undefined || location_Latitude === null)
            throw new Error("The parameter 'location_Latitude' must be defined and cannot be null.");
        else
            url_ += "Location.Latitude=" + encodeURIComponent("" + location_Latitude) + "&";
        if (location_Longitude === undefined || location_Longitude === null)
            throw new Error("The parameter 'location_Longitude' must be defined and cannot be null.");
        else
            url_ += "Location.Longitude=" + encodeURIComponent("" + location_Longitude) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCartGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCartGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartDtoPaginatedList>;
        }));
    }

    protected processCartGet(response: HttpResponseBase): Observable<CartDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    component(id: number, accept_Language: any | undefined): Observable<ComponentDto> {
        let url_ = this.baseUrl + "/api/1/Component/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComponent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComponent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComponentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComponentDto>;
        }));
    }

    protected processComponent(response: HttpResponseBase): Observable<ComponentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ComponentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    cuisine(id: number, accept_Language: any | undefined): Observable<CuisineDto> {
        let url_ = this.baseUrl + "/api/1/Cuisine/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCuisine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCuisine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineDto>;
        }));
    }

    protected processCuisine(response: HttpResponseBase): Observable<CuisineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CuisineDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    dashboardItem(id: string, accept_Language: any | undefined): Observable<ItemDto> {
        let url_ = this.baseUrl + "/api/1/DashboardItem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemDto>;
        }));
    }

    protected processDashboardItem(response: HttpResponseBase): Observable<ItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ItemDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    dashboardSubCategory(id: number, accept_Language: any | undefined): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboardSubCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboardSubCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processDashboardSubCategory(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SubCategoryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    deals(id: string, accept_Language: any | undefined): Observable<DealsDto> {
        let url_ = this.baseUrl + "/api/1/Deals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DealsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DealsDto>;
        }));
    }

    protected processDeals(response: HttpResponseBase): Observable<DealsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DealsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    industry(id: number, accept_Language: any | undefined): Observable<IndustryDto> {
        let url_ = this.baseUrl + "/api/1/Industry/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndustry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDto>;
        }));
    }

    protected processIndustry(response: HttpResponseBase): Observable<IndustryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    item(id: string, accept_Language: any | undefined): Observable<ItemDto> {
        let url_ = this.baseUrl + "/api/1/Item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemDto>;
        }));
    }

    protected processItem(response: HttpResponseBase): Observable<ItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ItemDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    product(accept_Language: any | undefined, body: DeleteProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    productComponentGet(productId: number, accept_Language: any | undefined): Observable<GetComponentsForProduct[]> {
        let url_ = this.baseUrl + "/api/1/ProductComponent/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductComponentGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductComponentGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetComponentsForProduct[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetComponentsForProduct[]>;
        }));
    }

    protected processProductComponentGet(response: HttpResponseBase): Observable<GetComponentsForProduct[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetComponentsForProduct[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    productComponentDelete(accept_Language: any | undefined, body: DeleteProductComponentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ProductComponent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductComponentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductComponentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductComponentDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    size(id: number, accept_Language: any | undefined): Observable<SizeDto> {
        let url_ = this.baseUrl + "/api/1/Size/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDto>;
        }));
    }

    protected processSize(response: HttpResponseBase): Observable<SizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    sizeType(id: number, accept_Language: any | undefined): Observable<SizeTypeDto> {
        let url_ = this.baseUrl + "/api/1/SizeType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDto>;
        }));
    }

    protected processSizeType(response: HttpResponseBase): Observable<SizeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    sKUGet(id: number, accept_Language: any | undefined): Observable<SKUDto> {
        let url_ = this.baseUrl + "/api/1/SKU/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSKUGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSKUGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SKUDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SKUDto>;
        }));
    }

    protected processSKUGet(response: HttpResponseBase): Observable<SKUDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SKUDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeIds (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    sKUDelete(id: number, storeIds: string[] | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "storeIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSKUDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSKUDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSKUDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategoryType(id: number, accept_Language: any | undefined): Observable<StoreCategoryTypeDto> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDto>;
        }));
    }

    protected processStoreCategoryType(response: HttpResponseBase): Observable<StoreCategoryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeWorkingDay(storeId: string | undefined, accept_Language: any | undefined): Observable<StoreWorkingDaysDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreWorkingDay?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreWorkingDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreWorkingDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreWorkingDaysDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreWorkingDaysDto[]>;
        }));
    }

    protected processStoreWorkingDay(response: HttpResponseBase): Observable<StoreWorkingDaysDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreWorkingDaysDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    subCategory(id: number, accept_Language: any | undefined): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/1/SubCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processSubCategory(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SubCategoryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    tag(id: number, accept_Language: any | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/1/Tag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TagDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    userFavoriteStorePost(accept_Language: any | undefined, body: CreateUserFavoriteStoreDto | undefined): Observable<UserFavoriteStoreDto> {
        let url_ = this.baseUrl + "/api/1/UserFavoriteStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserFavoriteStorePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserFavoriteStorePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserFavoriteStoreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserFavoriteStoreDto>;
        }));
    }

    protected processUserFavoriteStorePost(response: HttpResponseBase): Observable<UserFavoriteStoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserFavoriteStoreDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    userFavoriteStoreDelete(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/UserFavoriteStore?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserFavoriteStoreDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserFavoriteStoreDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserFavoriteStoreDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BannerAdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: CreateBannerAdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/BannerAd/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateBannerAdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/BannerAd/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: ActivateBannerAdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/BannerAd/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param type (optional) 
     * @param placment (optional) 
     * @param isActive (optional) 
     * @param industryId (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    list(name: string | undefined, type: BannerAdTypes | undefined, placment: BannerAdPlacements | undefined, isActive: boolean | undefined, industryId: number | undefined, from: moment.Moment | undefined, to: moment.Moment | undefined, pageIndex: number | undefined, pageSize: number | undefined, accept_Language: any | undefined): Observable<GetBannerAdOutputDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/BannerAd/list?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (placment === null)
            throw new Error("The parameter 'placment' cannot be null.");
        else if (placment !== undefined)
            url_ += "Placment=" + encodeURIComponent("" + placment) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBannerAdOutputDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBannerAdOutputDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<GetBannerAdOutputDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetBannerAdOutputDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    industries(id: string | undefined, accept_Language: any | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/1/BannerAd/industries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndustries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndustries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processIndustries(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    placements(id: string | undefined, accept_Language: any | undefined): Observable<BannerAdPlacements[]> {
        let url_ = this.baseUrl + "/api/1/BannerAd/placements?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlacements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlacements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BannerAdPlacements[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BannerAdPlacements[]>;
        }));
    }

    protected processPlacements(response: HttpResponseBase): Observable<BannerAdPlacements[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BannerAdPlacements[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    deactivateOld(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/BannerAd/deactivate-old";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateOld(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateOld(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeactivateOld(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/BannerAd/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AllServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param orderType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    active(orderType: OrderType | undefined, pageIndex: number | undefined, pageSize: number | undefined, accept_Language: any | undefined): Observable<ActiveBrandDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Brand/All/Active?";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveBrandDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveBrandDtoPaginatedList>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<ActiveBrandDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ActiveBrandDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BrandDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateBrandDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/BrandDashboard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateBrandDto | undefined): Observable<BrandDto> {
        let url_ = this.baseUrl + "/api/1/BrandDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BrandDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/BrandDashboard/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param isActive (optional) 
     * @param orderType (optional) 
     * @param filter (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(pageIndex: number | undefined, pageSize: number | undefined, isActive: boolean | undefined, orderType: OrderType | undefined, filter: string | undefined, accept_Language: any | undefined): Observable<BrandDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/BrandDashboard/All?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<BrandDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BrandDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorder(accept_Language: any | undefined, body: GuidReOrderingDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/BrandDashboard/Reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/BrandDashboard/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CartServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    itemPost(accept_Language: any | undefined, body: AddCartItemDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Cart/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processItemPost(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    itemPut(accept_Language: any | undefined, body: UpdateCartItemDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Cart/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processItemPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param ids (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    itemDelete(ids: string[] | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Cart/item?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processItemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cartId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    itemsGet(cartId: string | undefined, accept_Language: any | undefined): Observable<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/1/Cart/items?";
        if (cartId === null)
            throw new Error("The parameter 'cartId' cannot be null.");
        else if (cartId !== undefined)
            url_ += "cartId=" + encodeURIComponent("" + cartId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItemDto[]>;
        }));
    }

    protected processItemsGet(response: HttpResponseBase): Observable<CartItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeGet(storeId: string | undefined, accept_Language: any | undefined): Observable<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/1/Cart/store?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItemDto[]>;
        }));
    }

    protected processStoreGet(response: HttpResponseBase): Observable<CartItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    all(accept_Language: any | undefined, body: LocationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Cart/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    completePut(accept_Language: any | undefined, body: CompleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Cart/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompletePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorderPut(accept_Language: any | undefined, body: ReorderDto | undefined): Observable<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/1/Cart/reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorderPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorderPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItemDto[]>;
        }));
    }

    protected processReorderPut(response: HttpResponseBase): Observable<CartItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    itemPost(accept_Language: any | undefined, body: AddCartItemDtoV2 | undefined): Observable<AddCartItemResultDto> {
        let url_ = this.baseUrl + "/api/1.1/Cart/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddCartItemResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddCartItemResultDto>;
        }));
    }

    protected processItemPost(response: HttpResponseBase): Observable<AddCartItemResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AddCartItemResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    itemPut(accept_Language: any | undefined, body: UpdateCartItemDtoV2 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1.1/Cart/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processItemPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    replace(accept_Language: any | undefined, body: ReplaceCartItemsDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1.1/Cart/Replace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processReplace(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param cartId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    itemsGet(cartId: string | undefined, accept_Language: any | undefined): Observable<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/1.1/Cart/items?";
        if (cartId === null)
            throw new Error("The parameter 'cartId' cannot be null.");
        else if (cartId !== undefined)
            url_ += "cartId=" + encodeURIComponent("" + cartId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItemDto[]>;
        }));
    }

    protected processItemsGet(response: HttpResponseBase): Observable<CartItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderType (optional) 
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeGet(orderType: OrderType | undefined, storeId: string | undefined, accept_Language: any | undefined): Observable<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/1.1/Cart/store?";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "orderType=" + encodeURIComponent("" + orderType) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItemDto[]>;
        }));
    }

    protected processStoreGet(response: HttpResponseBase): Observable<CartItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    completePut(accept_Language: any | undefined, body: CompleteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1.1/Cart/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompletePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorderPut(accept_Language: any | undefined, body: ReorderDtoV2 | undefined): Observable<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/1.1/Cart/reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorderPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorderPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartItemDto[]>;
        }));
    }

    protected processReorderPut(response: HttpResponseBase): Observable<CartItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartItemDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class 1.1ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param storeId (optional) 
     * @param id (optional) 
     * @param orderType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    cart(pageIndex: number | undefined, pageSize: number | undefined, location_Latitude: number, location_Longitude: number, status: CartStatus | undefined, storeId: string | undefined, id: string | undefined, orderType: OrderType | undefined, accept_Language: any | undefined): Observable<CartDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1.1/Cart?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (location_Latitude === undefined || location_Latitude === null)
            throw new Error("The parameter 'location_Latitude' must be defined and cannot be null.");
        else
            url_ += "Location.Latitude=" + encodeURIComponent("" + location_Latitude) + "&";
        if (location_Longitude === undefined || location_Longitude === null)
            throw new Error("The parameter 'location_Longitude' must be defined and cannot be null.");
        else
            url_ += "Location.Longitude=" + encodeURIComponent("" + location_Longitude) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CartDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CartDtoPaginatedList>;
        }));
    }

    protected processCart(response: HttpResponseBase): Observable<CartDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CartDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ComponentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ComponentDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Component/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComponentDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComponentDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ComponentDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ComponentDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateComponentDto | undefined): Observable<ComponentDto> {
        let url_ = this.baseUrl + "/api/1/Component/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComponentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComponentDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ComponentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ComponentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateComponentDto | undefined): Observable<ComponentDto> {
        let url_ = this.baseUrl + "/api/1/Component/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComponentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComponentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ComponentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ComponentDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Component/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CuisineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<CuisineDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Cuisine/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<CuisineDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CuisineDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateCuisineDto | undefined): Observable<CuisineDto> {
        let url_ = this.baseUrl + "/api/1/Cuisine/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<CuisineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CuisineDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateCuisineDto | undefined): Observable<CuisineDto> {
        let url_ = this.baseUrl + "/api/1/Cuisine/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CuisineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CuisineDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Cuisine/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Cuisine/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    selectList(accept_Language: any | undefined): Observable<CuisineSelectListDto[]> {
        let url_ = this.baseUrl + "/api/1/Cuisine/SelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineSelectListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineSelectListDto[]>;
        }));
    }

    protected processSelectList(response: HttpResponseBase): Observable<CuisineSelectListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CuisineSelectListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param categoryId (optional) 
     * @param subCategoryId (optional) 
     * @param isActive (optional) 
     * @param orderType (optional) 
     * @param brandId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, categoryId: number | undefined, subCategoryId: number | undefined, isActive: boolean | undefined, orderType: OrderType | undefined, brandId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<ItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/DashboardItem/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (subCategoryId === null)
            throw new Error("The parameter 'subCategoryId' cannot be null.");
        else if (subCategoryId !== undefined)
            url_ += "SubCategoryId=" + encodeURIComponent("" + subCategoryId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ItemDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateItemDto | undefined): Observable<ItemDto> {
        let url_ = this.baseUrl + "/api/1/DashboardItem/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ItemDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateItemDto | undefined): Observable<ItemDto> {
        let url_ = this.baseUrl + "/api/1/DashboardItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ItemDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ItemDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    id(accept_Language: any | undefined, body: ItemDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DashboardItem/id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardSubCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param isActive (optional) 
     * @param orderType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, isActive: boolean | undefined, orderType: OrderType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<SubCategoryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<SubCategoryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SubCategoryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateSubCategoryDto | undefined): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SubCategoryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateSubCategoryDto | undefined): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SubCategoryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    id(accept_Language: any | undefined, body: SubCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorder(accept_Language: any | undefined, body: Int32ReOrderingDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/Reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/DashboardSubCategory/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DealsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param isActive (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, isActive: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<DealsDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Deals/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DealsDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DealsDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<DealsDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DealsDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateDealsDto | undefined): Observable<DealsDto> {
        let url_ = this.baseUrl + "/api/1/Deals/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DealsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DealsDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<DealsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DealsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateDealsDto | undefined): Observable<DealsDto> {
        let url_ = this.baseUrl + "/api/1/Deals/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DealsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DealsDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DealsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DealsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Deals/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Deals/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reOrderinglist(accept_Language: any | undefined, body: GuidReOrderingDto[] | undefined): Observable<DealsDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Deals/ReOrderinglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReOrderinglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReOrderinglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DealsDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DealsDtoPaginatedList>;
        }));
    }

    protected processReOrderinglist(response: HttpResponseBase): Observable<DealsDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DealsDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param discountType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    stores(min: number, max: number, type: DealType, discountType: CatalogDiscountType | undefined, accept_Language: any | undefined): Observable<GetDealStoresCountResult> {
        let url_ = this.baseUrl + "/api/1/Deals/Stores?";
        if (min === undefined || min === null)
            throw new Error("The parameter 'min' must be defined and cannot be null.");
        else
            url_ += "Min=" + encodeURIComponent("" + min) + "&";
        if (max === undefined || max === null)
            throw new Error("The parameter 'max' must be defined and cannot be null.");
        else
            url_ += "Max=" + encodeURIComponent("" + max) + "&";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (discountType === null)
            throw new Error("The parameter 'discountType' cannot be null.");
        else if (discountType !== undefined)
            url_ += "DiscountType=" + encodeURIComponent("" + discountType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDealStoresCountResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDealStoresCountResult>;
        }));
    }

    protected processStores(response: HttpResponseBase): Observable<GetDealStoresCountResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetDealStoresCountResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CatalogDeliveryZoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: CatalogDeliveryZoneActivateInputDto | undefined): Observable<CatalogDeliveryZoneDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/CatalogDeliveryZone/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryZoneDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<CatalogDeliveryZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isIntegrationFare (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getAllDefault(isIntegrationFare: boolean | undefined, accept_Language: any | undefined): Observable<CatalogDeliveryZoneFullDto[]> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/CatalogDeliveryZone/GetAllDefault?";
        if (isIntegrationFare === null)
            throw new Error("The parameter 'isIntegrationFare' cannot be null.");
        else if (isIntegrationFare !== undefined)
            url_ += "IsIntegrationFare=" + encodeURIComponent("" + isIntegrationFare) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryZoneFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryZoneFullDto[]>;
        }));
    }

    protected processGetAllDefault(response: HttpResponseBase): Observable<CatalogDeliveryZoneFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryZoneFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateCatalogDeliveryZoneDto | undefined): Observable<CatalogDeliveryZoneDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/CatalogDeliveryZone/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryZoneDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CatalogDeliveryZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isIntegrationFare (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    get(userId: string | undefined, isIntegrationFare: boolean | undefined, accept_Language: any | undefined): Observable<CatalogDeliveryZoneFullDto[]> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/CatalogDeliveryZone/Get?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (isIntegrationFare === null)
            throw new Error("The parameter 'isIntegrationFare' cannot be null.");
        else if (isIntegrationFare !== undefined)
            url_ += "IsIntegrationFare=" + encodeURIComponent("" + isIntegrationFare) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryZoneFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryZoneFullDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CatalogDeliveryZoneFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryZoneFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: SaveCatalogDeliveryZoneDto | undefined): Observable<CatalogDeliveryZoneDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/CatalogDeliveryZone/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryZoneDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryZoneDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<CatalogDeliveryZoneDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryZoneDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeliveryDistanceFareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: DeliveryDistanceFareActivateInputDto | undefined): Observable<DeliveryDistanceFareDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryDistanceFare/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryDistanceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryDistanceFareDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<DeliveryDistanceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryDistanceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isIntegrationFare (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getDefault(isIntegrationFare: boolean | undefined, accept_Language: any | undefined): Observable<DeliveryDistanceFareFullDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryDistanceFare/GetDefault?";
        if (isIntegrationFare === null)
            throw new Error("The parameter 'isIntegrationFare' cannot be null.");
        else if (isIntegrationFare !== undefined)
            url_ += "IsIntegrationFare=" + encodeURIComponent("" + isIntegrationFare) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryDistanceFareFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryDistanceFareFullDto>;
        }));
    }

    protected processGetDefault(response: HttpResponseBase): Observable<DeliveryDistanceFareFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryDistanceFareFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateDeliveryDistanceFareDto | undefined): Observable<DeliveryDistanceFareDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryDistanceFare/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryDistanceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryDistanceFareDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DeliveryDistanceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryDistanceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isIntegrationFare (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    get(userId: string | undefined, isIntegrationFare: boolean | undefined, accept_Language: any | undefined): Observable<DeliveryDistanceFareDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryDistanceFare/Get?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (isIntegrationFare === null)
            throw new Error("The parameter 'isIntegrationFare' cannot be null.");
        else if (isIntegrationFare !== undefined)
            url_ += "IsIntegrationFare=" + encodeURIComponent("" + isIntegrationFare) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryDistanceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryDistanceFareDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DeliveryDistanceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryDistanceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: SaveDeliveryDistanceFareDto | undefined): Observable<DeliveryDistanceFareDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryDistanceFare/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryDistanceFareDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryDistanceFareDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<DeliveryDistanceFareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryDistanceFareDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeliveryZoneCustomServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: DeliveryZoneCustomCreateInputDto | undefined): Observable<DeliveryZoneCustomDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryZoneCustom/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryZoneCustomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryZoneCustomDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DeliveryZoneCustomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryZoneCustomDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: DeliveryZoneCustomUpdateInputDto | undefined): Observable<DeliveryZoneCustomDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryZoneCustom/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryZoneCustomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryZoneCustomDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DeliveryZoneCustomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryZoneCustomDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param isIntegrationFare (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    get(userId: string | undefined, isIntegrationFare: boolean | undefined, accept_Language: any | undefined): Observable<DeliveryZoneCustomFullDto[]> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryZoneCustom/Get?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (isIntegrationFare === null)
            throw new Error("The parameter 'isIntegrationFare' cannot be null.");
        else if (isIntegrationFare !== undefined)
            url_ += "IsIntegrationFare=" + encodeURIComponent("" + isIntegrationFare) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryZoneCustomFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryZoneCustomFullDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DeliveryZoneCustomFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryZoneCustomFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: DeliveryZoneCustomActivateDto | undefined): Observable<DeliveryZoneCustomDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryZoneCustom/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryZoneCustomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryZoneCustomDto>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<DeliveryZoneCustomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryZoneCustomDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeliveryZoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    getAll(accept_Language: any | undefined): Observable<DeliveryZoneFullDto[]> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryZone/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryZoneFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryZoneFullDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DeliveryZoneFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryZoneFullDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateDeliveryZoneDto | undefined): Observable<DeliveryZoneFullDto> {
        let url_ = this.baseUrl + "/api/1/DeliveryFareDashBoard/DeliveryZone/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryZoneFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryZoneFullDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DeliveryZoneFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryZoneFullDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DiscountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param isActive (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    list(pageIndex: number | undefined, pageSize: number | undefined, isActive: boolean | undefined, accept_Language: any | undefined): Observable<CatalogDiscountDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Discount/list?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDiscountDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDiscountDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<CatalogDiscountDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDiscountDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(accept_Language: any | undefined, body: CreateDiscountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Discount/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: ActivateDiscountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Discount/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    delete(id: string, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Discount/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    deactivateOld(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Discount/deactivate-old";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateOld(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateOld(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeactivateOld(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HorizontalBarServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    list(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GetHorizntalBarOutputDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/list?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHorizntalBarOutputDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHorizntalBarOutputDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<GetHorizntalBarOutputDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetHorizntalBarOutputDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: CreateHorizontalBarDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateHorizontalBarDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: ActivateHorizontalBarDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delete(id: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorder(accept_Language: any | undefined, body: GuidReOrderingDto[] | undefined): Observable<GetHorizntalBarOutputDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHorizntalBarOutputDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHorizntalBarOutputDtoPaginatedList>;
        }));
    }

    protected processReorder(response: HttpResponseBase): Observable<GetHorizntalBarOutputDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetHorizntalBarOutputDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/HorizontalBar/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IndustryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<IndustryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Industry/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<IndustryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    allByPartner(accept_Language: any | undefined): Observable<IndustryDto[]> {
        let url_ = this.baseUrl + "/api/1/Industry/AllByPartner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllByPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllByPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDto[]>;
        }));
    }

    protected processAllByPartner(response: HttpResponseBase): Observable<IndustryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allActive(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<IndustryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Industry/AllActive?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDtoPaginatedList>;
        }));
    }

    protected processAllActive(response: HttpResponseBase): Observable<IndustryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateIndustryDto | undefined): Observable<IndustryDto> {
        let url_ = this.baseUrl + "/api/1/Industry/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<IndustryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateIndustryDto | undefined): Observable<IndustryDto> {
        let url_ = this.baseUrl + "/api/1/Industry/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IndustryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    id(accept_Language: any | undefined, body: IndustryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Industry/id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    partner(accept_Language: any | undefined, body: SetPartnerIndusriesDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Industry/Partner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    maxAllowedStoreCategory(accept_Language: any | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/1/Industry/MaxAllowedStoreCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMaxAllowedStoreCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxAllowedStoreCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processMaxAllowedStoreCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Industry/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CatalogIndustryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<IndustryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/IndustryDashBoard/CatalogIndustry/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<IndustryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allByPartner(id: string | undefined, accept_Language: any | undefined): Observable<IndustryDto[]> {
        let url_ = this.baseUrl + "/api/1/IndustryDashBoard/CatalogIndustry/AllByPartner?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllByPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllByPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IndustryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IndustryDto[]>;
        }));
    }

    protected processAllByPartner(response: HttpResponseBase): Observable<IndustryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IndustryDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    savePartnerIndusries(accept_Language: any | undefined, body: SetPartnerIndusriesDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/IndustryDashBoard/CatalogIndustry/SavePartnerIndusries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePartnerIndusries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePartnerIndusries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePartnerIndusries(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IntegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    createStore(accept_Language: any | undefined, body: CreateStoreDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Integration/CreateStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateStore(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveAdditionalSKU(accept_Language: any | undefined, body: CreateAdditionalSkuDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveAdditionalSKU";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAdditionalSKU(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAdditionalSKU(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAdditionalSKU(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveSizeType(accept_Language: any | undefined, body: CreateSizeTypeDto | undefined): Observable<SizeTypeDto> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveSizeType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSizeType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSizeType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDto>;
        }));
    }

    protected processSaveSizeType(response: HttpResponseBase): Observable<SizeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveTag(accept_Language: any | undefined, body: CreateTagDto | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processSaveTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TagDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveSize(accept_Language: any | undefined, body: CreateSizeDto | undefined): Observable<SizeDto> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveSize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDto>;
        }));
    }

    protected processSaveSize(response: HttpResponseBase): Observable<SizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveOption(accept_Language: any | undefined, body: CreateSkuOptionDto | undefined): Observable<CreateSkuOptionResultDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveOption";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateSkuOptionResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateSkuOptionResultDto[]>;
        }));
    }

    protected processSaveOption(response: HttpResponseBase): Observable<CreateSkuOptionResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateSkuOptionResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveProduct(accept_Language: any | undefined, body: CreateProductDto | undefined): Observable<CreateProductResultDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateProductResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateProductResultDto[]>;
        }));
    }

    protected processSaveProduct(response: HttpResponseBase): Observable<CreateProductResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateProductResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveStoreCategory(accept_Language: any | undefined, body: CreateStoreCategoryDto | undefined): Observable<CreateStoreCategoryResultDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveStoreCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveStoreCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveStoreCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateStoreCategoryResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateStoreCategoryResultDto[]>;
        }));
    }

    protected processSaveStoreCategory(response: HttpResponseBase): Observable<CreateStoreCategoryResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateStoreCategoryResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    sizeTypeList(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<SizeTypeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Integration/SizeTypeList?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDtoPaginatedList>;
        }));
    }

    protected processSizeTypeList(response: HttpResponseBase): Observable<SizeTypeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeProductList(storeId: string | undefined, accept_Language: any | undefined): Observable<GetStoreCategories[]> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreProductList?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreProductList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreProductList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreCategories[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreCategories[]>;
        }));
    }

    protected processStoreProductList(response: HttpResponseBase): Observable<GetStoreCategories[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreCategories[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeCategoryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    categoryProductsList(storeCategoryId: number | undefined, accept_Language: any | undefined): Observable<GetStoreProducts[]> {
        let url_ = this.baseUrl + "/api/1/Integration/CategoryProductsList?";
        if (storeCategoryId === null)
            throw new Error("The parameter 'storeCategoryId' cannot be null.");
        else if (storeCategoryId !== undefined)
            url_ += "storeCategoryId=" + encodeURIComponent("" + storeCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryProductsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryProductsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreProducts[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreProducts[]>;
        }));
    }

    protected processCategoryProductsList(response: HttpResponseBase): Observable<GetStoreProducts[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreProducts[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategories(storeId: string | undefined, accept_Language: any | undefined): Observable<GetCatgoryListDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategories?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCatgoryListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCatgoryListDto[]>;
        }));
    }

    protected processStoreCategories(response: HttpResponseBase): Observable<GetCatgoryListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetCatgoryListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    productSkus(productId: number | undefined, accept_Language: any | undefined): Observable<GetIntegrationProductSkusDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/ProductSkus?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductSkus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIntegrationProductSkusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIntegrationProductSkusDto[]>;
        }));
    }

    protected processProductSkus(response: HttpResponseBase): Observable<GetIntegrationProductSkusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetIntegrationProductSkusDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skuId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    skuOption(skuId: number | undefined, accept_Language: any | undefined): Observable<GetIntegrationSkuOptionsDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/SkuOption?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIntegrationSkuOptionsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIntegrationSkuOptionsDto[]>;
        }));
    }

    protected processSkuOption(response: HttpResponseBase): Observable<GetIntegrationSkuOptionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetIntegrationSkuOptionsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param productType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeMenu(storeId: string | undefined, productType: ProductType | undefined, accept_Language: any | undefined): Observable<GetStoreCategories[]> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreMenu?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (productType === null)
            throw new Error("The parameter 'productType' cannot be null.");
        else if (productType !== undefined)
            url_ += "productType=" + encodeURIComponent("" + productType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreCategories[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreCategories[]>;
        }));
    }

    protected processStoreMenu(response: HttpResponseBase): Observable<GetStoreCategories[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreCategories[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerSizes(accept_Language: any | undefined): Observable<GetPartnerSizesListDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/PartnerSizes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerSizes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerSizes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPartnerSizesListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPartnerSizesListDto[]>;
        }));
    }

    protected processPartnerSizes(response: HttpResponseBase): Observable<GetPartnerSizesListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPartnerSizesListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerSizeTypes(accept_Language: any | undefined): Observable<GetPartnerSizeTypesListDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/partnerSizeTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerSizeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerSizeTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPartnerSizeTypesListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPartnerSizeTypesListDto[]>;
        }));
    }

    protected processPartnerSizeTypes(response: HttpResponseBase): Observable<GetPartnerSizeTypesListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPartnerSizeTypesListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateOrderItems(accept_Language: any | undefined, body: ValidateOrderItemsInputDto | undefined): Observable<ValidateOrderItemsResponseDto> {
        let url_ = this.baseUrl + "/api/1/Integration/ValidateOrderItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateOrderItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateOrderItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidateOrderItemsResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidateOrderItemsResponseDto>;
        }));
    }

    protected processValidateOrderItems(response: HttpResponseBase): Observable<ValidateOrderItemsResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidateOrderItemsResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveOptionItem(accept_Language: any | undefined, body: CreateStoreOptionItemDto | undefined): Observable<CreateStoreOptionItemResultDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/SaveOptionItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOptionItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOptionItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateStoreOptionItemResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateStoreOptionItemResultDto[]>;
        }));
    }

    protected processSaveOptionItem(response: HttpResponseBase): Observable<CreateStoreOptionItemResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateStoreOptionItemResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    sizesList(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<SizeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Integration/SizesList?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDtoPaginatedList>;
        }));
    }

    protected processSizesList(response: HttpResponseBase): Observable<SizeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategoryTypeList(accept_Language: any | undefined): Observable<StoreCategoryTypeDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategoryTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDto[]>;
        }));
    }

    protected processStoreCategoryTypeList(response: HttpResponseBase): Observable<StoreCategoryTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerStores(partnerId: string | undefined, accept_Language: any | undefined): Observable<StoreDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/PartnerStores?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto[]>;
        }));
    }

    protected processPartnerStores(response: HttpResponseBase): Observable<StoreDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeDetails(storeId: string | undefined, accept_Language: any | undefined): Observable<StoreDto> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreDetails?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto>;
        }));
    }

    protected processStoreDetails(response: HttpResponseBase): Observable<StoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    sizeTypeGet(id: number, accept_Language: any | undefined): Observable<SizeTypeDto> {
        let url_ = this.baseUrl + "/api/1/Integration/SizeType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeTypeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeTypeGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDto>;
        }));
    }

    protected processSizeTypeGet(response: HttpResponseBase): Observable<SizeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    sizeTypeDelete(id: number, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/SizeType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeTypeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeTypeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSizeTypeDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    sizeGet(id: number, accept_Language: any | undefined): Observable<SizeDto> {
        let url_ = this.baseUrl + "/api/1/Integration/Size/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDto>;
        }));
    }

    protected processSizeGet(response: HttpResponseBase): Observable<SizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    sizeDelete(id: number, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/Size/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSizeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSizeDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSizeDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeWorkingDaysGet(storeId: string | undefined, accept_Language: any | undefined): Observable<AvailableHourDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreWorkingDays?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreWorkingDaysGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreWorkingDaysGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableHourDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableHourDto[]>;
        }));
    }

    protected processStoreWorkingDaysGet(response: HttpResponseBase): Observable<AvailableHourDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableHourDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeWorkingDaysDelete(storeId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreWorkingDays?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreWorkingDaysDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreWorkingDaysDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreWorkingDaysDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeCategoryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategoryGet(storeCategoryId: number | undefined, accept_Language: any | undefined): Observable<CategoryResponseDto> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategory?";
        if (storeCategoryId === null)
            throw new Error("The parameter 'storeCategoryId' cannot be null.");
        else if (storeCategoryId !== undefined)
            url_ += "storeCategoryId=" + encodeURIComponent("" + storeCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponseDto>;
        }));
    }

    protected processStoreCategoryGet(response: HttpResponseBase): Observable<CategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CategoryResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeCategoryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategoryDelete(storeCategoryId: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategory?";
        if (storeCategoryId === null)
            throw new Error("The parameter 'storeCategoryId' cannot be null.");
        else if (storeCategoryId !== undefined)
            url_ += "storeCategoryId=" + encodeURIComponent("" + storeCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreCategoryDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    storeCategoryPut(accept_Language: any | undefined, body: UpdateStoreCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreCategoryPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeCategoryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategoryAvailableHour(storeCategoryId: number | undefined, accept_Language: any | undefined): Observable<AvailableHourDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategoryAvailableHour?";
        if (storeCategoryId === null)
            throw new Error("The parameter 'storeCategoryId' cannot be null.");
        else if (storeCategoryId !== undefined)
            url_ += "storeCategoryId=" + encodeURIComponent("" + storeCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryAvailableHour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryAvailableHour(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableHourDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableHourDto[]>;
        }));
    }

    protected processStoreCategoryAvailableHour(response: HttpResponseBase): Observable<AvailableHourDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableHourDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    productGet(productId: number | undefined, accept_Language: any | undefined): Observable<ProductResponseDto> {
        let url_ = this.baseUrl + "/api/1/Integration/product?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductResponseDto>;
        }));
    }

    protected processProductGet(response: HttpResponseBase): Observable<ProductResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    productDelete(accept_Language: any | undefined, body: DeleteProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    productAvailableHour(productId: number | undefined, accept_Language: any | undefined): Observable<AvailableHourDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/ProductAvailableHour?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductAvailableHour(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductAvailableHour(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableHourDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableHourDto[]>;
        }));
    }

    protected processProductAvailableHour(response: HttpResponseBase): Observable<AvailableHourDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableHourDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param optionId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    optionGet(optionId: number | undefined, accept_Language: any | undefined): Observable<GetIntegrationOptionDto> {
        let url_ = this.baseUrl + "/api/1/Integration/Option?";
        if (optionId === null)
            throw new Error("The parameter 'optionId' cannot be null.");
        else if (optionId !== undefined)
            url_ += "optionId=" + encodeURIComponent("" + optionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIntegrationOptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIntegrationOptionDto>;
        }));
    }

    protected processOptionGet(response: HttpResponseBase): Observable<GetIntegrationOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetIntegrationOptionDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    optionDelete(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/Option?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param optionItemId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    optionItemGet(optionItemId: number | undefined, accept_Language: any | undefined): Observable<GetIntegrationSkuOptionItemsDto> {
        let url_ = this.baseUrl + "/api/1/Integration/OptionItem?";
        if (optionItemId === null)
            throw new Error("The parameter 'optionItemId' cannot be null.");
        else if (optionItemId !== undefined)
            url_ += "optionItemId=" + encodeURIComponent("" + optionItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionItemGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionItemGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIntegrationSkuOptionItemsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIntegrationSkuOptionItemsDto>;
        }));
    }

    protected processOptionItemGet(response: HttpResponseBase): Observable<GetIntegrationSkuOptionItemsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetIntegrationSkuOptionItemsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    optionItemDelete(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/OptionItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionItemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionItemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionItemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    skuGet(id: number | undefined, accept_Language: any | undefined): Observable<IntegrationSkuDto> {
        let url_ = this.baseUrl + "/api/1/Integration/sku?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegrationSkuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegrationSkuDto>;
        }));
    }

    protected processSkuGet(response: HttpResponseBase): Observable<IntegrationSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IntegrationSkuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    skuDelete(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/sku?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSkuDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    skuPut(accept_Language: any | undefined, body: UpdateAdditionalSkuDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/sku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkuPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkuPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSkuPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parnterId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerMenu(parnterId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/PartnerMenu?";
        if (parnterId === null)
            throw new Error("The parameter 'parnterId' cannot be null.");
        else if (parnterId !== undefined)
            url_ += "parnterId=" + encodeURIComponent("" + parnterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartnerMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    workingDays(accept_Language: any | undefined, body: SetStoreWorkingDaysDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/workingDays";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkingDays(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkingDays(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWorkingDays(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    store(storeId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/Store?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeCategoryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeCategoryAvailableHoursDelete(storeCategoryId: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategoryAvailableHours?";
        if (storeCategoryId === null)
            throw new Error("The parameter 'storeCategoryId' cannot be null.");
        else if (storeCategoryId !== undefined)
            url_ += "storeCategoryId=" + encodeURIComponent("" + storeCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryAvailableHoursDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryAvailableHoursDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreCategoryAvailableHoursDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    storeCategoryAvailableHoursPut(accept_Language: any | undefined, body: SetStoreCategoryAvailableHoursDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/StoreCategoryAvailableHours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreCategoryAvailableHoursPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreCategoryAvailableHoursPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStoreCategoryAvailableHoursPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    productCategoryAvailableHours(productId: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/ProductCategoryAvailableHours?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductCategoryAvailableHours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductCategoryAvailableHours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProductCategoryAvailableHours(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateStore(accept_Language: any | undefined, body: UpdateStoreDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Integration/UpdateStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateStore(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateSizeType(accept_Language: any | undefined, body: UpdateSizeTypeDto | undefined): Observable<SizeTypeDto> {
        let url_ = this.baseUrl + "/api/1/Integration/UpdateSizeType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSizeType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSizeType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDto>;
        }));
    }

    protected processUpdateSizeType(response: HttpResponseBase): Observable<SizeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateSize(accept_Language: any | undefined, body: UpdateSizeDto | undefined): Observable<SizeDto> {
        let url_ = this.baseUrl + "/api/1/Integration/UpdateSize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDto>;
        }));
    }

    protected processUpdateSize(response: HttpResponseBase): Observable<SizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    product(accept_Language: any | undefined, body: UpdateProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    option(accept_Language: any | undefined, body: UpdateSkuOption | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Integration/option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    uploadStoreCategoryImageBase64(accept_Language: any | undefined, body: AttachmentCreateDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/Integration/UploadStoreCategoryImageBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadStoreCategoryImageBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadStoreCategoryImageBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadStoreCategoryImageBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    busy(accept_Language: any | undefined, body: SetStoreBusyDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/1/Integration/busy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBusy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBusy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processBusy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    stores(accept_Language: any | undefined): Observable<StoreDto[]> {
        let url_ = this.baseUrl + "/api/1/Integration/Stores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto[]>;
        }));
    }

    protected processStores(response: HttpResponseBase): Observable<StoreDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    store(id: string, accept_Language: any | undefined): Observable<StoreDto> {
        let url_ = this.baseUrl + "/api/1/Integration/store/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto>;
        }));
    }

    protected processStore(response: HttpResponseBase): Observable<StoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param categoryId (optional) 
     * @param subCategoryId (optional) 
     * @param isActive (optional) 
     * @param orderType (optional) 
     * @param brandId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, categoryId: number | undefined, subCategoryId: number | undefined, isActive: boolean | undefined, orderType: OrderType | undefined, brandId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GetItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Item/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (subCategoryId === null)
            throw new Error("The parameter 'subCategoryId' cannot be null.");
        else if (subCategoryId !== undefined)
            url_ += "SubCategoryId=" + encodeURIComponent("" + subCategoryId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (brandId === null)
            throw new Error("The parameter 'brandId' cannot be null.");
        else if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetItemDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<GetItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetItemDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MobileMenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<MobileMenuDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/MobileMenu/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileMenuDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileMenuDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<MobileMenuDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileMenuDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateMobileMenuDto | undefined): Observable<MobileMenuDto> {
        let url_ = this.baseUrl + "/api/1/MobileMenu/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileMenuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileMenuDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<MobileMenuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileMenuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateMobileMenuDto | undefined): Observable<MobileMenuDto> {
        let url_ = this.baseUrl + "/api/1/MobileMenu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileMenuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileMenuDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MobileMenuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileMenuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/MobileMenu/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reOrderinglist(accept_Language: any | undefined, body: GuidReOrderingDto[] | undefined): Observable<MobileMenuDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/MobileMenu/ReOrderinglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReOrderinglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReOrderinglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileMenuDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileMenuDtoPaginatedList>;
        }));
    }

    protected processReOrderinglist(response: HttpResponseBase): Observable<MobileMenuDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileMenuDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param storeId (optional) 
     * @param maxReturnedItems (optional) 
     * @param orderType (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    recent(location_Latitude: number, location_Longitude: number, storeId: string | undefined, maxReturnedItems: number | undefined, orderType: OrderType | undefined, accept_Language: any | undefined): Observable<RecentOrderResultDto> {
        let url_ = this.baseUrl + "/api/1/Order/recent?";
        if (location_Latitude === undefined || location_Latitude === null)
            throw new Error("The parameter 'location_Latitude' must be defined and cannot be null.");
        else
            url_ += "Location.Latitude=" + encodeURIComponent("" + location_Latitude) + "&";
        if (location_Longitude === undefined || location_Longitude === null)
            throw new Error("The parameter 'location_Longitude' must be defined and cannot be null.");
        else
            url_ += "Location.Longitude=" + encodeURIComponent("" + location_Longitude) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (maxReturnedItems === null)
            throw new Error("The parameter 'maxReturnedItems' cannot be null.");
        else if (maxReturnedItems !== undefined)
            url_ += "MaxReturnedItems=" + encodeURIComponent("" + maxReturnedItems) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecentOrderResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecentOrderResultDto>;
        }));
    }

    protected processRecent(response: HttpResponseBase): Observable<RecentOrderResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RecentOrderResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerAdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param partnerId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param isActive (optional) 
     * @param status (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    list(partnerId: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, isActive: boolean | undefined, status: AdsStatus | undefined, from: moment.Moment | undefined, to: moment.Moment | undefined, accept_Language: any | undefined): Observable<GetPartnerAdsListResultDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/PartnerAd/list?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPartnerAdsListResultDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPartnerAdsListResultDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<GetPartnerAdsListResultDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPartnerAdsListResultDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(accept_Language: any | undefined, body: CreatePartnerAdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerAd/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    edit(accept_Language: any | undefined, body: EditPartnerAdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerAd/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: ActivatePartnerAdDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerAd/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PartnerPaymentMethodsDashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    paymentTypes(accept_Language: any | undefined): Observable<PaymentTypeDto[]> {
        let url_ = this.baseUrl + "/api/1/PartnerPaymentMethodsDashBoard/PaymentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeDto[]>;
        }));
    }

    protected processPaymentTypes(response: HttpResponseBase): Observable<PaymentTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentTypeDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: PartnerPaymentMethodInputDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/PartnerPaymentMethodsDashBoard/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allByPartner(id: string | undefined, accept_Language: any | undefined): Observable<PartnerPaymentMethodDto[]> {
        let url_ = this.baseUrl + "/api/1/PartnerPaymentMethodsDashBoard/AllByPartner?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllByPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllByPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartnerPaymentMethodDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartnerPaymentMethodDto[]>;
        }));
    }

    protected processAllByPartner(response: HttpResponseBase): Observable<PartnerPaymentMethodDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartnerPaymentMethodDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param storeCategoryId (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPaginated(storeCategoryId: number | undefined, storeId: string | undefined, filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GetProductByIdDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Product/GetPaginated?";
        if (storeCategoryId === null)
            throw new Error("The parameter 'storeCategoryId' cannot be null.");
        else if (storeCategoryId !== undefined)
            url_ += "StoreCategoryId=" + encodeURIComponent("" + storeCategoryId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductByIdDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductByIdDtoPaginatedList>;
        }));
    }

    protected processGetPaginated(response: HttpResponseBase): Observable<GetProductByIdDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetProductByIdDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateProductDto | undefined): Observable<CreateProductResultDto[]> {
        let url_ = this.baseUrl + "/api/1/Product/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateProductResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateProductResultDto[]>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<CreateProductResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateProductResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Product/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorder(accept_Language: any | undefined, body: ReorderProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Product/reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: ProductActivateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Product/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    availableHours(productId: number | undefined, accept_Language: any | undefined): Observable<ProductAvailableHoursDto[]> {
        let url_ = this.baseUrl + "/api/1/Product/availableHours?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableHours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableHours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductAvailableHoursDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductAvailableHoursDto[]>;
        }));
    }

    protected processAvailableHours(response: HttpResponseBase): Observable<ProductAvailableHoursDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductAvailableHoursDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setAvailableHours(accept_Language: any | undefined, body: SetProductAvailableHoursDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Product/SetAvailableHours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAvailableHours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAvailableHours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAvailableHours(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    stores(productId: number | undefined, accept_Language: any | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/1/Product/stores?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processStores(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partner(accept_Language: any | undefined): Observable<GetProductByIdDto[]> {
        let url_ = this.baseUrl + "/api/1/Product/partner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductByIdDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductByIdDto[]>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<GetProductByIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetProductByIdDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param parnterId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerMenu(parnterId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Product/PartnerMenu?";
        if (parnterId === null)
            throw new Error("The parameter 'parnterId' cannot be null.");
        else if (parnterId !== undefined)
            url_ += "parnterId=" + encodeURIComponent("" + parnterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartnerMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductComponentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateProductComponentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ProductComponent/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateProductComponentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ProductComponent/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductMerchantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    activate(accept_Language: any | undefined, body: ProductActivateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/ProductMerchant/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SizeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<SizeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Size/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<SizeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateSizeDto | undefined): Observable<SizeDto> {
        let url_ = this.baseUrl + "/api/1/Size/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<SizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateSizeDto | undefined): Observable<SizeDto> {
        let url_ = this.baseUrl + "/api/1/Size/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SizeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Size/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sizeTypeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    partner(sizeTypeId: number | undefined, accept_Language: any | undefined): Observable<GetPartnerSizesListDto[]> {
        let url_ = this.baseUrl + "/api/1/Size/partner?";
        if (sizeTypeId === null)
            throw new Error("The parameter 'sizeTypeId' cannot be null.");
        else if (sizeTypeId !== undefined)
            url_ += "sizeTypeId=" + encodeURIComponent("" + sizeTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPartnerSizesListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPartnerSizesListDto[]>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<GetPartnerSizesListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPartnerSizesListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sizeReordering (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    reOrderinglist(sizeReordering: Int64ReOrderingDto[] | undefined, accept_Language: any | undefined): Observable<SizeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Size/ReOrderinglist?";
        if (sizeReordering === null)
            throw new Error("The parameter 'sizeReordering' cannot be null.");
        else if (sizeReordering !== undefined)
            sizeReordering && sizeReordering.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sizeReordering[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReOrderinglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReOrderinglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeDtoPaginatedList>;
        }));
    }

    protected processReOrderinglist(response: HttpResponseBase): Observable<SizeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SizeTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<SizeTypeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/SizeType/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<SizeTypeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateSizeTypeDto | undefined): Observable<SizeTypeDto> {
        let url_ = this.baseUrl + "/api/1/SizeType/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<SizeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateSizeTypeDto | undefined): Observable<SizeTypeDto> {
        let url_ = this.baseUrl + "/api/1/SizeType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SizeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SizeTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SizeType/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partner(accept_Language: any | undefined): Observable<GetPartnerSizeTypesListDto[]> {
        let url_ = this.baseUrl + "/api/1/SizeType/partner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPartnerSizeTypesListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPartnerSizeTypesListDto[]>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<GetPartnerSizeTypesListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPartnerSizeTypesListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SKUServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param isActive (optional) 
     * @param isDefault (optional) 
     * @param sKUDefaultImageId (optional) 
     * @param sizeId (optional) 
     * @param colorId (optional) 
     * @param productId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(code: string | undefined, isActive: boolean | undefined, isDefault: boolean | undefined, sKUDefaultImageId: string | undefined, sizeId: number | undefined, colorId: number | undefined, productId: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<SKUDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/SKU/All?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isDefault === null)
            throw new Error("The parameter 'isDefault' cannot be null.");
        else if (isDefault !== undefined)
            url_ += "IsDefault=" + encodeURIComponent("" + isDefault) + "&";
        if (sKUDefaultImageId === null)
            throw new Error("The parameter 'sKUDefaultImageId' cannot be null.");
        else if (sKUDefaultImageId !== undefined)
            url_ += "SKUDefaultImageId=" + encodeURIComponent("" + sKUDefaultImageId) + "&";
        if (sizeId === null)
            throw new Error("The parameter 'sizeId' cannot be null.");
        else if (sizeId !== undefined)
            url_ += "SizeId=" + encodeURIComponent("" + sizeId) + "&";
        if (colorId === null)
            throw new Error("The parameter 'colorId' cannot be null.");
        else if (colorId !== undefined)
            url_ += "ColorId=" + encodeURIComponent("" + colorId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SKUDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SKUDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<SKUDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SKUDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param code (optional) 
     * @param unitPrice (optional) 
     * @param isActive (optional) 
     * @param isDefault (optional) 
     * @param sizeId (optional) 
     * @param calorie (optional) 
     * @param productId (optional) 
     * @param images (optional) 
     * @param maxQty (optional) 
     * @param minQty (optional) 
     * @param stepCount (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, code: string | undefined, unitPrice: number | undefined, isActive: boolean | undefined, isDefault: boolean | undefined, sizeId: number | undefined, calorie: number | undefined, productId: number | undefined, images: CreateSKUImageDto[] | undefined, maxQty: number | undefined, minQty: number | undefined, stepCount: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (code === null || code === undefined)
            throw new Error("The parameter 'code' cannot be null.");
        else
            content_.append("Code", code.toString());
        if (unitPrice === null || unitPrice === undefined)
            throw new Error("The parameter 'unitPrice' cannot be null.");
        else
            content_.append("UnitPrice", unitPrice.toString());
        if (isActive === null || isActive === undefined)
            throw new Error("The parameter 'isActive' cannot be null.");
        else
            content_.append("IsActive", isActive.toString());
        if (isDefault === null || isDefault === undefined)
            throw new Error("The parameter 'isDefault' cannot be null.");
        else
            content_.append("IsDefault", isDefault.toString());
        if (sizeId === null || sizeId === undefined)
            throw new Error("The parameter 'sizeId' cannot be null.");
        else
            content_.append("SizeId", sizeId.toString());
        if (calorie === null || calorie === undefined)
            throw new Error("The parameter 'calorie' cannot be null.");
        else
            content_.append("Calorie", calorie.toString());
        if (productId === null || productId === undefined)
            throw new Error("The parameter 'productId' cannot be null.");
        else
            content_.append("ProductId", productId.toString());
        if (images === null || images === undefined)
            throw new Error("The parameter 'images' cannot be null.");
        else
            images.forEach(item_ => content_.append("Images", item_.toString()));
        if (maxQty === null || maxQty === undefined)
            throw new Error("The parameter 'maxQty' cannot be null.");
        else
            content_.append("MaxQty", maxQty.toString());
        if (minQty === null || minQty === undefined)
            throw new Error("The parameter 'minQty' cannot be null.");
        else
            content_.append("MinQty", minQty.toString());
        if (stepCount === null || stepCount === undefined)
            throw new Error("The parameter 'stepCount' cannot be null.");
        else
            content_.append("StepCount", stepCount.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    optionPost(accept_Language: any | undefined, body: CreateSkuOptionDto | undefined): Observable<CreateSkuOptionResultDto[]> {
        let url_ = this.baseUrl + "/api/1/SKU/option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateSkuOptionResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateSkuOptionResultDto[]>;
        }));
    }

    protected processOptionPost(response: HttpResponseBase): Observable<CreateSkuOptionResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateSkuOptionResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    optionPut(accept_Language: any | undefined, body: UpdateSkuOption | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    optionDelete(accept_Language: any | undefined, body: DeleteSkuOptionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateSKUDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    productAdditionalSKUs(productId: number, accept_Language: any | undefined): Observable<GetProductAdditionalSKUsListDto[]> {
        let url_ = this.baseUrl + "/api/1/SKU/ProductAdditionalSKUs/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductAdditionalSKUs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductAdditionalSKUs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductAdditionalSKUsListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductAdditionalSKUsListDto[]>;
        }));
    }

    protected processProductAdditionalSKUs(response: HttpResponseBase): Observable<GetProductAdditionalSKUsListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetProductAdditionalSKUsListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    optionGet(productId: number, accept_Language: any | undefined): Observable<GetProductSkuOptionsDto[]> {
        let url_ = this.baseUrl + "/api/1/SKU/option/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductSkuOptionsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductSkuOptionsDto[]>;
        }));
    }

    protected processOptionGet(response: HttpResponseBase): Observable<GetProductSkuOptionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetProductSkuOptionsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveAdditional(accept_Language: any | undefined, body: CreateAdditionalSkuDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/SaveAdditional";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAdditional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAdditional(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAdditional(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    editAdditional(accept_Language: any | undefined, body: UpdateAdditionalSkuDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/EditAdditional";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAdditional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAdditional(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditAdditional(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    store(storeId: string | undefined, accept_Language: any | undefined): Observable<GetStoreSKUsDto[]> {
        let url_ = this.baseUrl + "/api/1/SKU/Store?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreSKUsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreSKUsDto[]>;
        }));
    }

    protected processStore(response: HttpResponseBase): Observable<GetStoreSKUsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreSKUsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    partner(accept_Language: any | undefined): Observable<GetStoreSKUsDto[]> {
        let url_ = this.baseUrl + "/api/1/SKU/partner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreSKUsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreSKUsDto[]>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<GetStoreSKUsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreSKUsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    optionItemDelete(accept_Language: any | undefined, body: DeleteStoreOptionItem | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/optionItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionItemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionItemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionItemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    optionItemPost(accept_Language: any | undefined, body: CreateStoreOptionItemDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/optionItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionItemPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionItemPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionItemPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorder(accept_Language: any | undefined, body: ReorderSKUDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/reorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReorder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    optionOrder(accept_Language: any | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/SKU/OptionOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOptionOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param industryId (optional) 
     * @param storeId (optional) 
     * @param partnerId (optional) 
     * @param storeCategoryTypeId (optional) 
     * @param searchText (optional) 
     * @param isFavouriteOnly (optional) 
     * @param allPartnerStores (optional) 
     * @param deliveryFeesFrom (optional) 
     * @param deliveryFeesTo (optional) 
     * @param discountFrom (optional) 
     * @param discountTo (optional) 
     * @param catalogDiscountType (optional) 
     * @param cashbackValueFrom (optional) 
     * @param cashbackValueTo (optional) 
     * @param cashbackType (optional) 
     * @param sortingType (optional) 
     * @param sortAsc (optional) 
     * @param onlyStoresInRange (optional) 
     * @param f (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    location(industryId: number | undefined, storeId: string | undefined, partnerId: string | undefined, storeCategoryTypeId: number | undefined, userLocation_Latitude: number, userLocation_Longitude: number, searchText: string | undefined, isFavouriteOnly: boolean | undefined, allPartnerStores: boolean | undefined, deliveryFeesFrom: number | undefined, deliveryFeesTo: number | undefined, discountFrom: number | undefined, discountTo: number | undefined, catalogDiscountType: CatalogDiscountType | undefined, cashbackValueFrom: number | undefined, cashbackValueTo: number | undefined, cashbackType: CashbackType | undefined, sortingType: StoreSortingType | undefined, sortAsc: boolean | undefined, onlyStoresInRange: boolean | undefined, f: StoreFilterInput[] | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GetStoresOutputDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Store/location?";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeCategoryTypeId === null)
            throw new Error("The parameter 'storeCategoryTypeId' cannot be null.");
        else if (storeCategoryTypeId !== undefined)
            url_ += "StoreCategoryTypeId=" + encodeURIComponent("" + storeCategoryTypeId) + "&";
        if (userLocation_Latitude === undefined || userLocation_Latitude === null)
            throw new Error("The parameter 'userLocation_Latitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Latitude=" + encodeURIComponent("" + userLocation_Latitude) + "&";
        if (userLocation_Longitude === undefined || userLocation_Longitude === null)
            throw new Error("The parameter 'userLocation_Longitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Longitude=" + encodeURIComponent("" + userLocation_Longitude) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (isFavouriteOnly === null)
            throw new Error("The parameter 'isFavouriteOnly' cannot be null.");
        else if (isFavouriteOnly !== undefined)
            url_ += "IsFavouriteOnly=" + encodeURIComponent("" + isFavouriteOnly) + "&";
        if (allPartnerStores === null)
            throw new Error("The parameter 'allPartnerStores' cannot be null.");
        else if (allPartnerStores !== undefined)
            url_ += "AllPartnerStores=" + encodeURIComponent("" + allPartnerStores) + "&";
        if (deliveryFeesFrom === null)
            throw new Error("The parameter 'deliveryFeesFrom' cannot be null.");
        else if (deliveryFeesFrom !== undefined)
            url_ += "DeliveryFeesFrom=" + encodeURIComponent("" + deliveryFeesFrom) + "&";
        if (deliveryFeesTo === null)
            throw new Error("The parameter 'deliveryFeesTo' cannot be null.");
        else if (deliveryFeesTo !== undefined)
            url_ += "DeliveryFeesTo=" + encodeURIComponent("" + deliveryFeesTo) + "&";
        if (discountFrom === null)
            throw new Error("The parameter 'discountFrom' cannot be null.");
        else if (discountFrom !== undefined)
            url_ += "DiscountFrom=" + encodeURIComponent("" + discountFrom) + "&";
        if (discountTo === null)
            throw new Error("The parameter 'discountTo' cannot be null.");
        else if (discountTo !== undefined)
            url_ += "DiscountTo=" + encodeURIComponent("" + discountTo) + "&";
        if (catalogDiscountType === null)
            throw new Error("The parameter 'catalogDiscountType' cannot be null.");
        else if (catalogDiscountType !== undefined)
            url_ += "CatalogDiscountType=" + encodeURIComponent("" + catalogDiscountType) + "&";
        if (cashbackValueFrom === null)
            throw new Error("The parameter 'cashbackValueFrom' cannot be null.");
        else if (cashbackValueFrom !== undefined)
            url_ += "CashbackValueFrom=" + encodeURIComponent("" + cashbackValueFrom) + "&";
        if (cashbackValueTo === null)
            throw new Error("The parameter 'cashbackValueTo' cannot be null.");
        else if (cashbackValueTo !== undefined)
            url_ += "CashbackValueTo=" + encodeURIComponent("" + cashbackValueTo) + "&";
        if (cashbackType === null)
            throw new Error("The parameter 'cashbackType' cannot be null.");
        else if (cashbackType !== undefined)
            url_ += "CashbackType=" + encodeURIComponent("" + cashbackType) + "&";
        if (sortingType === null)
            throw new Error("The parameter 'sortingType' cannot be null.");
        else if (sortingType !== undefined)
            url_ += "SortingType=" + encodeURIComponent("" + sortingType) + "&";
        if (sortAsc === null)
            throw new Error("The parameter 'sortAsc' cannot be null.");
        else if (sortAsc !== undefined)
            url_ += "SortAsc=" + encodeURIComponent("" + sortAsc) + "&";
        if (onlyStoresInRange === null)
            throw new Error("The parameter 'onlyStoresInRange' cannot be null.");
        else if (onlyStoresInRange !== undefined)
            url_ += "OnlyStoresInRange=" + encodeURIComponent("" + onlyStoresInRange) + "&";
        if (f === null)
            throw new Error("The parameter 'f' cannot be null.");
        else if (f !== undefined)
            f && f.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "F[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoresOutputDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoresOutputDtoPaginatedList>;
        }));
    }

    protected processLocation(response: HttpResponseBase): Observable<GetStoresOutputDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoresOutputDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    deals(userLocation_Latitude: number, userLocation_Longitude: number, accept_Language: any | undefined): Observable<GetStoreDealsOutputDto[]> {
        let url_ = this.baseUrl + "/api/1/Store/deals?";
        if (userLocation_Latitude === undefined || userLocation_Latitude === null)
            throw new Error("The parameter 'userLocation_Latitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Latitude=" + encodeURIComponent("" + userLocation_Latitude) + "&";
        if (userLocation_Longitude === undefined || userLocation_Longitude === null)
            throw new Error("The parameter 'userLocation_Longitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Longitude=" + encodeURIComponent("" + userLocation_Longitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreDealsOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreDealsOutputDto[]>;
        }));
    }

    protected processDeals(response: HttpResponseBase): Observable<GetStoreDealsOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreDealsOutputDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    shifts(storeId: string, accept_Language: any | undefined): Observable<StoreWeeklyShiftDto[]> {
        let url_ = this.baseUrl + "/api/1/Store/{storeId}/shifts";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShifts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShifts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreWeeklyShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreWeeklyShiftDto[]>;
        }));
    }

    protected processShifts(response: HttpResponseBase): Observable<StoreWeeklyShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreWeeklyShiftDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    calculateFinalFare(accept_Language: any | undefined, body: CatalogDeliveryInputDto | undefined): Observable<CatalogDeliveryResultDto> {
        let url_ = this.baseUrl + "/api/1/Store/CalculateFinalFare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateFinalFare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateFinalFare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryResultDto>;
        }));
    }

    protected processCalculateFinalFare(response: HttpResponseBase): Observable<CatalogDeliveryResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    workingDays(accept_Language: any | undefined, body: SetStoreWorkingDaysDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Store/workingDays";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkingDays(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkingDays(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWorkingDays(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    availablePaymentTypes(partnerId: string | undefined, storeId: string | undefined, accept_Language: any | undefined): Observable<PaymentType[]> {
        let url_ = this.baseUrl + "/api/1/Store/AvailablePaymentTypes?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailablePaymentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailablePaymentTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentType[]>;
        }));
    }

    protected processAvailablePaymentTypes(response: HttpResponseBase): Observable<PaymentType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentType[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerId(partnerId: string | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Store/partnerId?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartnerId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    calculateNoUserLocationFarer(storeId: string | undefined, accept_Language: any | undefined): Observable<CatalogDeliveryResultDto> {
        let url_ = this.baseUrl + "/api/1/Store/CalculateNoUserLocationFarer?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateNoUserLocationFarer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateNoUserLocationFarer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogDeliveryResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogDeliveryResultDto>;
        }));
    }

    protected processCalculateNoUserLocationFarer(response: HttpResponseBase): Observable<CatalogDeliveryResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogDeliveryResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    products(storeId: string | undefined, accept_Language: any | undefined): Observable<GetStoreCategoryProductsListDto[]> {
        let url_ = this.baseUrl + "/api/1/Store/products?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreCategoryProductsListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreCategoryProductsListDto[]>;
        }));
    }

    protected processProducts(response: HttpResponseBase): Observable<GetStoreCategoryProductsListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreCategoryProductsListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    skus(productId: number | undefined, accept_Language: any | undefined): Observable<GetProductSkusDto[]> {
        let url_ = this.baseUrl + "/api/1/Store/skus?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductSkusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductSkusDto[]>;
        }));
    }

    protected processSkus(response: HttpResponseBase): Observable<GetProductSkusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetProductSkusDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    components(productId: number | undefined, accept_Language: any | undefined): Observable<GetProductComponentListDto> {
        let url_ = this.baseUrl + "/api/1/Store/components?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComponents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComponents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductComponentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductComponentListDto>;
        }));
    }

    protected processComponents(response: HttpResponseBase): Observable<GetProductComponentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetProductComponentListDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    busy(accept_Language: any | undefined, body: SetStoreBusyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Store/busy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBusy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBusy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBusy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param allPartnerStores (optional) 
     * @param industryId (optional) 
     * @param maxStoresCountInEachSection (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    horizenatalSections(userLocation_Latitude: number, userLocation_Longitude: number, allPartnerStores: boolean | undefined, industryId: number | undefined, maxStoresCountInEachSection: number | undefined, accept_Language: any | undefined): Observable<GetHorizenatalSectionResponseDto[]> {
        let url_ = this.baseUrl + "/api/1/Store/HorizenatalSections?";
        if (userLocation_Latitude === undefined || userLocation_Latitude === null)
            throw new Error("The parameter 'userLocation_Latitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Latitude=" + encodeURIComponent("" + userLocation_Latitude) + "&";
        if (userLocation_Longitude === undefined || userLocation_Longitude === null)
            throw new Error("The parameter 'userLocation_Longitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Longitude=" + encodeURIComponent("" + userLocation_Longitude) + "&";
        if (allPartnerStores === null)
            throw new Error("The parameter 'allPartnerStores' cannot be null.");
        else if (allPartnerStores !== undefined)
            url_ += "AllPartnerStores=" + encodeURIComponent("" + allPartnerStores) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (maxStoresCountInEachSection === null)
            throw new Error("The parameter 'maxStoresCountInEachSection' cannot be null.");
        else if (maxStoresCountInEachSection !== undefined)
            url_ += "MaxStoresCountInEachSection=" + encodeURIComponent("" + maxStoresCountInEachSection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHorizenatalSections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHorizenatalSections(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHorizenatalSectionResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHorizenatalSectionResponseDto[]>;
        }));
    }

    protected processHorizenatalSections(response: HttpResponseBase): Observable<GetHorizenatalSectionResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetHorizenatalSectionResponseDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param allPartnerStores (optional) 
     * @param industryId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    horizenatalSection(id: string | undefined, userLocation_Latitude: number, userLocation_Longitude: number, allPartnerStores: boolean | undefined, industryId: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GetStoresOutputDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Store/HorizenatalSection?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (userLocation_Latitude === undefined || userLocation_Latitude === null)
            throw new Error("The parameter 'userLocation_Latitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Latitude=" + encodeURIComponent("" + userLocation_Latitude) + "&";
        if (userLocation_Longitude === undefined || userLocation_Longitude === null)
            throw new Error("The parameter 'userLocation_Longitude' must be defined and cannot be null.");
        else
            url_ += "UserLocation.Longitude=" + encodeURIComponent("" + userLocation_Longitude) + "&";
        if (allPartnerStores === null)
            throw new Error("The parameter 'allPartnerStores' cannot be null.");
        else if (allPartnerStores !== undefined)
            url_ += "AllPartnerStores=" + encodeURIComponent("" + allPartnerStores) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHorizenatalSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHorizenatalSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoresOutputDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoresOutputDtoPaginatedList>;
        }));
    }

    protected processHorizenatalSection(response: HttpResponseBase): Observable<GetStoresOutputDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoresOutputDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeDetails(storeId: string | undefined, accept_Language: any | undefined): Observable<StoreDto> {
        let url_ = this.baseUrl + "/api/1/Store/StoreDetails?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto>;
        }));
    }

    protected processStoreDetails(response: HttpResponseBase): Observable<StoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SkuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skuId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    options(skuId: number | undefined, accept_Language: any | undefined): Observable<GetSkuOptionDto[]> {
        let url_ = this.baseUrl + "/api/1/Store/sku/options?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSkuOptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSkuOptionDto[]>;
        }));
    }

    protected processOptions(response: HttpResponseBase): Observable<GetSkuOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetSkuOptionDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isActive (optional) 
     * @param parentStoreCategoryId (optional) 
     * @param storeId (optional) 
     * @param storeCategoryTypeId (optional) 
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getPaginated(isActive: boolean | undefined, parentStoreCategoryId: number | undefined, storeId: string | undefined, storeCategoryTypeId: number | undefined, filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<StoreCategoryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/GetPaginated?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (parentStoreCategoryId === null)
            throw new Error("The parameter 'parentStoreCategoryId' cannot be null.");
        else if (parentStoreCategoryId !== undefined)
            url_ += "ParentStoreCategoryId=" + encodeURIComponent("" + parentStoreCategoryId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (storeCategoryTypeId === null)
            throw new Error("The parameter 'storeCategoryTypeId' cannot be null.");
        else if (storeCategoryTypeId !== undefined)
            url_ += "StoreCategoryTypeId=" + encodeURIComponent("" + storeCategoryTypeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryDtoPaginatedList>;
        }));
    }

    protected processGetPaginated(response: HttpResponseBase): Observable<StoreCategoryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param parentStoreCategoryId (optional) 
     * @param storeId (optional) 
     * @param storeCategoryTypeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getAll(isActive: boolean | undefined, parentStoreCategoryId: number | undefined, storeId: string | undefined, storeCategoryTypeId: number | undefined, accept_Language: any | undefined): Observable<StoreCategoryDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/GetAll?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (parentStoreCategoryId === null)
            throw new Error("The parameter 'parentStoreCategoryId' cannot be null.");
        else if (parentStoreCategoryId !== undefined)
            url_ += "ParentStoreCategoryId=" + encodeURIComponent("" + parentStoreCategoryId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (storeCategoryTypeId === null)
            throw new Error("The parameter 'storeCategoryTypeId' cannot be null.");
        else if (storeCategoryTypeId !== undefined)
            url_ += "StoreCategoryTypeId=" + encodeURIComponent("" + storeCategoryTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StoreCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderingList (optional) 
     * @param storeIds (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    reOrderinglist(orderingList: Int64ReOrderingDto[] | undefined, storeIds: string[] | undefined, accept_Language: any | undefined): Observable<StoreCategoryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/ReOrderinglist?";
        if (orderingList === null)
            throw new Error("The parameter 'orderingList' cannot be null.");
        else if (orderingList !== undefined)
            orderingList && orderingList.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "orderingList[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReOrderinglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReOrderinglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryDtoPaginatedList>;
        }));
    }

    protected processReOrderinglist(response: HttpResponseBase): Observable<StoreCategoryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getAllParentCategory(storeId: string | undefined, accept_Language: any | undefined): Observable<StoreCategoryDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/GetAllParentCategory?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllParentCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllParentCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryDto[]>;
        }));
    }

    protected processGetAllParentCategory(response: HttpResponseBase): Observable<StoreCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    get(id: number, accept_Language: any | undefined): Observable<StoreCategoryDto> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StoreCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateStoreCategoryDto | undefined): Observable<CreateStoreCategoryResultDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateStoreCategoryResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateStoreCategoryResultDto[]>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<CreateStoreCategoryResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateStoreCategoryResultDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateStoreCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    active(id: number | undefined, accept_Language: any | undefined, body: string[] | undefined): Observable<StoreCategoryDto> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/Active?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryDto>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<StoreCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storecategoryId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    availableHours(storecategoryId: number | undefined, accept_Language: any | undefined): Observable<StoreCategoryAvailableHoursDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/availableHours?";
        if (storecategoryId === null)
            throw new Error("The parameter 'storecategoryId' cannot be null.");
        else if (storecategoryId !== undefined)
            url_ += "storecategoryId=" + encodeURIComponent("" + storecategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableHours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableHours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryAvailableHoursDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryAvailableHoursDto[]>;
        }));
    }

    protected processAvailableHours(response: HttpResponseBase): Observable<StoreCategoryAvailableHoursDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryAvailableHoursDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setAvailableHours(accept_Language: any | undefined, body: SetStoreCategoryAvailableHoursDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/SetAvailableHours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAvailableHours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAvailableHours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAvailableHours(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(id: number | undefined, accept_Language: any | undefined, body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    categoryList(storeId: string | undefined, accept_Language: any | undefined): Observable<GetCatgoryListDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/CategoryList?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCatgoryListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCatgoryListDto[]>;
        }));
    }

    protected processCategoryList(response: HttpResponseBase): Observable<GetCatgoryListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetCatgoryListDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeCategoryCode (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    stores(storeCategoryCode: string | undefined, accept_Language: any | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategory/stores?";
        if (storeCategoryCode === null)
            throw new Error("The parameter 'storeCategoryCode' cannot be null.");
        else if (storeCategoryCode !== undefined)
            url_ += "StoreCategoryCode=" + encodeURIComponent("" + storeCategoryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processStores(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreCategoryTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param industryId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, industryId: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<StoreCategoryTypeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<StoreCategoryTypeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    allByIndustries(accept_Language: any | undefined): Observable<StoreCategoryTypeDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/AllByIndustries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllByIndustries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllByIndustries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDto[]>;
        }));
    }

    protected processAllByIndustries(response: HttpResponseBase): Observable<StoreCategoryTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param industryId (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    allActive(filter: string | undefined, industryId: number | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<StoreCategoryTypeActiveDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/AllActive?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeActiveDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeActiveDtoPaginatedList>;
        }));
    }

    protected processAllActive(response: HttpResponseBase): Observable<StoreCategoryTypeActiveDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeActiveDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isMain (optional) 
     * @param isActive (optional) 
     * @param industryId (optional) 
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    getAll(isMain: boolean | undefined, isActive: boolean | undefined, industryId: number | undefined, partnerId: string | undefined, accept_Language: any | undefined): Observable<StoreCategoryTypeDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/GetAll?";
        if (isMain === null)
            throw new Error("The parameter 'isMain' cannot be null.");
        else if (isMain !== undefined)
            url_ += "IsMain=" + encodeURIComponent("" + isMain) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "PartnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<StoreCategoryTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateStoreCategoryTypeDto | undefined): Observable<StoreCategoryTypeDto> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<StoreCategoryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateStoreCategoryTypeDto | undefined): Observable<StoreCategoryTypeDto> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StoreCategoryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    uploadImage(accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param industryId (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    reOrderinglist(industryId: number | undefined, accept_Language: any | undefined, body: Int64ReOrderingDto[] | undefined): Observable<StoreCategoryTypeDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/ReOrderinglist?";
        if (industryId === null)
            throw new Error("The parameter 'industryId' cannot be null.");
        else if (industryId !== undefined)
            url_ += "IndustryId=" + encodeURIComponent("" + industryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReOrderinglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReOrderinglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryTypeDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryTypeDtoPaginatedList>;
        }));
    }

    protected processReOrderinglist(response: HttpResponseBase): Observable<StoreCategoryTypeDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryTypeDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerID (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    savePartnerStoreCategoryType(partnerID: string | undefined, accept_Language: any | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreCategoryType/SavePartnerStoreCategoryType?";
        if (partnerID === null)
            throw new Error("The parameter 'partnerID' cannot be null.");
        else if (partnerID !== undefined)
            url_ += "partnerID=" + encodeURIComponent("" + partnerID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePartnerStoreCategoryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePartnerStoreCategoryType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePartnerStoreCategoryType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateCreate(accept_Language: any | undefined, body: CreateStoreDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/ValidateCreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    validateUpdate(accept_Language: any | undefined, body: UpdateStoreDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/ValidateUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(accept_Language: any | undefined, body: CreateStoreDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateStoreDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    delete(id: string | undefined, accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param isActive (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    activate(id: string | undefined, isActive: boolean | undefined, accept_Language: any | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/Activate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    setBusy(accept_Language: any | undefined, body: SetStoreBusyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/SetBusy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetBusy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetBusy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetBusy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    partnerStores(partnerId: string | undefined, accept_Language: any | undefined): Observable<StoreDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/PartnerStores?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto[]>;
        }));
    }

    protected processPartnerStores(response: HttpResponseBase): Observable<StoreDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    storeDetails(storeId: string | undefined, accept_Language: any | undefined): Observable<StoreDto> {
        let url_ = this.baseUrl + "/api/1/StoreDashboard/StoreDetails?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreDto>;
        }));
    }

    protected processStoreDetails(response: HttpResponseBase): Observable<StoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreDeliveryTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param partnerId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    parnter(partnerId: string | undefined, accept_Language: any | undefined): Observable<GetPartnerStoreDeliveryTypeDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreDeliveryType/parnter?";
        if (partnerId === null)
            throw new Error("The parameter 'partnerId' cannot be null.");
        else if (partnerId !== undefined)
            url_ += "partnerId=" + encodeURIComponent("" + partnerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParnter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParnter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPartnerStoreDeliveryTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPartnerStoreDeliveryTypeDto[]>;
        }));
    }

    protected processParnter(response: HttpResponseBase): Observable<GetPartnerStoreDeliveryTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPartnerStoreDeliveryTypeDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    partner(accept_Language: any | undefined, body: SetParnterStoreDeliveryTypeDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreDeliveryType/partner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPartner(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    remove(accept_Language: any | undefined, body: RemoveParnterStoreDeliveryTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreDeliveryType/remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreMerchantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    products(storeId: string | undefined, accept_Language: any | undefined): Observable<StoreCategoryProductsListTotalMangedDto> {
        let url_ = this.baseUrl + "/api/1/StoreMerchant/products?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCategoryProductsListTotalMangedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCategoryProductsListTotalMangedDto>;
        }));
    }

    protected processProducts(response: HttpResponseBase): Observable<StoreCategoryProductsListTotalMangedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreCategoryProductsListTotalMangedDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    testAbortConnection(accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/StoreMerchant/test-abort-connection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestAbortConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestAbortConnection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestAbortConnection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreWorkingDayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param storeId (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    statistics(storeId: string | undefined, accept_Language: any | undefined): Observable<GetStoreWorkingDaysWithStatisticsDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreWorkingDay/Statistics?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreWorkingDaysWithStatisticsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreWorkingDaysWithStatisticsDto[]>;
        }));
    }

    protected processStatistics(response: HttpResponseBase): Observable<GetStoreWorkingDaysWithStatisticsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetStoreWorkingDaysWithStatisticsDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    main(accept_Language: any | undefined): Observable<StoreWorkingDaysDto[]> {
        let url_ = this.baseUrl + "/api/1/StoreWorkingDay/main";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreWorkingDaysDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreWorkingDaysDto[]>;
        }));
    }

    protected processMain(response: HttpResponseBase): Observable<StoreWorkingDaysDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StoreWorkingDaysDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param isActive (optional) 
     * @param orderType (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, isActive: boolean | undefined, orderType: OrderType | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<GetSubCategoryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/SubCategory/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (orderType === null)
            throw new Error("The parameter 'orderType' cannot be null.");
        else if (orderType !== undefined)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSubCategoryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSubCategoryDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<GetSubCategoryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetSubCategoryDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorting (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    all(filter: string | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorting: string | undefined, accept_Language: any | undefined): Observable<TagDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/1/Tag/All?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDtoPaginatedList>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<TagDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TagDtoPaginatedList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    save(accept_Language: any | undefined, body: CreateTagDto | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/1/Tag/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TagDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(accept_Language: any | undefined, body: UpdateTagDto | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/1/Tag/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TagDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param accept_Language (optional) 
     * @return Success
     */
    id(id: number | undefined, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/Tag/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    product(productId: number, accept_Language: any | undefined): Observable<ProductTagDto[]> {
        let url_ = this.baseUrl + "/api/1/Tag/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTagDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTagDto[]>;
        }));
    }

    protected processProduct(response: HttpResponseBase): Observable<ProductTagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductTagDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserFavoriteStoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) 
     * @return Success
     */
    deleteByStoreId(storeId: string, accept_Language: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/1/UserFavoriteStore/DeleteByStoreId/{storeId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteByStoreId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteByStoreId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ActivateBannerAdDto {
    id: string;
    isActive: boolean;
}

export interface ActivateDiscountDto {
    id: string;
    to: string | undefined;
    timeZone: number | undefined;
    isActive: boolean;
}

export interface ActivateHorizontalBarDto {
    id: string;
    isActive: boolean;
}

export interface ActivatePartnerAdDto {
    id: number;
    isActive: boolean;
}

export interface ActiveBrandDto {
    id: string;
    name: LocalizedFieldDto;
    imageUrl: LocalizedFieldDto;
}

export interface ActiveBrandDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ActiveBrandDto[] | undefined;
}

export interface AddCartItemDto {
    storeId: string;
    skuId: number;
    quantity: number;
    itemDetail: string;
}

export interface AddCartItemDtoV2 {
    orderType: OrderType;
    storeId: string | undefined;
    skuId: number | undefined;
    itemId: string | undefined;
    itemName: string | undefined;
    quantity: number;
    itemDetail: string;
}

export interface AddCartItemResultDto {
    cartId: string;
    cartItemId: string;
}

export interface Address {
    fullAddress: string | undefined;
    levels: string[] | undefined;
}

export enum AdsStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface AttachmentCreateDto {
    attachmentName: string | undefined;
    attachmentContent: string | undefined;
}

export interface AvailableHourDto {
    day: DayOfWeek;
    from: string | undefined;
    to: string | undefined;
    allTime: boolean;
    createdAt: string | undefined;
    updatedAt: string | undefined;
}

export enum BannerAdClickActions {
    _1 = 1,
}

export enum BannerAdPlacements {
    _1 = 1,
    _2 = 2,
}

export enum BannerAdTypes {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface BrandDto {
    id: string;
    name: LocalizedFieldDto;
    imageUrl: LocalizedFieldDto;
    isActive: boolean;
    ordering: number;
    orderType: OrderType;
}

export interface BrandDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: BrandDto[] | undefined;
}

export interface CartDto {
    id: string;
    price: number;
    code: string | undefined;
    status: CartStatus;
    orderId: string | undefined;
    parentCartId: string | undefined;
    storeId: string | undefined;
    storeName: LocalizedFieldDto;
    itemsCount: number;
    storeIsBusy: boolean;
    storeIsAvailable: boolean;
    hasProblem: boolean;
    storeLogoUrl: string | undefined;
    storeDescription: LocalizedFieldDto;
    orderType: OrderType;
}

export interface CartDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CartDto[] | undefined;
}

export interface CartExtraItem {
    additions: CartItemComponent[] | undefined;
    removes: CartItemComponent[] | undefined;
    optionItems: CartItemComponent[] | undefined;
}

export interface CartItemComponent {
    id: number;
    nameLocalized: LocalizedFieldDto;
    price: number;
}

export interface CartItemDto {
    id: string;
    cartId: string;
    skuId: number | undefined;
    quantity: number;
    itemDetail: string | undefined;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    size: LocalizedFieldDto;
    isSKUActive: boolean;
    isItemActive: boolean;
    isProductActive: boolean;
    isProductAvailable: boolean;
    productId: number;
    priceBeforeDiscount: number;
    priceAfterDiscount: number;
    priceBeforeDiscountWithExtra: number;
    priceAfterDiscountWithExtra: number;
    productImageUrl: string | undefined;
    hasDiscount: boolean;
    notes: string | undefined;
    price: number | undefined;
    extra: CartExtraItem;
    categoryId: number;
    itemId: string | undefined;
}

export enum CartStatus {
    _1 = 1,
    _2 = 2,
}

export enum CashbackType {
    _1 = 1,
    _2 = 2,
}

export interface CatalogDeliveryInputDto {
    partnerId: string;
    storeId: string | undefined;
    userLocation: LocationDto;
    storeLocation: LocationDto;
    orderPrice: number | undefined;
    deliveryDate: moment.Moment | undefined;
    hasFixedDistance: boolean;
    distanceFromDb: number;
}

export interface CatalogDeliveryResultDto {
    deliveryFare: number;
    distanceByKm: number;
    partnerDebitFare: number;
    isOutOfRange: boolean;
    catalogOffersNotifications: string[] | undefined;
    availablePaymentTypes: PaymentType[] | undefined;
    originalDeliveryFare: number;
    selectedCustomFare: DeliveryZoneCustomDto;
}

export interface CatalogDeliveryZoneActivateInputDto {
    id: string;
    isActivate: boolean;
}

export interface CatalogDeliveryZoneDto {
    id: string;
    deliveryZoneId: number;
    userId: string;
    fixedFare: number;
    isIntegrationFare: boolean;
    isActive: boolean;
    deliveryZone: DeliveryZoneDto;
}

export interface CatalogDeliveryZoneFullDto {
    id: string;
    deliveryZoneId: number;
    deliveryZoneName: string | undefined;
    minimumDistance: number;
    maximumDistance: number;
    userId: string;
    fixedFare: number;
    isIntegrationFare: boolean;
    isActive: boolean;
}

export interface CatalogDiscountDto {
    id: string;
    level: string | undefined;
    type: string | undefined;
    value: number;
    isActive: boolean;
    rowId: string | undefined;
    rowName: string | undefined;
    to: string | undefined;
    from: string | undefined;
    partnerId: string;
    timeZone: number | undefined;
    limitations: CatalogDiscountLimitationDto[] | undefined;
}

export interface CatalogDiscountDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CatalogDiscountDto[] | undefined;
}

export enum CatalogDiscountLevel {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export interface CatalogDiscountLimitationDto {
    type: CatalogDiscountLimitationType;
    value: number;
}

export enum CatalogDiscountLimitationType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CatalogDiscountType {
    _1 = 1,
    _2 = 2,
}

export interface CatalogOrderItem {
    productId: number;
    quantity: number;
    skuId: number;
    options: CatalogOrderItemOption[] | undefined;
}

export interface CatalogOrderItemOption {
    id: number;
    itemId: number;
    quantity: number;
}

export interface CategoryResponseDto {
    categoryId: number;
    categoryName: LocalizedFieldDto;
    createdAt: string | undefined;
    updatedAt: string | undefined;
    storeCategoryTypeId: number;
}

export interface CompleteDto {
    id: string;
    orderId: string;
}

export interface ComponentDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    name: string | undefined;
    price: number;
    partnerId: string | undefined;
}

export interface ComponentDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ComponentDto[] | undefined;
}

export interface CreateAdditionalSkuDto {
    code: string;
    unitPrice: number;
    isActive: boolean;
    sizeId: number;
    calorie: number | undefined;
    productId: number;
    storeIds: string[] | undefined;
    storeId: string | undefined;
    ordering: number | undefined;
    maxQty: number;
    minQty: number;
    stepCount: number;
}

export interface CreateBannerAdDto {
    type: BannerAdTypes;
    partnerId: string;
    from: string;
    to: string;
    timeZone: number;
    name: LocalizedFieldDto;
    image: LocalizedFieldDto;
    clickAction: BannerAdClickActions;
    cost: number;
    industries: number[];
    bannerAdPlacments: BannerAdPlacements[];
}

export interface CreateBrandDto {
    name: LocalizedFieldDto;
    imageUrl: LocalizedFieldDto;
    orderType: OrderType;
    isActive: boolean;
}

export interface CreateComponentDto {
    nameAr: string;
    nameEn: string;
    price: number;
    partnerId: string | undefined;
}

export interface CreateCuisineDto {
    isActive: boolean;
    nameAr: string;
    descriptionAr: string;
    nameEn: string;
    descriptionEn: string;
    imageUrl: string;
}

export interface CreateDealsDto {
    type: DealType;
    image: LocalizedField;
    minValue: number;
    maxValue: number;
    isActive: boolean;
    color: string | undefined;
    discountType: CatalogDiscountType;
    name: LocalizedFieldDto;
}

export interface CreateDiscountDto {
    level: CatalogDiscountLevel;
    type: CatalogDiscountType;
    value: number;
    rowId: string;
    rowName: string;
    limitations: CreateDiscountLimitationDto[] | undefined;
}

export interface CreateDiscountLimitationDto {
    type: CatalogDiscountLimitationType;
    value: number;
}

export interface CreateHorizontalBarDto {
    name: LocalizedFieldDto;
    countOfSepCells: number;
    template: number;
    content: HorizntalBarContent;
    partners: string[] | undefined;
    bannerImageUrl: LocalizedFieldDto;
}

export interface CreateIndustryDto {
    name: LocalizedFieldDto;
    image: LocalizedFieldDto;
    isService: boolean;
    color: string;
    isActive: boolean;
    orderType: OrderType;
}

export interface CreateItemDto {
    name: LocalizedFieldDto;
    image: string | undefined;
    attachedFiles: AttachmentCreateDto[] | undefined;
    unitOfMeasure: UnitOfMeasure;
    isActive: boolean;
    subCategoryId: number;
    brandId: string | undefined;
}

export interface CreateMobileMenuDto {
    type: MobileMenuType;
    level: number;
    ordering: number;
    rowId: string;
    isActive: boolean;
}

export interface CreatePartnerAdDto {
    partnerId: string;
    from: string;
    to: string;
    timeZone: number;
    amount: number;
}

export interface CreateProductComponentDto {
    productId: number;
    componentId: number;
    isDefault: boolean;
    maxCount: number;
    storeIds: string[] | undefined;
    storeId: string;
}

export interface CreateProductDto {
    code: string;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    isActive: boolean;
    storeCategoryId: number;
    cuisineId: number | undefined;
    maxComponentCount: number;
    minComponentCount: number;
    storeIds: string[] | undefined;
    defaultSku: CreateSKUDto;
    storeId: string | undefined;
    tagIds: number[] | undefined;
    sizeTypeId: number | undefined;
    productType: ProductType;
    ordering: number | undefined;
}

export interface CreateProductResultDto {
    productId: number;
    skuId: number;
    storeId: string;
}

export interface CreateSKUDto {
    code: string | undefined;
    unitPrice: number;
    isActive: boolean;
    isDefault: boolean;
    sizeId: number;
    calorie: number | undefined;
    productId: number;
    images: CreateSKUImageDto[] | undefined;
    maxQty: number;
    minQty: number;
    stepCount: number;
}

export interface CreateSKUImageDto {
    attachment: AttachmentCreateDto;
    isDefault: boolean;
}

export interface CreateSizeDto {
    isActive: boolean;
    nameAr: string;
    nameEn: string;
    partnerId: string | undefined;
    sizeTypeId: number | undefined;
}

export interface CreateSizeTypeDto {
    isActive: boolean;
    nameAr: string;
    nameEn: string;
    partnerId: string | undefined;
}

export interface CreateSkuOptionDto {
    storeId: string | undefined;
    storeIds: string[] | undefined;
    name: LocalizedFieldDto;
    skuId: number;
    ordering: number | undefined;
    skuCode: string | undefined;
    minSelection: number;
    maxSelection: number;
}

export interface CreateSkuOptionResultDto {
    id: number;
    storeId: string | undefined;
}

export interface CreateStoreCategoryDto {
    isActive: boolean;
    parentStoreCategoryId: number | undefined;
    storeId: string | undefined;
    code: string;
    storeCategoryTypeId: number;
    imageUrl: string;
    descriptionAr: string;
    descriptionEn: string;
    nameAr: string;
    nameEn: string;
    storeIds: string[] | undefined;
}

export interface CreateStoreCategoryResultDto {
    id: number;
    storeId: string;
}

export interface CreateStoreCategoryTypeDto {
    isActive: boolean;
    industryId: number;
    imageUrl: string | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isMain: boolean;
    ordering: number;
}

export interface CreateStoreDto {
    id: string | undefined;
    description: LocalizedFieldDto;
    name: LocalizedFieldDto;
    commercialRegistration: string | undefined;
    storeLogoName: string | undefined;
    storeLogoContent: string | undefined;
    storeLogoUrl: string | undefined;
    commercialRegPhotoName: string | undefined;
    commercialRegPhotoContent: string | undefined;
    commercialRegistrationPhotoUrl: string | undefined;
    twitterAccount: string | undefined;
    instagramAccount: string | undefined;
    youtubeAccount: string | undefined;
    facebookAccount: string | undefined;
    snapchatAccount: string | undefined;
    partnerId: string | undefined;
    isAvailable: boolean;
    isActivated: boolean;
    hotline: string | undefined;
    maxEstimationDeliveryTime: number;
    isMainStore: boolean;
    location: LocationDto;
    workingDays: StoreWorkingDaysDto[] | undefined;
    storeCoverImageName: string | undefined;
    storeCoverImageContent: string | undefined;
    storeCoverImageUrl: string | undefined;
    sessionUserId: string | undefined;
    minimumCharge: number | undefined;
    code: string | undefined;
    address: LocalizedAddressDto;
}

export interface CreateStoreOptionItemDto {
    storeId: string | undefined;
    storeIds: string[] | undefined;
    optionId: number;
    skuId: number;
    price: number;
    defaultSelected: boolean;
}

export interface CreateStoreOptionItemResultDto {
    id: number;
    storeId: string | undefined;
}

export interface CreateSubCategoryDto {
    nameAr: string;
    nameEn: string;
    ordering: number;
    orderType: OrderType;
    isActive: boolean;
    imageUrl: string | undefined;
    parentSubCategoryId: number | undefined;
}

export interface CreateTagDto {
    isActive: boolean;
    nameAr: string;
    nameEn: string;
}

export interface CreateUserFavoriteStoreDto {
    userId: string | undefined;
    storeId: string;
}

export interface CuisineDto {
    id: number;
    nameEn: string | undefined;
    nameAr: string | undefined;
    descriptionEn: string | undefined;
    descriptionAr: string | undefined;
    isActive: boolean;
    imageUrl: string | undefined;
}

export interface CuisineDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: CuisineDto[] | undefined;
}

export interface CuisineSelectListDto {
    id: number;
    name: string | undefined;
}

export enum DayOfWeek {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum DealType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface DealsDto {
    id: string;
    type: DealType;
    image: LocalizedField;
    minValue: number;
    maxValue: number;
    isActive: boolean;
    color: string | undefined;
    typeName: string | undefined;
    ordering: number;
    discountType: CatalogDiscountType;
    name: LocalizedFieldDto;
}

export interface DealsDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: DealsDto[] | undefined;
}

export interface DeleteProductComponentDto {
    productCode: string | undefined;
    componentId: number;
    storeId: string;
    storeIds: string[] | undefined;
}

export interface DeleteProductDto {
    id: number;
    all: boolean;
    storeIds: string[] | undefined;
}

export interface DeleteSkuOptionDto {
    storeId: string | undefined;
    storeIds: string[] | undefined;
    name: LocalizedFieldDto;
    id: number;
}

export interface DeleteStoreOptionItem {
    id: number;
    skuId: number;
    storeId: string | undefined;
    storeIds: string[] | undefined;
}

export interface DeliveryDistanceFareActivateInputDto {
    id: string;
    isActivate: boolean;
}

export interface DeliveryDistanceFareDto {
    id: string;
    userId: string;
    minimumDistance: number;
    minimumDistanceFees: number;
    extraDistance: number;
    extraDistanceFees: number;
    isIntegrationFare: boolean;
    isActive: boolean;
}

export interface DeliveryDistanceFareFullDto {
    id: string;
    userId: string;
    minimumDistance: number;
    minimumDistanceFees: number;
    extraDistance: number;
    extraDistanceFees: number;
    isIntegrationFare: boolean;
    isActive: boolean;
}

export enum DeliveryType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export interface DeliveryZoneCustomActivateDto {
    id: string;
    isActive: boolean;
}

export interface DeliveryZoneCustomCreateInputDto {
    catalogDeliveryZoneId: string;
    startDate: string | undefined;
    endDate: string | undefined;
    fixedFare: number;
    partnerFixedDebit: number;
    priceGreaterThan: number | undefined;
    isActive: boolean;
}

export interface DeliveryZoneCustomDto {
    id: string;
    catalogDeliveryZoneId: string;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    fixedFare: number;
    partnerFixedDebit: number;
    priceGreaterThan: number | undefined;
    isActive: boolean;
}

export interface DeliveryZoneCustomFullDto {
    id: string;
    catalogDeliveryZoneId: string;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    fixedFare: number;
    partnerFixedDebit: number;
    priceGreaterThan: number | undefined;
    isIntegrationFare: boolean;
    userId: string;
    isActive: boolean;
    zoneName: string | undefined;
}

export interface DeliveryZoneCustomUpdateInputDto {
    id: string;
    catalogDeliveryZoneId: string;
    startDate: string | undefined;
    endDate: string | undefined;
    fixedFare: number;
    partnerFixedDebit: number;
    priceGreaterThan: number | undefined;
    isActive: boolean;
}

export interface DeliveryZoneDto {
    id: number;
    name: string | undefined;
    minimumDistance: number;
    maximumDistance: number;
}

export interface DeliveryZoneFullDto {
    id: number;
    name: string | undefined;
    minimumDistance: number;
    maximumDistance: number;
}

export interface DiscountDto {
    type: CatalogDiscountType;
    value: number;
    isActive: boolean;
    duration: DiscountDurationDto;
}

export interface DiscountDurationDto {
    to: string | undefined;
    from: string | undefined;
    timeZone: number;
}

export interface EditPartnerAdDto {
    id: number;
    partnerId: string;
    from: string;
    to: string;
    timeZone: number;
    amount: number;
}

export interface GetBannerAdOutputDto {
    id: string;
    type: BannerAdTypes;
    partnerId: string;
    from: string | undefined;
    to: string | undefined;
    timeZone: number;
    name: LocalizedFieldDto;
    image: LocalizedFieldDto;
    cost: number;
    isActive: boolean;
    clickAction: BannerAdClickActions;
}

export interface GetBannerAdOutputDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetBannerAdOutputDto[] | undefined;
}

export interface GetCategoryProductsListDto {
    categoryTypeId: number;
    productId: number;
    name: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    calorie: number | undefined;
    maxComponentCount: number;
    minComponentCount: number;
    price: number;
    isAvailable: boolean;
    nameLocalized: LocalizedFieldDto;
    hasDiscount: boolean;
    priceAfterDiscount: number;
}

export interface GetCategoryProductsListMangedDto {
    productId: number;
    name: string | undefined;
    imageUrl: string | undefined;
    description: string | undefined;
    calorie: number | undefined;
    price: number;
    isActive: boolean;
    nameLocalized: LocalizedFieldDto;
}

export interface GetCatgoryListDto {
    storeCategoryId: number;
    name: string | undefined;
    localizedName: LocalizedFieldDto;
}

export interface GetComponentsForProduct {
    id: number;
    componentId: number;
    isDefault: boolean;
    maxCount: number;
    componentName: string | undefined;
    price: number;
}

export interface GetDealStoresCountResult {
    storesCount: number;
    partnersCount: number;
}

export interface GetHorizenatalSectionResponseDto {
    id: string;
    sectionName: LocalizedFieldDto;
    template: number;
    countOfSepCells: number;
    bannerImage: LocalizedFieldDto;
    ordering: number;
    totalCount: number;
    stores: GetStoresOutputDto[] | undefined;
}

export interface GetHorizntalBarOutputDto {
    id: string;
    name: LocalizedFieldDto;
    countOfSepCells: number;
    ordering: number;
    type: HorizntalBarType;
    isActive: boolean;
    template: number;
    content: HorizntalBarContent;
    partners: string[] | undefined;
    bannerImageUrl: LocalizedFieldDto;
}

export interface GetHorizntalBarOutputDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetHorizntalBarOutputDto[] | undefined;
}

export interface GetIntegrationOptionDto {
    optionId: number;
    name: LocalizedFieldDto;
    minSelection: number;
    maxSelection: number;
    createdAt: string | undefined;
    updatedAt: string | undefined;
}

export interface GetIntegrationProductSkusDto {
    calorie: number | undefined;
    price: number;
    hasDiscount: boolean;
    priceAfterDiscount: number;
    size: IntegrationSizeDto;
    skuId: number;
    isDefault: boolean;
    name: LocalizedFieldDto;
    order: number | undefined;
    imageUrl: string | undefined;
    maxQty: number;
    minQty: number;
    stepCount: number;
    createdAt: string | undefined;
    updatedAt: string | undefined;
    optionList: GetIntegrationSkuOptionsDto[] | undefined;
    discount: DiscountDto;
}

export interface GetIntegrationSkuOptionItemsDto {
    optionItemId: number;
    price: number;
    calorie: number | undefined;
    isItemDefaultSelected: boolean;
    size: IntegrationSizeDto;
    name: LocalizedFieldDto;
    skuId: number;
    imageUrl: string | undefined;
    createdAt: string | undefined;
    updatedAt: string | undefined;
}

export interface GetIntegrationSkuOptionsDto {
    optionId: number;
    name: LocalizedFieldDto;
    minSelection: number;
    maxSelection: number;
    createdAt: string | undefined;
    updatedAt: string | undefined;
    optionItemsList: GetIntegrationSkuOptionItemsDto[] | undefined;
}

export interface GetItemDto {
    id: string;
    name: string | undefined;
    nameEn: string | undefined;
    nameAr: string | undefined;
    image: string | undefined;
    unitOfMeasure: string | undefined;
    subCategoryId: number;
    subCategoryName: string | undefined;
    categoryName: string | undefined;
    isActive: boolean;
    orderType: OrderType;
    unitOfMeasureType: UnitOfMeasure;
    brandName: LocalizedFieldDto;
    brandImageUrl: LocalizedFieldDto;
}

export interface GetItemDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetItemDto[] | undefined;
}

export interface GetMobileBannerAdsOutputDto {
    clickAction: BannerAdClickActions;
    clickActionValue: string | undefined;
    image: LocalizedFieldDto;
    type: BannerAdTypes;
    partnerId: string | undefined;
}

export interface GetPartnerAdsListResultDto {
    id: number;
    partnerId: string | undefined;
    name: string | undefined;
    from: string | undefined;
    to: string | undefined;
    timeZone: number;
    amount: number;
    isActive: boolean;
    status: AdsStatus;
    statusName: string | undefined;
}

export interface GetPartnerAdsListResultDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetPartnerAdsListResultDto[] | undefined;
}

export interface GetPartnerSizeTypesListDto {
    id: number;
    name: string | undefined;
    isActive: boolean;
}

export interface GetPartnerSizesListDto {
    id: number;
    name: string | undefined;
    nameLocalized: LocalizedFieldDto;
}

export interface GetPartnerStoreDeliveryTypeDto {
    storeId: string;
    types: DeliveryType[] | undefined;
}

export interface GetProductAdditionalSKUsListDto {
    id: number;
    code: string | undefined;
    unitPrice: number;
    isActive: boolean;
    isDefault: boolean;
    sizeId: number;
    sizeName: string | undefined;
    calorie: number | undefined;
    ordering: number | undefined;
    hasDiscount: boolean;
    priceAfterDiscount: number;
    maxQty: number;
    minQty: number;
    stepCount: number;
}

export interface GetProductByIdDto {
    id: number;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    code: string | undefined;
    productName: string | undefined;
    isActive: boolean;
    storeCategoryId: number;
    cuisineId: number | undefined;
    sizeId: number;
    maxComponentCount: number;
    unitPrice: number;
    calorie: number | undefined;
    imageUrl: string | undefined;
    skuId: number;
    storeCategoryName: string | undefined;
    imageId: number | undefined;
    ordering: number | undefined;
    minComponentCount: number;
    sizeTypeId: number | undefined;
    productType: ProductType;
    typeName: string | undefined;
    storeId: string;
}

export interface GetProductByIdDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetProductByIdDto[] | undefined;
}

export interface GetProductComponentDto {
    nameLocalized: LocalizedFieldDto;
    name: string | undefined;
    price: number;
    maxCount: number;
    componentId: number;
}

export interface GetProductComponentListDto {
    additions: GetProductComponentDto[] | undefined;
    canBeRemoved: GetProductComponentDto[] | undefined;
    maxComponentCount: number;
}

export interface GetProductSkuImagesDto {
    isDefault: boolean;
    imageUrl: string | undefined;
}

export interface GetProductSkuOptionItemDto {
    id: number;
    defaultSelected: boolean;
    name: string | undefined;
    skuId: number;
    skuOptionId: number;
    price: number;
}

export interface GetProductSkuOptionsDto {
    id: number;
    name: LocalizedFieldDto;
    optionName: string | undefined;
    skuId: number;
    sizeName: string | undefined;
    minSelection: number;
    maxSelection: number;
    ordering: number;
    options: GetProductSkuOptionItemDto[] | undefined;
}

export interface GetProductSkusDto {
    calorie: number | undefined;
    price: number;
    hasDiscount: boolean;
    priceAfterDiscount: number;
    size: string | undefined;
    sizeLocalized: LocalizedFieldDto;
    skuId: number;
    isDefault: boolean;
    skuName: string | undefined;
    skuNameLocalized: LocalizedFieldDto;
    order: number | undefined;
    images: GetProductSkuImagesDto[] | undefined;
    categoryTypeId: number;
    maxQty: number;
    minQty: number;
    stepCount: number;
}

export interface GetSkuOptionDto {
    name: string | undefined;
    minSelection: number;
    maxSelection: number;
    items: GetSkuOptionItemDto[] | undefined;
}

export interface GetSkuOptionItemDto {
    price: number;
    calorie: number | undefined;
    isItemDefaultSelected: boolean;
    size: string | undefined;
    name: string | undefined;
    nameLocalized: LocalizedFieldDto;
    skuId: number;
    imageUrls: string[] | undefined;
}

export interface GetStoreCategories {
    category: CategoryResponseDto;
    productList: GetStoreProducts[] | undefined;
    categoryAvailableHours: AvailableHourDto[] | undefined;
}

export interface GetStoreCategoryProductsListDto {
    categoryName: string | undefined;
    productList: GetCategoryProductsListDto[] | undefined;
}

export interface GetStoreCategoryProductsListMangedDto {
    categoryName: string | undefined;
    productList: GetCategoryProductsListMangedDto[] | undefined;
}

export interface GetStoreDealsOutputDto {
    image: LocalizedFieldDto;
    link: string | undefined;
}

export interface GetStoreProducts {
    id: number;
    code: string | undefined;
    imageUrl: string | undefined;
    description: LocalizedFieldDto;
    maxComponentCount: number;
    minComponentCount: number;
    price: number;
    isActive: boolean;
    name: LocalizedFieldDto;
    hasDiscount: boolean;
    priceAfterDiscount: number;
    productType: ProductType;
    createdAt: string | undefined;
    updatedAt: string | undefined;
    discount: DiscountDto;
    productAvailableHours: AvailableHourDto[] | undefined;
    skusList: GetIntegrationProductSkusDto[] | undefined;
}

export interface GetStoreSKUsDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
}

export interface GetStoreWorkingDaysWithStatisticsDto {
    day: DayOfWeek;
    workingShifts: StoreWorkingShiftsDto[] | undefined;
    totalWorkingHours: number;
    totalNotWorkingHours: number;
}

export interface GetStoresOutputDto {
    id: string | undefined;
    isBusy: boolean;
    logoUrl: string | undefined;
    storeCoverImageUrl: string | undefined;
    distanceFormatted: string | undefined;
    distance: number;
    isFavourite: boolean;
    rate: number | undefined;
    maxEstimationDeliveryTime: number;
    description: string | undefined;
    name: string | undefined;
    distanceFromDb: number;
    partnerId: string | undefined;
    deliveryFees: number;
    partnerDebitFare: number;
    isOutOfRange: boolean;
    location: LocationDto;
    minimumCharge: number | undefined;
    isAvailable: boolean;
    catalogOffersNotifications: string[] | undefined;
    storeWorkingHours: StoreWorkingHour[] | undefined;
    hasAds: boolean;
    twitterAccount: string | undefined;
    instagramAccount: string | undefined;
    youtubeAccount: string | undefined;
    facebookAccount: string | undefined;
    snapchatAccount: string | undefined;
    hasDiscount: boolean;
    discountSkusCount: number;
    maxDiscount: number;
    catalogDiscountType: CatalogDiscountType;
    isIntegration: boolean;
    addressDetails: Address;
    address: string | undefined;
    paymentType: PaymentType;
    paymentTypes: PaymentType[] | undefined;
    deliveryTypes: DeliveryType[] | undefined;
    cashbacks: StoreCashback[] | undefined;
    zoneId: number | undefined;
    cityId: number | undefined;
    storeCategoryTypeId: number;
}

export interface GetStoresOutputDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetStoresOutputDto[] | undefined;
}

export interface GetSubCategoryDto {
    id: number;
    name: string | undefined;
    nameEn: string | undefined;
    nameAr: string | undefined;
    orderType: OrderType;
    categoryName: string | undefined;
    imageUrl: string | undefined;
    isActive: boolean;
    ordering: number;
    parentSubCategoryId: number | undefined;
    parentSubCategoryName: string | undefined;
}

export interface GetSubCategoryDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: GetSubCategoryDto[] | undefined;
}

export interface GuidReOrderingDto {
    id: string;
    ordering: number;
}

export enum HorizntalBarContent {
    _1 = 1,
}

export enum HorizntalBarType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export interface IndustryDto {
    id: number;
    name: LocalizedFieldDto;
    image: LocalizedFieldDto;
    isService: boolean;
    color: string | undefined;
    isActive: boolean;
    orderType: OrderType;
}

export interface IndustryDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: IndustryDto[] | undefined;
}

export interface Int32ReOrderingDto {
    id: number;
    ordering: number;
}

export interface Int64ReOrderingDto {
    id: number;
    ordering: number;
}

export interface IntegrationSizeDto {
    id: number;
    name: LocalizedFieldDto;
    createdAt: string | undefined;
    updatedAt: string | undefined;
}

export interface IntegrationSkuDto {
    calorie: number | undefined;
    price: number;
    hasDiscount: boolean;
    priceAfterDiscount: number;
    size: IntegrationSizeDto;
    skuId: number;
    isDefault: boolean;
    name: LocalizedFieldDto;
    order: number | undefined;
    imageUrl: string | undefined;
    maxQty: number;
    minQty: number;
    stepCount: number;
    createdAt: string | undefined;
    updatedAt: string | undefined;
    discount: DiscountDto;
}

export interface ItemDto {
    id: string;
    name: LocalizedFieldDto;
    image: string | undefined;
    unitOfMeasure: UnitOfMeasure;
    subCategoryId: number;
    categoryName: LocalizedFieldDto;
    parentCategoryName: LocalizedFieldDto;
    orderType: OrderType;
    isActive: boolean;
    brandId: string | undefined;
    brandName: LocalizedFieldDto;
    brandImageUrl: LocalizedFieldDto;
}

export interface ItemDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: ItemDto[] | undefined;
}

export interface LocalizedAddressDto {
    ar: string | undefined;
    en: string | undefined;
}

export interface LocalizedField {
    ar: string | undefined;
    en: string | undefined;
}

export interface LocalizedFieldDto {
    ar: string | undefined;
    en: string | undefined;
}

export interface LocationDto {
    latitude: number;
    longitude: number;
}

export interface MobileMenuDto {
    id: string;
    name: LocalizedFieldDto;
    type: MobileMenuType;
    level: number;
    ordering: number;
    rowId: string | undefined;
    isActive: boolean;
}

export interface MobileMenuDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: MobileMenuDto[] | undefined;
}

export enum MobileMenuType {
    _1 = 1,
    _2 = 2,
}

export interface OrderItemOptionItemResponseDto {
    itemId: number;
    price: number;
}

export interface OrderItemOptionResponseDto {
    id: number;
    items: OrderItemOptionItemResponseDto[] | undefined;
}

export interface OrderItemResponseDto {
    skuId: number;
    productId: number;
    name: LocalizedFieldDto;
    quantity: number;
    imageUrl: string | undefined;
    unitPrice: number;
    itemDetails: string | undefined;
    options: OrderItemOptionResponseDto[] | undefined;
}

export enum OrderType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
}

export interface PartnerPaymentMethodDto {
    partnerId: string;
    isActive: boolean;
    paymentType: PaymentType;
}

export interface PartnerPaymentMethodInputDto {
    paymentType: string | undefined;
    partnerId: string;
    isActive: boolean;
}

export enum PaymentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export interface PaymentTypeDto {
    paymentTypeName: string | undefined;
    paymentTypeValue: PaymentType;
}

export interface ProductActivateDto {
    id: number;
    isActive: boolean;
}

export interface ProductAvailableHoursDto {
    id: number;
    day: DayOfWeek;
    from: string | undefined;
    to: string | undefined;
    allTime: boolean;
    productId: number;
    timeZone: number;
}

export interface ProductResponseDto {
    id: number;
    code: string | undefined;
    imageUrl: string | undefined;
    description: LocalizedFieldDto;
    maxComponentCount: number;
    minComponentCount: number;
    price: number;
    isActive: boolean;
    name: LocalizedFieldDto;
    hasDiscount: boolean;
    priceAfterDiscount: number;
    productType: ProductType;
    createdAt: string | undefined;
    updatedAt: string | undefined;
    discount: DiscountDto;
}

export interface ProductTagDto {
    id: number;
    name: LocalizedFieldDto;
    tagId: number;
}

export enum ProductType {
    _1 = 1,
    _2 = 2,
}

export interface RecentOrderDto {
    storeId: string;
    storeLogoUrl: string | undefined;
    storeName: LocalizedFieldDto;
    firstOrderItemName: LocalizedFieldDto;
    firstOrderItemDescription: LocalizedFieldDto;
    countOfRemainingItems: number;
    orderId: string;
    cartId: string;
    orderDate: moment.Moment;
    price: number;
    orderType: OrderType;
}

export interface RecentOrderResultDto {
    orders: RecentOrderDto[] | undefined;
    totalCount: number;
}

export interface RemoveParnterStoreDeliveryTypeDto {
    storeId: string;
    type: DeliveryType;
}

export interface ReorderDto {
    cartId: string | undefined;
    orderId: string | undefined;
    location: LocationDto;
}

export interface ReorderDtoV2 {
    cartId: string | undefined;
    orderId: string | undefined;
    location: LocationDto;
    orderType: OrderType;
}

export interface ReorderProductDto {
    orderingList: Int64ReOrderingDto[] | undefined;
}

export interface ReorderSKUDto {
    orderingList: Int64ReOrderingDto[] | undefined;
    storeIds: string[] | undefined;
    storeId: string | undefined;
}

export interface ReplaceCartItemsDto {
    orderType: OrderType;
    itemsList: AddCartItemDtoV2[] | undefined;
}

export interface SKUDto {
    id: number;
    code: string | undefined;
    unitPrice: number;
    price: number;
    maxQty: number | undefined;
    minQty: number | undefined;
    isActive: boolean;
    isDefault: boolean;
    sizeId: number | undefined;
    productId: number;
}

export interface SKUDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: SKUDto[] | undefined;
}

export interface SaveCatalogDeliveryZoneDto {
    id: string;
    deliveryZoneId: number;
    userId: string;
    fixedFare: number;
    isIntegrationFare: boolean;
    isActive: boolean;
}

export interface SaveDeliveryDistanceFareDto {
    id: string;
    userId: string;
    minimumDistance: number;
    minimumDistanceFees: number;
    extraDistance: number;
    extraDistanceFees: number;
    isIntegrationFare: boolean;
    isActive: boolean;
}

export interface SetParnterStoreDeliveryTypeDto {
    storeId: string;
    type: DeliveryType;
}

export interface SetPartnerIndusriesDto {
    patnerId: string | undefined;
    industries: number[] | undefined;
    storeCategoryTypes: number[] | undefined;
}

export interface SetProductAvailableHoursDto {
    storeId: string | undefined;
    storeIds: string[] | undefined;
    productId: number;
    availableHours: ProductAvailableHoursDto[] | undefined;
}

export interface SetStoreBusyDto {
    period: number | undefined;
    isBusy: boolean;
    storeId: string | undefined;
    notifyStore: boolean;
}

export interface SetStoreCategoryAvailableHoursDto {
    storeIds: string[] | undefined;
    storeCategoryId: number;
    availableHours: StoreCategoryAvailableHoursDto[] | undefined;
}

export interface SetStoreWorkingDaysDto {
    storeId: string;
    workingDays: SetWorkingDayDto[] | undefined;
}

export interface SetWorkingDayDto {
    day: DayOfWeek;
    workingFrom: string | undefined;
    workingTo: string | undefined;
}

export interface SizeDto {
    id: number;
    nameAr: string | undefined;
    name: string | undefined;
    nameEn: string | undefined;
    isActive: boolean;
    partnerId: string | undefined;
    ordering: number;
    sizeTypeId: number | undefined;
    sizeTypeName: string | undefined;
}

export interface SizeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: SizeDto[] | undefined;
}

export interface SizeTypeDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    name: string | undefined;
    isActive: boolean;
    partnerId: string | undefined;
}

export interface SizeTypeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: SizeTypeDto[] | undefined;
}

export interface StoreCashback {
    cashbackType: CashbackType;
    cashbackValue: number | undefined;
    cashbackMinValue: number | undefined;
    message: LocalizedFieldDto;
}

export interface StoreCategoryAvailableHoursDto {
    id: number;
    day: DayOfWeek;
    from: string | undefined;
    to: string | undefined;
    allTime: boolean;
    storeCategoryId: number;
    timeZone: number;
}

export interface StoreCategoryDto {
    id: number;
    descriptionAr: string | undefined;
    descriptionEn: string | undefined;
    nameAr: string;
    nameEn: string;
    name: string | undefined;
    description: string | undefined;
    ordering: number;
    imageUrl: string | undefined;
    isActive: boolean;
    parentStoreCategoryId: number | undefined;
    parentStoreCategoryName: string | undefined;
    storeId: string | undefined;
    storeName: string | undefined;
    storeCategoryTypeId: number | undefined;
    storeCategoryTypeName: string | undefined;
    code: string;
}

export interface StoreCategoryDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: StoreCategoryDto[] | undefined;
}

export interface StoreCategoryProductsListTotalMangedDto {
    all: number;
    active: number;
    inActive: number;
    categoryProductList: GetStoreCategoryProductsListMangedDto[] | undefined;
}

export interface StoreCategoryTypeActiveDto {
    id: number;
    name: string | undefined;
    imageUrl: string | undefined;
    industryId: number;
}

export interface StoreCategoryTypeActiveDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: StoreCategoryTypeActiveDto[] | undefined;
}

export interface StoreCategoryTypeDto {
    id: number;
    isActive: boolean;
    industryId: number;
    imageUrl: string | undefined;
    nameEn: string | undefined;
    nameAr: string | undefined;
    name: string | undefined;
    ordering: number;
    isMain: boolean;
    isMainForPartner: boolean;
    industryName: string | undefined;
}

export interface StoreCategoryTypeDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: StoreCategoryTypeDto[] | undefined;
}

export interface StoreDto {
    id: string;
    code: string | undefined;
    name: LocalizedFieldDto;
    address: LocalizedAddressDto;
    commercialRegistration: string | undefined;
    storeLogoUrl: string | undefined;
    storeCoverImageUrl: string | undefined;
    commercialRegistrationPhotoUrl: string | undefined;
    twitterAccount: string | undefined;
    instagramAccount: string | undefined;
    youtubeAccount: string | undefined;
    facebookAccount: string | undefined;
    snapchatAccount: string | undefined;
    isBusy: boolean;
    isActivated: boolean;
    hotline: string | undefined;
    maxEstimationDeliveryTime: number;
    isMainStore: boolean;
    location: LocationDto;
    partnerId: string | undefined;
    rate: number | undefined;
    description: LocalizedFieldDto;
    minimumCharge: number | undefined;
    busyUntil: moment.Moment;
    discountSkusCount: number;
    maxDiscount: number;
    lastDiscountTime: moment.Moment | undefined;
    lastDiscountTimeZone: number | undefined;
    isIntegration: boolean;
    catalogDiscountType: CatalogDiscountType;
    storeName: string | undefined;
    busyEndsAfterSeconds: number;
}

export interface StoreFilterInput {
    type: StoreFilterType;
    v: string[] | undefined;
}

export enum StoreFilterType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export interface StoreShiftDto {
    from: string | undefined;
    to: string | undefined;
}

export enum StoreSortingType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export interface StoreWeeklyShiftDto {
    day: DayOfWeek;
    shifts: StoreShiftDto[] | undefined;
}

export interface StoreWorkingDaysDto {
    id: number;
    day: DayOfWeek;
    workingFrom: string;
    workingTo: string;
    timeZone: number;
}

export interface StoreWorkingHour {
    workingFrom: string | undefined;
    workingTo: string | undefined;
    timeZone: number;
}

export interface StoreWorkingShiftsDto {
    workingFrom: string | undefined;
    workingTo: string | undefined;
}

export interface SubCategoryDto {
    id: number;
    name: LocalizedFieldDto;
    orderType: OrderType;
    imageUrl: string | undefined;
    isActive: boolean;
    ordering: number;
    parentSubCategoryId: number | undefined;
    parentCategoryName: LocalizedFieldDto;
    childsCount: number;
    childsName: string | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
}

export interface SubCategoryDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: SubCategoryDto[] | undefined;
}

export interface TagDto {
    id: number;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isActive: boolean;
}

export interface TagDtoPaginatedList {
    pageIndex: number;
    readonly totalPages: number;
    readonly totalCount: number;
    readonly hasPreviousPage: boolean;
    readonly hasNextPage: boolean;
    items: TagDto[] | undefined;
}

export enum UnitOfMeasure {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export interface UpdateAdditionalSkuDto {
    id: number;
    code: string | undefined;
    unitPrice: number;
    isActive: boolean;
    sizeId: number;
    calorie: number | undefined;
    productId: number;
    storeIds: string[] | undefined;
    storeId: string | undefined;
    ordering: number | undefined;
    maxQty: number;
    minQty: number;
    stepCount: number;
}

export interface UpdateBannerAdDto {
    id: string;
    type: BannerAdTypes;
    partnerId: string;
    from: string;
    to: string;
    timeZone: number;
    name: LocalizedFieldDto;
    image: LocalizedFieldDto;
    clickAction: BannerAdClickActions;
    cost: number;
    industries: number[];
    bannerAdPlacments: BannerAdPlacements[];
}

export interface UpdateBrandDto {
    id: string;
    name: LocalizedFieldDto;
    imageUrl: LocalizedFieldDto;
    isActive: boolean;
    orderType: OrderType;
}

export interface UpdateCartItemDto {
    id: string;
    quantity: number;
    itemDetail: string;
    skuId: number;
}

export interface UpdateCartItemDtoV2 {
    id: string;
    quantity: number;
    itemDetail: string;
    orderType: OrderType;
    skuId: number | undefined;
    itemId: string | undefined;
    itemName: string | undefined;
}

export interface UpdateCatalogDeliveryZoneDto {
    id: string;
    fixedFare: number;
}

export interface UpdateComponentDto {
    id: number;
    nameAr: string;
    nameEn: string;
    price: number;
    partnerId: string | undefined;
}

export interface UpdateCuisineDto {
    id: number;
    isActive: boolean;
    nameAr: string;
    descriptionAr: string;
    nameEn: string;
    descriptionEn: string;
    imageUrl: string;
}

export interface UpdateDealsDto {
    id: string;
    type: DealType;
    image: LocalizedField;
    minValue: number;
    isActive: boolean;
    color: string | undefined;
    maxValue: number;
    discountType: CatalogDiscountType;
    name: LocalizedFieldDto;
}

export interface UpdateDeliveryDistanceFareDto {
    id: string;
    minimumDistance: number;
    minimumDistanceFees: number;
    extraDistance: number;
    extraDistanceFees: number;
    isActive: boolean;
}

export interface UpdateDeliveryZoneDto {
    id: number;
    minimumDistance: number;
    maximumDistance: number;
}

export interface UpdateHorizontalBarDto {
    id: string;
    name: LocalizedFieldDto;
    countOfSepCells: number;
    template: number;
    content: HorizntalBarContent;
    partners: string[] | undefined;
    bannerImageUrl: LocalizedFieldDto;
}

export interface UpdateIndustryDto {
    id: number;
    name: LocalizedFieldDto;
    image: LocalizedFieldDto;
    isService: boolean;
    color: string;
    isActive: boolean;
    orderType: OrderType;
}

export interface UpdateItemDto {
    id: string;
    name: LocalizedFieldDto;
    image: string | undefined;
    attachedFiles: AttachmentCreateDto[] | undefined;
    unitOfMeasure: UnitOfMeasure;
    isActive: boolean;
    subCategoryId: number;
    brandId: string | undefined;
}

export interface UpdateMobileMenuDto {
    id: string;
    type: MobileMenuType;
    level: number;
    ordering: number;
    rowId: string;
    isActive: boolean;
}

export interface UpdateProductComponentDto {
    id: number;
    productId: number;
    componentId: number;
    isDefault: boolean;
    maxCount: number;
    storeIds: string[] | undefined;
    storeId: string;
}

export interface UpdateProductDto {
    id: number;
    code: string;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    isActive: boolean;
    storeCategoryId: number;
    cuisineId: number | undefined;
    maxComponentCount: number;
    storeIds: string[] | undefined;
    defaultSku: UpdateSKUDto;
    storeId: string | undefined;
    tagIds: number[] | undefined;
    sizeTypeId: number | undefined;
    minComponentCount: number;
    productType: ProductType;
    updateUnitPriceForAllStores: boolean;
    ordering: number | undefined;
}

export interface UpdateSKUDto {
    id: number;
    code: string;
    unitPrice: number;
    isActive: boolean;
    isDefault: boolean;
    sizeId: number;
    images: UpdateSKUImageDto[] | undefined;
    productId: number;
    calorie: number | undefined;
    maxQty: number;
    minQty: number;
    stepCount: number;
}

export interface UpdateSKUImageDto {
    skuImageId: number;
    attachment: AttachmentCreateDto;
    isDefault: boolean;
}

export interface UpdateSizeDto {
    id: number;
    isActive: boolean | undefined;
    nameAr: string;
    nameEn: string;
    partnerId: string | undefined;
    sizeTypeId: number | undefined;
}

export interface UpdateSizeTypeDto {
    id: number;
    isActive: boolean | undefined;
    nameAr: string;
    nameEn: string;
    partnerId: string | undefined;
}

export interface UpdateSkuOption {
    storeId: string | undefined;
    storeIds: string[] | undefined;
    id: number;
    skuId: number | undefined;
    name: LocalizedFieldDto;
    minSelection: number;
    maxSelection: number;
    ordering: number | undefined;
}

export interface UpdateStoreCategoryDto {
    id: number;
    isActive: boolean | undefined;
    parentStoreCategoryId: number | undefined;
    storeCategoryTypeId: number;
    nameAr: string;
    nameEn: string;
    imageUrl: string;
    descriptionAr: string;
    descriptionEn: string;
    storeIds: string[] | undefined;
}

export interface UpdateStoreCategoryTypeDto {
    id: number;
    isActive: boolean | undefined;
    industryId: number;
    imageUrl: string | undefined;
    nameAr: string | undefined;
    nameEn: string | undefined;
    isMain: boolean;
}

export interface UpdateStoreDto {
    id: string | undefined;
    name: LocalizedFieldDto;
    description: LocalizedFieldDto;
    commercialRegistration: string | undefined;
    storeLogoName: string | undefined;
    storeLogoContent: string | undefined;
    storeLogoUrl: string | undefined;
    commercialRegPhotoName: string | undefined;
    commercialRegPhotoContent: string | undefined;
    commercialRegistrationPhotoUrl: string | undefined;
    twitterAccount: string | undefined;
    instagramAccount: string | undefined;
    youtubeAccount: string | undefined;
    facebookAccount: string | undefined;
    snapchatAccount: string | undefined;
    partnerId: string | undefined;
    isAvailable: boolean;
    isActivated: boolean;
    hotline: string | undefined;
    maxEstimationDeliveryTime: number;
    isMainStore: boolean;
    location: LocationDto;
    workingDays: StoreWorkingDaysDto[] | undefined;
    storeCoverImageName: string | undefined;
    storeCoverImageContent: string | undefined;
    storeCoverImageUrl: string | undefined;
    code: string | undefined;
    sessionUserId: string | undefined;
    minimumCharge: number | undefined;
    forAllStores: boolean;
    address: LocalizedAddressDto;
}

export interface UpdateSubCategoryDto {
    id: number;
    nameAr: string;
    nameEn: string;
    orderType: OrderType;
    ordering: number;
    isActive: boolean;
    imageUrl: string | undefined;
    parentSubCategoryId: number | undefined;
}

export interface UpdateTagDto {
    id: number;
    isActive: boolean | undefined;
    nameAr: string;
    nameEn: string;
}

export interface UserFavoriteStoreDto {
    id: number;
    storeId: string;
    storeName: string | undefined;
    storeLogoUrl: string | undefined;
    description: string | undefined;
    industeyName: string | undefined;
    rate: number | undefined;
    distance: number;
    deliveryFee: number;
}

export interface ValidateOrderItemsInputDto {
    storeId: string;
    items: CatalogOrderItem[] | undefined;
}

export interface ValidateOrderItemsResponseDto {
    items: OrderItemResponseDto[] | undefined;
    storeLocation: LocationDto;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}